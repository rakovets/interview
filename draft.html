<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Общие</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Общие</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_что_такое_ооп">Что такое ООП?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_преимущества_у_ооп">Какие преимущества у ООП?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Возможность легкой модификации (при грамотном анализе и проектировании)</p>
</li>
<li>
<p>Возможность отката при наличии версий</p>
</li>
<li>
<p>Более легкая расширяемость</p>
</li>
<li>
<p>«Более естественная» декомпозиция программного обеспечения, которая существенно облегчает его разработку</p>
</li>
<li>
<p>Сокращение количества межмодульных вызовов и уменьшение объемов информации, передаваемой̆ между модулями</p>
</li>
<li>
<p>Увеличивается показатель повторного использования кода</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_недостатки_у_ооп">Какие недостатки у ООП?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Требуется другая квалификация</p>
</li>
<li>
<p>Резко увеличивается время на анализ и проектирование систем</p>
</li>
<li>
<p>Увеличение времени выполнения</p>
</li>
<li>
<p>Размер кода увеличивается</p>
</li>
<li>
<p>Неэффективно с точки зрения памяти (мертвый код - тот, который не используется)</p>
</li>
<li>
<p>Сложность распределения работ на начальном этапе</p>
</li>
<li>
<p>Себестоимость больше</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_назовите_основные_принципы_ооп">Назовите основные принципы ООП</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Абстракция</p>
</li>
<li>
<p>Инкапсуляция</p>
</li>
<li>
<p>Наследование</p>
</li>
<li>
<p>Полиморфизм</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_инкапсуляция_с_примером">Что такое инкапсуляция? (С примером)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.</p>
</div>
<div class="paragraph">
<p>Инкапсуляция – это механизм «обёртывания» данных или кода, который работает с этими данными в отдельный модуль. Инкапсулированные, таким образом, переменные, отделены от других классов и доступ к ним возможен только с помощью методов класса, который содержит эти переменные.</p>
</div>
<div class="paragraph">
<p>Пример: нажимая на педаль газа, мы не знаем и не понимаем что происходит под капотом, класс Автомобиль скрыл от нас реализацию и дал нам инструменты (методы) для работы с этой реализацией.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_наследование_с_примером">Что такое наследование? (С примером)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего, частично или полностью заимствуя функциональность родителя. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.</p>
</div>
<div class="paragraph">
<p>Пример: есть человек родитель, его потомок наследует от него его характеристики, добавляя что-то свое.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_полиморфизм_с_примером">Что такое полиморфизм? (С примером)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Полиморфизм – это свойство системы использовать объекты с общим интерфейсом или классом родителем, без информации о типе и внутренней структуре объекта.</p>
</div>
<div class="paragraph">
<p>Пример: человек может есть еду в общем, будь-то ягоды, овощи или мясо.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_ассоциация_агрегация_и_композиция">Что такое ассоциация, агрегация и композиция?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Реализуют has-a (имеет) отношения.</p>
</div>
<div class="paragraph">
<p>has-a отношения основаны на использовании. Выделяют три варианта отношения has-a: ассоциация, агрегация и композиция.</p>
</div>
<div class="paragraph">
<p><strong>Ассоциация</strong> - это когда объекты двух классов могут ссылаться друг на друга. Например, класс Horse has-a Halter если код в классе Horse содержит ссылку на экземпляр класса Halter.</p>
</div>
<div class="paragraph">
<p>Агрегация и композиция являются частными случаями ассоциации.</p>
</div>
<div class="paragraph">
<p><strong>Агрегация</strong> - отношение, когда один объект является частью другого.</p>
</div>
<div class="paragraph">
<p>*Композиция *- еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту.</p>
</div>
<div class="paragraph">
<p><strong>Агрегация</strong>: объект класса Halter создается извне Horse и передается в конструктор для установления связи, если объект класса Horse будет удален, объект класса Halter может и дальше использоваться, если, конечно, на него останется ссылка.</p>
</div>
<div class="paragraph">
<p><strong>Композиция</strong>: объект класса Halter создается в конструкторе, что означает более тесную связь между объектами, объект класса Halter не может существовать без создавшего его объекта Horse.&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_значит_является_is_a_имеет_has_a">"Что значит является - ""is a"", имеет - ""has a""?"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>«является» подразумевает наследование.</p>
</div>
<div class="paragraph">
<p>«имеет» подразумевает ассоциацию (агрегацию или композицию).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_раннее_статическое_и_позднее_динамическое_связывание">Расскажите про раннее (статическое) и позднее (динамическое) связывание</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).</p>
</div>
<div class="paragraph">
<p>В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.</p>
</div>
<div class="paragraph">
<p>Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не статический и не был объявлен как final (приватные методы являются final по умолчанию).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_solid">Расскажите про SOLID</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Принцип единственной ответственности</strong> - класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.</p>
</div>
<div class="paragraph">
<p><strong>Принцип открытости-закрытости</strong>- программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.</p>
</div>
<div class="paragraph">
<p><strong>Принцип подстановки Барбары Лисков</strong> - необходимо, чтобы подклассы могли служить заменой для своих суперклассов.</p>
</div>
<div class="paragraph">
<p>Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.</p>
</div>
<div class="paragraph">
<p><strong>Принцип разделения интерфейса</strong> - создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют. Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.</p>
</div>
<div class="paragraph">
<p><strong>Принцип инверсии зависимостей</strong>- объектом зависимости должна быть абстракция, а не что-то конкретное. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</p>
</div>
<div class="paragraph">
<p>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. В процессе разработки программного обеспечения существует момент, когда функционал приложения перестает помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какова_основная_идея_языка">Какова основная идея языка?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Кроссплатформенность - в основу Java положен принцип WORA «Write Once Run Anywhere», на русском «Написано один раз, работает везде».</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_за_счет_чего_обеспечивается_кроссплатформенность">За счет чего обеспечивается кроссплатформенность?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Кроссплатформенность достигается за счет использования виртуальной машины «Java Virtual Machine» – JVM.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_преимущества_у_java">Какие преимущества у Java?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Кроссплатформенность</strong> - благодаря JVM</p>
</li>
<li>
<p><strong>Безопасность</strong> - напиример использование классов, имеющих цифровую подпись. Полные права предоставляются только при полном доверии автору класса</p>
</li>
<li>
<p><strong>Простота</strong> – первое техническое достоинство Java. У него чёткие синтаксические правила и понятная семантика. Рациональность и краткость очень полезны для обработки кода машинами с ограниченным объёмом ресурсов</p>
</li>
<li>
<p>*Объектно-ориентированный подход - з*а 3 десятилетия он доказал свою эффективность. Суть состоит в том, что в центре внимания находятся данные (объекты), интерфейсы и алгоритмы вторичны. Другими словами, мы отталкиваемся от результата при выборе инструментов, способов их применения</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_недостатки_у_java">Какие недостатки у Java?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>*Производительность *-  в отличие от языков C или С, вместо компилятора у Java применяется виртуальная машина JVM. Это несколько снижает скорость исполнения Java-кода, так как сначала процессору нужно запустить JVM, а потом она начинает выполнять код. Считается, что ПО на Java работает медленнее, чем такие же программы на C/C</p>
</li>
<li>
<p>*Количество кода *- помимо прочего, Java отличается от других популярных языков (например, Python) довольно длинными и объемными конструкциями кода. Это фактор может сделать язык весьма запутанным для начинающих программистов</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jdk_что_в_него_входит">Что такое JDK? Что в него входит?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java Development Kit - набор инструментов разработчика.</p>
</div>
<div class="paragraph">
<p>В JDK входят:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java Virtual Machine (JVM) - виртуальная машина для запуска байт кода</p>
</li>
<li>
<p>Java Runtime Environment (JRE) - минимальная реализация виртуальной машины, необходимая для запуска Java приложений, не содержит инструментов разработки</p>
</li>
<li>
<p>Java Development Tools - другие инструменты для разработки приложений</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_byte_code">Что такое byte code?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Набор инструкций, исполняемых виртуальной машиной Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_загрузчик_классов_classloader">Что такое загрузчик классов «classloader»?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM. Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах благодаря загрузчику классов. Делегирование является важной концепцией, которую выполняет загрузчик. Загрузчик классов отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. Эта загрузка обычно выполняется «по требованию», поскольку она не происходит до тех пор, пока программа не вызовет класс. Класс с именем может быть загружен только один раз данным загрузчиком классов.</p>
</div>
<div class="paragraph">
<p>При запуске JVM, используются три загрузчика классов:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Bootstrap</strong> class loader (Загрузчик класса Bootstrap)</p>
</li>
<li>
<p><strong>Extensions</strong> class loader (Загрузчик класса расширений)</p>
</li>
<li>
<p><strong>System</strong> class loader (Системный загрузчик классов)</p>
<div class="ulist">
<ul>
<li>
<p>Загрузчик класса Bootstrap загружает основные библиотеки Java, расположенные в папке <code>&lt;JAVA_HOME&gt;/jre/lib</code>. Этот загрузчик является частью ядра JVM, написан на нативном коде.</p>
</li>
<li>
<p>Загрузчик класса расширений загружает код в каталоги расширений (<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>, или любой другой каталог, указанный системным свойством <code>java.ext.dirs</code>).</p>
</li>
<li>
<p>Системный загрузчик загружает код, найденный в <code>java.class.path</code>, который сопоставляется с переменной среды <code>CLASSPATH</code>. Это реализуется классом <code>sun.misc.Launcher$AppClassLoader</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jit">Что такое JIT?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just-in-time compilation, компиляция «на лету» – технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_сборщик_мусора_garbage_collector">Что такое сборщик мусора? (Garbage collector)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сборщик мусора - это программа, которая работает на виртуальной машине Java и избавляется от объектов, которые больше не используются приложением Java. Это форма автоматического управления памятью.</p>
</div>
<div class="paragraph">
<p>Сборщик мусора Garbage Collector выполняет всего две задачи, связанные с поиском мусора и его очисткой. Для обнаружения мусора существует два подхода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reference counting – учет ссылок;</p>
</li>
<li>
<p>Tracing – трассировка.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Суть подхода «Reference counting» связана с тем, что каждый объект имеет счетчик, который хранит информацию о количестве указывающих на него ссылок. При уничтожении ссылки счетчик уменьшается. При нулевом значении счетчика объект можно считать мусором.</p>
</div>
<div class="paragraph">
<p>Главным недостатком данного подхода является сложность обеспечения точности счетчика и «невозможность» выявлять циклические зависимости. Так, например, два объекта могут ссылаться друг на друга, но ни на один из них нет внешней ссылки. Это сопровождается утечками памяти. В связи с этим данный подход не получил распространения.</p>
</div>
<div class="paragraph">
<p>Главная идея «Tracing» связана с тем, что до «живого» объекта можно добраться из корневых точек (GC Root). Всё, что доступно из «живого» объекта, также является «живым». Если представить все объекты и ссылки между ними как дерево, то необходимо пройти от корневых узлов GC Roots по всем узлам. При этом узлы, до которых нельзя добраться, являются мусором.</p>
</div>
<div class="paragraph">
<p>Данный подход, обеспечивающий выявление циклических ссылок, используется в виртуальной машине HotSpot VM.</p>
</div>
<div class="paragraph">
<p>JVM HotSpot использует алгоритм сборки мусора типа «Generational Garbage Collection», который позволяет применять разные модули для разных этапов сборки мусора. Всего в HotSpot реализовано четыре сборщика мусора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Serial (последовательный)</strong>  - Первый, примитивный. Прямой как палка. Для сборки мусора полностью останавливает JVM и собирает мусор в один поток.</p>
</li>
<li>
<p><strong>Parallel (параллельный)</strong> - Попытка сделать сборку быстрой и многопоточной. На многоядерных процессорах это хорошо работает. Но все равно для сборки он требует полного останова JVM. Использовался по умолчанию до Java 9. В новых версиях Java он продолжает совершенствоваться и дополняться новыми опциями, так что для каких-то особых приложений можно не обращаться к новым сборщикам мусора. Справится и улучшенный Parallel GC.</p>
</li>
<li>
<p><strong>Concurrent Mark Sweep (CMS)</strong> - Цель — отсрочить полную сборку мусора с остановом JVM путем маленьких и коротких операций по сбору сведений о мусоре, а потом путём быстрых и коротких операций — убрать, что можно. Если достигается определенный процент использованного heap, т.е. CMS-сборщик видит, что не справляется, то JVM останавливается и происходит полная сборка мусора.</p>
</li>
<li>
<p><strong>Garbage-First (G1)</strong> - Впервые появился как экспериментальный в JDK6u14, а начиная с JDK7 Update 4 — как официальный. В Java 9 он теперь включен по умолчанию. Мейнстрим на несколько релизов Java вперед. Поколенческий, как и все предыдущие сборщики, но зоны поколений реализованы несколько иначе. Постоянно совершенствуется. В новых версиях Java 11 и Java 12 добавляются новые функции.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_поколения_объектов">Что такое поколения объектов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Young Generation (молодое поколение)</strong>. Здесь создаются новые объекты. Область young generation разделена на три части раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).&lt;/div&gt;</p>
</li>
<li>
<p><strong>Old Generation (старое поколение)</strong>. Здесь хранятся давно живущие объекты.&lt;/div&gt;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_finalize_зачем_он_нужен">Что такое finalize()? Зачем он нужен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Через вызов метода finalize() JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (garbage collector) и переопределяя finalize() можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.</p>
</div>
<div class="paragraph">
<p>После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода finalize() т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора. Объект не обязательно будет доступен для сборки сразу же - метод finalize() может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_heap_и_stack_память_в_java_чем_они_отличаются">Что такое Heap и Stack память в Java? Чем они отличаются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.</p>
</div>
<div class="paragraph">
<p>Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO (Последний-зашел-Первый-вышел)</p>
</div>
<div class="paragraph">
<p>Различия между Heap и Stack памятью:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы</p>
</li>
<li>
<p>Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче</p>
</li>
<li>
<p>Объекты в куче доступны с любой точке программы, в то время как стековая память не может быть доступна для других потоков</p>
</li>
<li>
<p>Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы</p>
</li>
<li>
<p>Если память стека полностью занята, то Java Runtime бросает исключение java.lang.StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space</p>
</li>
<li>
<p>Размер памяти стека намного меньше памяти в куче</p>
</li>
<li>
<p>Из-за простоты распределения памяти, стековая память работает намного быстрее кучи</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для определения начального и максимального размера памяти в куче используются -Xms и -Xmx опции JVM. Для стека определить размер памяти можно с помощью опции -Xss.</p>
</div>
<div class="paragraph">
<p><strong>Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?</strong></p>
</div>
<div class="paragraph">
<p>Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_примитивные_типы_данных_есть_в_java">Какие примитивные типы данных есть в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Java есть 8 примитивных типов, которые делят на 4 группы, вот они:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Целые числа - byte, short, int, long</p>
</li>
<li>
<p>Числа с плавающей точкой (иначе вещественные) - float, double</p>
</li>
<li>
<p>Логический - boolean</p>
</li>
<li>
<p>Символьный - char</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_char">Что такое char?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Символьный тип char: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта, поэтому диапазон хранимых значений от 0 до 65535.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_сколько_памяти_занимает_boolean">Сколько памяти занимает boolean?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>boolean занимает 4 байта, но когда находится в массиве 1 байт.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_классы_обертки">Что такое классы-обертки?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если требуется создать ссылку на один из примитивных типов данных, необходимо использовать соответствующий класс-обертку. Также в таких классах есть некоторые полезные методы и константы. Оборачивание примитива в объект называется упаковкой (boxing), а обратный процесс распаковкой (unboxing).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_автоупаковка_и_автораспаковка">Что такое автоупаковка и автораспаковка?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Автоупаковка (autoboxing) — это процесс автоматической инкапсуляции данных простого типа, такого как int или double, в эквивалентную ему оболочку типа, как только понадобится объект этого типа. При этом нет необходимости в явном создании объекта нужного типа.</p>
</div>
<div class="paragraph">
<p>Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора “=”), либо при передаче примитива в параметры метода (типа класса-обертки).</p>
</div>
<div class="paragraph">
<p>Автораспаковка (auto-unboxing) — это процесс автоматического извлечения из упакованного объекта значения, когда оно потребуется.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_явное_и_неявное_приведение_типов_в_каких_случаях_в_java_нужно_использовать_явное_приведение">Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда в одной операции вовлечены данные разных типов, не всегда необходимо использовать операцию преобразования типов. Некоторые виды преобразований выполняются неявно, автоматически.</p>
</div>
<div class="paragraph">
<p>Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) - они расширяют представление объекта в памяти:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;byte -&gt; short -&gt; int -&gt; long
int -&gt; double
short -&gt; float -&gt; double
char -&gt; int</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типу с меньшей разрядностью. Это следующие цепочки преобразований:</p>
</div>
<div class="paragraph">
<p>int -&gt; float, long -&gt; float и long -&gt; double</p>
</div>
<div class="paragraph">
<p>Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.</p>
</div>
<div class="paragraph">
<p>Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_пул_интов">Что такое пул интов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"Integer pool - это пул где хранятся значения от -128 до 127, когда классу обертке Integer присваивается значения через «=», двум разным ссылкам присваивается один и тот же кэшированный объект:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Integer a = 120;

Integer b = 120;

Integer c = 130;

Integer d = 130;

System.&lt;span style=""font-style: italic;""&gt;out&lt;/span&gt;.println(a == b); -&amp;gt; true

System.&lt;span style=""font-style: italic;""&gt;out&lt;/span&gt;.println(c == d); -&amp;gt; false</code></pre>
</div>
</div>
<div class="paragraph">
<p>"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_нюансы_у_строк_в_java">Какие нюансы у строк в Java?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>String неизменяемый класс, то есть однажды созданную строку нельзя изменить</p>
</li>
<li>
<p>Когда объект String создается через строковый литерал, он помещается в String Pool, строки созданные через ключевое слово «new» не помещаются в пул строк, а хранятся просто в куче (heap)</p>
</li>
<li>
<p>Созданную через «new» строку можно интернировать методом Intern()</p>
</li>
<li>
<p>Строки можно конкатенировать через оператор<br></p>
</li>
<li>
<p>С Java 7 строки можно использовать в конструкции «switch»</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_пул_строк">Что такое пул строк?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>String Pool</strong> - это область памяти в куче (heap), где хранятся интернированные строки или строки которые созданы через строковый литерал.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_не_рекомендуется_изменять_строки_в_цикле_что_рекомендуется_использовать">Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Потому что при каждом изменени строки, создается новый объект String и по итогу создается столько объектов, сколько итераций в цикле. Рекомендуется использовать StringBuilder или StringBuffer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_строки_не_рекомендуется_использовать_для_хранения_паролей">Почему строки не рекомендуется использовать для хранения паролей?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс String неизменяемый и хранится в пуле строк. Строка остается в пуле строк, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, он остается доступным в памяти некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.</p>
</div>
<div class="paragraph">
<p>Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, свойственного строке.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_string_неизменяемый_и_финализированный_класс">Почему String неизменяемый и финализированный класс?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Неизменяемость строки дала возможность создать String Pool, который сохраняет больше памяти в куче (heap)</p>
</li>
<li>
<p>Неизменяемость строки обеспечила безопасность данных, если бы строка была mutable, у злоумышленников была бы возможность изменять значения строки по ссылке</p>
</li>
<li>
<p>Неизменяемость строки сделала безопасным её использования в работе с несколькими потоками</p>
</li>
<li>
<p>Из-за неизменяемости строки, её hashCode кэшируется в момент создания и нет необходимости рассчитывать его снова, это сделал String идеальным кандидатом на роль ключа в HashMap</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_строка_является_популярным_ключом_в_hashmap_в_java">Почему строка является популярным ключом в HashMap в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Поскольку строки неизменны, их хэшкод кэшируется в момент создания и не требует повторного пересчета. Они обрабатываются быстрее, чем другие объекты-ключи.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_делает_метод_intern_в_классе_string">Что делает метод intern() в классе String?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Помещает строку из кучи в String Pool, если в пуле нет строк с таким значением, иначе возвращает ссылку на строку из String Pool.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_использовать_строки_в_конструкции_switch">Можно ли использовать строки в конструкции switch?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, начиная с Java 7 в операторе switch можно использовать строки.</p>
</div>
<div class="paragraph">
<p>При этом:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>участвующие строки чувствительны к регистру</p>
</li>
<li>
<p>используется метод equals() для сравнения полученного значения со значениями case, поэтому во избежание NullPointerException стоит предусмотреть проверку на null</p>
</li>
<li>
<p>согласно документации, Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_основная_разница_между_string_stringbuffer_stringbuilder">Какая основная разница между String, StringBuffer, StringBuilder?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс <code>String</code> является неизменяемым (immutable) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</p>
</div>
<div class="paragraph">
<p>Класс <code>StringBuffer</code> изменяемый - использовать <code>StringBuffer</code> следует тогда, когда необходимо часто модифицировать содержимое.</p>
</div>
<div class="paragraph">
<p>Класс <code>StringBuilder</code> был добавлен в Java 5 и он во всем идентичен классу <code>StringBuffer</code> за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_существуют_ли_в_java_многомерные_массивы">Существуют ли в java многомерные массивы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, это массив массивов.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int[][] numbers = new int[3][3];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какими_значениями_инициируются_переменные_по_умолчанию">Какими значениями инициируются переменные по умолчанию?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В рамках класса поля (fields) инициализируются значениями по умолчанию (0, 0.0, null, false).</p>
</div>
<div class="paragraph">
<p>В рамках метода локальные переменные (local variables) обязательно должны быть инициализированы до использования.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_сигнатура_метода">Что такое сигнатура метода?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сигнатура метода — это имя метода и его параметры (порядок параметров имеет значение). В сигнатуру метода не входит возвращаемое значение и бросаемые им исключения.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;Контракт метода:&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p><strong>public void doSome(int x, int y) throw IOException{};</strong></p>
</div>
<div class="paragraph">
<p>&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>Его сигнатура:&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p><strong>doSome(int x, int y)</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_main">Расскажите про метод main</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Точка входа в программу</p>
</li>
<li>
<p>Может находиться в любом обычном классе</p>
</li>
<li>
<p>Статический</p>
</li>
<li>
<p>Принимает входной параметр – массив строк</p>
</li>
<li>
<p>В приложении может быть несколько таких методов</p>
</li>
<li>
<p>Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка «Error: Main method not found»</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_переменные_передаются_в_методы_по_значению_или_по_ссылке">Каким образом переменные передаются в методы, по значению или по ссылке?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Премитивные типы по значению</p>
</li>
<li>
<p>Объекты по ссылке</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>То есть если изменить значение поля какого-то объекта в методе, то оно изменится и за пределами метода, если же изменить значение премитивного типа в методе, за пределами метода оно останется каким было.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_виды_классов_есть_в_java">Какие виды классов есть в java?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Обычный класс - public class * {}</p>
</li>
<li>
<p>Абстракнтный класс - public abstract class * {}</p>
</li>
<li>
<p>Финальный класс - public final class * {}</p>
</li>
<li>
<p>Интерфейс - public interface * {}</p>
</li>
<li>
<p>Enum - public enum * {}</p>
</li>
<li>
<p>Вложенный класс - public class Outer { class Inner {} }</p>
</li>
<li>
<p>Статический вложенный класс - public class Outer { static class Inner {} }</p>
</li>
<li>
<p>Локальный внутренний класс -  public class Outer { public void doSome() { class Inner {} } }</p>
</li>
<li>
<p>Анонимный класс :</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thread thread = new Thread() {[source, java]</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    @Override

    public void run() {

 System.&lt;span style=""font-style: italic;""&gt;out&lt;/span&gt;.println(""sd"");

    }

};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_вложенные_классы_в_каких_случаях_они_применяются">Расскажите про вложенные классы. В каких случаях они применяются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс называется вложенным (Nested class), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.</p>
</div>
<div class="paragraph">
<p>Если связь между объектом внутреннего класса и объектом внешнего класса не нужна, можно сделать внутренний класс статическим (static). Такой класс называют вложенным (nested).</p>
</div>
<div class="paragraph">
<p>Существуют четыре категории вложенных классов: + Static nested class (Статический вложенный класс); + Member inner class (Простой внутренний класс); + Local inner class (Локальный класс); + Anonymous inner class (Анонимный класс).</p>
</div>
<div class="paragraph">
<p>Такие категории классов, за исключением первого, также называют внутренними (Inner class). Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>
</div>
<div class="paragraph">
<p>Inner classes — внутренние классы (они же — non static nested classes, нестатические вложенные классы). Static nested classes - вложенные статические классы.&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_локальный_класс_каковы_его_особенности">Что такое «локальный класс»? Каковы его особенности?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.</p>
</div>
<div class="paragraph">
<p>Локальные классы имеют следующие особенности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Видны только в пределах блока, в котором объявлены</p>
</li>
<li>
<p>Не могут быть объявлены как private/public/protected или static</p>
</li>
<li>
<p>Не могут иметь внутри себя статических объявлений (полей, методов, классов)</p>
</li>
<li>
<p>Имеют доступ к полям и методам обрамляющего класса</p>
</li>
<li>
<p>Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_анонимные_классы_где_они_применяются">Что такое «анонимные классы»? Где они применяются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.</p>
</div>
<div class="paragraph">
<p>Анонимные классы имеют несколько ограничений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Их использование разрешено только в одном месте программы - месте его создания</p>
</li>
<li>
<p>Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться</p>
</li>
<li>
<p>Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Анонимные классы обычно применяются для:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создания объекта функции (function object), например реализация интерфейса Comparator</p>
</li>
<li>
<p>создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных</p>
</li>
<li>
<p>в статическом методе генерации</p>
</li>
<li>
<p>инициализации открытого статического поля final, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_из_вложенного_класса_получить_доступ_к_полю_внешнего_класса">Каким образом из вложенного класса получить доступ к полю внешнего класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.</p>
</div>
<div class="paragraph">
<p>Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр.</p>
</div>
<div class="paragraph">
<p>Например: Outer.this.field</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_перечисления_enum">Что такое перечисления (enum)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>enum – это класс перечислений. При объявлении переменной типа enum неявно создается класс производный от java.lang.Enum.</p>
</div>
<div class="paragraph">
<p>enum – это список именованных констант. Но в Java перечисления имеют более сложный функционал, чем в других языках программирования. Они могут иметь конструкторы, методы и переменные экземпляра.</p>
</div>
<div class="paragraph">
<p>Особенности enum классов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Конструктор всегда private или default</p>
</li>
<li>
<p>Могут имплементировать интерфейсы</p>
</li>
<li>
<p>Не могут наследовать класс</p>
</li>
<li>
<p>Можем переопределить toString()</p>
</li>
<li>
<p>Нет public конструктора, поэтому нельзя создать экземпляр вне Enum</p>
</li>
<li>
<p>При equals() выполняется ==</p>
</li>
<li>
<p>ordinal() возвращает порядковый номер элемента</p>
</li>
<li>
<p>Может использоваться в TreeSet и TreeMap так как enum имплементирует Comparable</p>
</li>
<li>
<p>compareTo() имитирует порядок элементов предоставляемый ordinal()</p>
</li>
<li>
<p>Можно использовать в Switch Case</p>
</li>
<li>
<p>values() возвращает массив всех констант</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_проблема_ромбовидного_наследования_решена_в_java">Как проблема ромбовидного наследования решена в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Множественное наследование может привести к проблеме ромба – когда один класс наследуется от двух, а те наследуются от одного предка. В Java не поддерживается множественное наследование классов, но допустимо множественное наследование интерфейсов. Интерфейсы только объявляют методы, а фактическая реализация будет сделана в конкретных классах, которые реализуют интерфейсы, так что нет никакой возможности двусмысленно трактовать множественное наследование в интерфейсе.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_конструктор_по_умолчанию">Что такое конструктор по умолчанию?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Конструктор по умолчанию (default constructor) – это конструктор, который не имеет параметров. Конструктор по умолчанию может объявляться в классе явным образом или генерироваться автоматически.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_быть_приватные_конструкторы_для_чего_они_нужны">Могут ли быть приватные конструкторы? Для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, такие конструкторы используются при реализации паттерна «Фабрика» или «Синглтон».</p>
</div>
<div class="paragraph">
<p>Сделав конструктор приватным, можно запретить возможность создания экземпляра (полезно для утилитных классов).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_классы_загрузчики_и_про_динамическую_загрузку_классов">Расскажите про классы-загрузчики и про динамическую загрузку классов</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.</p>
</div>
<div class="paragraph">
<p>В начале работы программы создается 3 основных загрузчика классов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>базовый загрузчик (bootstrap/primordial). Загружает основные системные и внутренние классы JDK (Core API - пакеты java.* (rt.jar и i18n.jar) . Важно заметить, что базовый загрузчик является «Изначальным» или «Корневым» и частью JVM, вследствие чего его нельзя создать внутри кода программы.</p>
</li>
<li>
<p>загрузчик расширений (extention). Загружает различные пакеты расширений, которые располагаются в директории &lt;JAVA_HOME&gt;/lib/ext или другой директории, описанной в системном параметре java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом sun.misc.Launcher$ExtClassLoader.</p>
</li>
<li>
<p>системный загрузчик (system/application). Загружает классы, пути к которым указаны в переменной окружения CLASSPATH или пути, которые указаны в командной строке запуска JVM после ключей -classpath или -cp. Системный загрузчик реализован классом sun.misc.Launcher$AppClassLoader.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Динамическая загрузка классов в Java имеет ряд особенностей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>отложенная (lazy) загрузка и связывание классов. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.</p>
</li>
<li>
<p>проверка корректности загружаемого кода (type safeness). Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.</p>
</li>
<li>
<p>программируемая загрузка. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.</p>
</li>
<li>
<p>множественные пространства имен. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Рассмотрим процесс загрузки более детально. Пусть в систем исполнения встретилась декларация переменной пользовательского класс Student.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Системный загрузчик попытается поискать в кеше класс Student.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Если класс найден, загрузка окончена.</p>
</li>
<li>
<p>Если класс не найден, загрузка делегируется загрузчику расширений.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Загрузчик расширений попытается поискать в кеше класс Student.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Если класс найден, загрузка окончена.</p>
</li>
<li>
<p>Если класс не найден, загрузка делегируется базовому загрузчику.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Базовый загрузчик попытается поискать в кеше класс Student.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Если класс найден, загрузка окончена.</p>
</li>
<li>
<p>Если класс не найден, базовый загрузчик попытается его загрузить.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Если загрузка прошла успешно, она закончена ;)</p>
</li>
<li>
<p>Иначе управление предается загрузчику раширений.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Загрузчик расширений пытается загрузить класс.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Если загрузка прошла успешно, она закончена ;)</p>
</li>
<li>
<p>Иначе управление предается системному загрузчику.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Системный загрузчик пытается загрузить класс.</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p>Если загрузка прошла успешно, она закончена ;)</p>
</li>
<li>
<p>Иначе генерируется исключение java.lang.ClassNotFoundException.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Динамическая загрузка классов производится через метод Class.forName(String className) или с использованием ClassLoader-а. Динамическая загрузка классов имеет смысл, когда требуется загрузить класс во время выполнения программы, когда нужно заменить класс, изменив, например, какую-то логику, не рестартуя приложения.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_конструктор_по_умолчанию_конструктор_копирования_и_конструктор_с_параметрами">Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Конструктор по умолчанию существует у всех объектов(явно или неявно) и не имеет никаких аргументов.</p>
</div>
<div class="paragraph">
<p>Конструктор копирования в качестве аргумента принимает свой же тип данных.</p>
</div>
<div class="paragraph">
<p>Конструктор копирования. В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта. О реализации инициализации полей полностью должен позаботиться разработчик класса.</p>
</div>
<div class="paragraph">
<p>Конструктор с параметрами принимает в качестве аргумента разные параметры и в разном количестве.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_модификаторы_доступа_есть_в_java_какие_применимы_к_классам">Какие модификаторы доступа есть в Java? Какие применимы к классам?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>public</strong>: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов</p>
</li>
<li>
<p><strong>private</strong>: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе</p>
</li>
<li>
<p><strong>protected</strong>: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах</p>
</li>
<li>
<p><strong>default:</strong> отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Для класса: public и модификатор по умолчанию.</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_означает_модификатор_static">Что означает модификатор static?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>static</code> — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на привязку субъекта классу, а не к экземпляру класса.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_статический_метод_быть_переопределён_или_перегружен">Может ли статический метод быть переопределён или перегружен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.</p>
</div>
<div class="paragraph">
<p>Переопределен - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.</p>
</div>
<div class="paragraph">
<p>В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_нестатические_методы_перегрузить_статические">Могут ли нестатические методы перегрузить статические?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static int plus(int a, int b) {
    return a + b;
}

public int plus(int a, int b, int c) {
    return a + b + c;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_сузить_уровень_доступатип_возвращаемого_значения_при_переопределении_метода">Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сузить модификатор доступа нелья, но можно расширить.</p>
</div>
<div class="paragraph">
<p>Сузить тип возвращаемого значения можно, если они совместимы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Object plus(int a, int b, int c) {
    return a + b + c;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Override
public Integer plus(int a, int b, int c) {
    return a + b + c;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_можно_изменить_в_сигнатуре_метода_при_переопределении_можно_ли_менять_модификаторы_throws_и_тп">Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведет к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.</p>
</div>
<div class="paragraph">
<p>Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника)</p>
</li>
<li>
<p>При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить overloading (перегрузка) метода</p>
</li>
<li>
<p>Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_классы_быть_статическими">Могут ли классы быть статическими?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, только вложенный. Вложенный статический класс имеет доступ только к статическим полям внешнего класса.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_означает_модификатор_final_к_чему_он_может_быть_применим">Что означает модификатор final? К чему он может быть применим?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>final</code> на полях - создает константу (переменная может быть проинициализирована только 1 раз)</p>
</li>
<li>
<p><code>final</code> на методах - нельзя переопределить метод</p>
</li>
<li>
<p><code>final</code> на классах - нельзя наследоваться от класса</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_быть_конструкторы_у_абстрактных_классов_для_чего_они_нужны">Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, в абстрактном классе в Java можно объявить и определить конструкторы. Поскольку создавать экземпляры абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов, то есть при создании экземпляра конкретного класса-реализации. Его можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.</p>
</div>
<div class="paragraph">
<p>Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Без него ваш подкласс не скомпилируется, поскольку первый оператор в любом конструкторе представляет собой неявный вызов super() – конструктора суперкласса по умолчанию в языке Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_интерфейсы_какие_модификаторы_по_умолчанию_имеют_поля_и_методы_интерфейсов">Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ключевое слово interface используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как public.</p>
</div>
<div class="paragraph">
<p>Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static методов.</p>
</div>
<div class="paragraph">
<p>Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static и неизменяемыми final.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_интерфейсы_отличаются_от_абстрактных_классов_в_каких_случаях_следует_использовать_абстрактный_класс_а_в_каких_интерфейс">Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса</p>
</li>
<li>
<p>Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом</p>
</li>
<li>
<p>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности</p>
</li>
<li>
<p>Все методы интерфейса неявно объявляются как public abstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static final</p>
</li>
<li>
<p>Интерфейсы позволяют создавать структуры типов без иерархии</p>
</li>
<li>
<p>Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_решается_проблема_ромбовидного_наследования_при_наследовании_интерфейсов_при_наличии_default_методов">Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_особенности_default_методов_в_интерфейсе_и_для_чего_они_нужны">Расскажите особенности default методов в интерфейсе и для чего они нужны?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Метод по умолчанию не может переопределить метод класса java.lang.Object</p>
</li>
<li>
<p>Помогают реализовывать интерфейсы без страха нарушить работу других классов</p>
</li>
<li>
<p>Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах</p>
</li>
<li>
<p>Дают свободу классам выбрать метод, который нужно переопределить</p>
</li>
<li>
<p>Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каков_порядок_вызова_конструкторов_и_блоков_инициализации_с_учётом_иерархии_классов">Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сначала вызываются все статические блоки от первого предка до последнего наследника. Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности (от предка до последнего потомка).</p>
</div>
<div class="paragraph">
<p>Parent static block(s) → Child static  block(s) →</p>
</div>
<div class="paragraph">
<p>Grandchild static block(s) → Parent non-static block(s) → Parent  constructor →</p>
</div>
<div class="paragraph">
<p>→ Child non-static block(s) → Child  constructor →</p>
</div>
<div class="paragraph">
<p>→ Grandchild non-static block(s) →  Grandchild constructor</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужны_и_какие_бывают_блоки_инициализации">Зачем нужны и какие бывают блоки инициализации?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Нестатические блоки инициализации (instance initializers) позволяют проводить инициализацию объектов вне зависимости от того, какой конструктор был вызван или, например, вести журналирование.</p>
</div>
<div class="paragraph">
<p>Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Существуют статические и нестатические блоки инициализации.</p>
</li>
<li>
<p>Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.</p>
</li>
<li>
<p>Несколько блоков инициализации выполняются в порядке следования в коде класса.</p>
</li>
<li>
<p>Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.</p>
</li>
<li>
<p>Блок инициализации возможно создать и в анонимном классе.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_в_java_используются_статические_блоки_инициализации">Для чего в Java используются статические блоки инициализации?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_произойдёт_если_в_блоке_инициализации_возникнет_исключительная_ситуация">Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.</p>
</div>
<div class="paragraph">
<p>В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какое_исключение_выбрасывается_при_возникновении_ошибки_в_блоке_инициализации_класса">Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если возникшее исключение - наследник <code>RuntimeException</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>для статических блоков инициализации будет выброшено <code>java.lang.ExceptionInInitializerError</code>;</p>
</li>
<li>
<p>для нестатических будет проброшено исключение-источник.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если возникшее исключение - наследник <code>Error</code>, то в обоих случаях будет выброшено <code>java.lang.Error</code>. Исключение: <code>java.lang.ThreadDeath</code> - смерть потока. В этом случае никакое исключение выброшено не будет.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_реализованы_методы_hashcode_и_equals_в_классе_object">Каким образом реализованы методы <code>hashCode()</code> и <code>equals()</code> в классе <code>Object</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;public boolean equals(Object obj) {&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
return (this == obj);&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Реализация метода <code>Object.hashCode()</code> описана как <code>native</code>, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;public native int hashCode();&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужен_equals_чем_он_отличается_от_операции">Зачем нужен equals(). Чем он отличается от операции ==?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод equals() - определяет отношение эквивалентности объектов.</p>
</div>
<div class="paragraph">
<p>При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_будет_если_переопределить_equals_не_переопределяя_hashcode_какие_могут_возникнуть_проблемы">Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;i&gt;- equals есть, hashCode &lt;/i&gt;нет</p>
</div>
<div class="paragraph">
<p>C точки зрения метода equals два объекта будут логически равны, в то время как с точки зрения метода hashCode они не будут иметь ничего общего. И, таким образом, помещая некий объект в хэш-таблицу, мы рискуем не получить его обратно по ключу.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;i&gt;hashCode &lt;/i&gt;есть, &lt;i&gt;equals &lt;/i&gt;нет</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Как известно метод equals по умолчанию просто сравнивает указатели на объекты, определяя, ссылаются ли они на один и тот же объект. Предположим, что метод hashCode мы сгенерировали средствами IDE, и он будет возвращать одинаковые хэш-значения для логически одинаковых объектов. Очевидно, что тем самым мы уже определили некоторый механизм сравнения двух объектов.</p>
</div>
<div class="paragraph">
<p>Мы по-прежнему не сможем найти наш объект в хэш-таблице. Хотя будем уже близки к этому, потому что как минимум найдем корзину хэш-таблицы, в которой объект будет лежать.</p>
</div>
<div class="paragraph">
<p>Для успешного поиска объекта в хэш-таблице помимо сравнения хэш-значений ключа используется также определение логического равенства ключа с искомым объектом. Т. е. без переопределения метода equals никак не получится обойтись.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_контракт_между_hashcode_и_equals">Какой контракт между hashCode() и equals()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При переопределении метода <code>equals</code> разработчик должен придерживаться основных правил, определенных в спецификации языка Java.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*Рефлексивность *- для любого заданного значения <code>x</code>, выражение <code>x.equals(x)</code> должно возвращать <code>true</code>.&lt;/li&gt;&lt;em&gt;Заданного&lt;/em&gt; — имеется в виду такого, что <code>x != null</code>&lt;li&gt;*Симметричность *- для любых заданных значений <code>x</code> и <code>y</code>, <code>x.equals(y)</code> должно возвращать <code>true</code> только в том случае, когда <code>y.equals(x)</code> возвращает <code>true</code>.</p>
</li>
<li>
<p>*Транзитивность *- для любых заданных значений <code>x</code>, <code>y</code> и <code>z</code>, если <code>x.equals(y)</code> возвращает <code>true</code> и <code>y.equals(z)</code> возвращает <code>true</code>, <code>x.equals(z)</code> должно вернуть значение <code>true</code>.</p>
</li>
<li>
<p><strong>Согласованность *-</strong> *для любых заданных значений <code>x</code> и <code>y</code> повторный вызов <code>x.equals(y)</code> будет возвращать значение предыдущего вызова этого метода при условии, что поля, используемые для сравнения этих двух объектов, не изменялись между вызовами.</p>
</li>
<li>
<p><strong>Сравнение null *-</strong> *для любого заданного значения <code>x</code> вызов <code>x.equals(null)</code> должен возвращать <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;h3&gt;Контракт hashCode&lt;/h3&gt;Для реализации хэш-функции в спецификации языка определены следующие правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>вызов метода <code>hashCode</code> один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.</p>
</li>
<li>
<p>вызов метода <code>hashCode</code> над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода <code>equals</code> для этих объектов возвращает <code>true</code>).</p>
</li>
<li>
<p>вызов метода <code>hashCode</code> над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужен_метод_hashcode">Для чего нужен метод <code>hashCode()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>hashCode()</code> необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым.</p>
</div>
<div class="paragraph">
<p>Следует понимать, что в Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если хэш коды разные, то и объекты гарантированно разные;</p>
</li>
<li>
<p>если хэш коды равны, то объекты могут не обязательно равны.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_правила_переопределения_метода_hashcode">Правила переопределения метода hashcode()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При реализации hashCode используется несколько простых правил. Прежде всего, при вычислении хеш-кода следует использовать те же поля, которые сравниваются в equals. Это, во-первых, даст равенство хеш-кодов для равных объектов, во-вторых, распределено полученное значение будет точно так же, как и исходные данные. Теоретически, можно сделать так, чтобы хеш-код всегда был равен 0, и это будет абсолютно легальная реализация. Другое дело, что ее ценность будет равна тому же самому нулю.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_есть_ли_какие_либо_рекомендации_о_том_какие_поля_следует_использовать_при_подсчете_hashcode">Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_нельзя_реализовать_hashcode_который_будет_гарантированно_уникальным_для_каждого_объекта">Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Невозможность написания идеального алгоритма. И потому что hashcode() возвращает int, то есть, рано или поздно все инты могут закончиться.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_a_getclass_equalsa_class_отличается_от_a_instanceof_a_class">Чем a.getClass().equals(A.class) отличается от a instanceOf A.class?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>instanceof проверяет, является ли ссылка на объект с левой стороны (LHS) экземпляром типа с правой стороны (RHS) или каким-либо подтипом. Возвращает boolean</p>
</li>
<li>
<p>getClass() == &#8230;&#8203; проверяет, идентичны ли типы. Возвращает класс</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_исключения">Что такое исключения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Исключение в Java — это объект, который описывает исключительное состояние, возникшее в каком-либо участке программного кода. Когда возникает исключительное состояние, создается объект класса <code>Exception</code>. Этот объект пересылается в метод, обрабатывающий данный тип исключительной ситуации. Исключения могут пробрасываться и «вручную» для того, чтобы сообщить о некоторых нештатных ситуациях.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_опишите_иерархию_исключений">Опишите иерархию исключений</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""paste-3f0ef2d169d8fea22b7bc34b09a913907dc696e3.png""&gt;"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_обрабатываемые_и_необрабатываемые_исключения">Расскажите про обрабатываемые и необрабатываемые исключения</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.</p>
</li>
<li>
<p>Unchecked исключения в Java - наследованные от RuntimeException, checked - от Exception (не включая unchecked).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример unchecked исключения - NullPointerException, checked исключения - IOException</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_механизм_обработки_исключений_в_java_try_catch_finally">Расскажите про механизм обработки исключений в java (Try-catch-finally)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;i&gt;try{ &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;} catch(SomeException e) {&lt;/i&gt;   //в скобках указывается класс конкретной ожидаемой ошибки</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;} finally{ &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;}&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_возможно_ли_использование_блока_try_finally_без_catch">Возможно ли использование блока try-finally (без catch)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>try</code> может быть в паре с <code>finally</code>, без <code>catch</code>. Работает это точно так же - после выхода из блока try выполняется блок finally. Это может быть полезно, например, в следующей ситуации. При выходе из метода вам надо произвести какое-либо действие. А return в этом методе стоит в нескольких местах. Писать одинаковый код перед каждым return нецелесообразно. Гораздо проще и эффективнее поместить основной код в try, а код, выполняемый при выходе - в finally.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_один_блок_catch_отлавливать_сразу_несколько_исключений">Может ли один блок catch отлавливать сразу несколько исключений?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Java 7 стала доступна новая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком catch:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;try {
&#8230;&#8203;
} catch( IOException | SQLException ex ) {
&#8230;&#8203;
}&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_всегда_ли_исполняется_блок_finally_существуют_ли_ситуации_когда_блок_finally_не_будет_выполнен">Всегда ли исполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Если вы вызываете System.exit();</p>
</li>
<li>
<p>Если JVM выйдет из строя первым;</p>
</li>
<li>
<p>Если JVM достигает бесконечного цикла (или другого не прерывающегося, не заканчивающегося оператора) в блоке try или catch;</p>
</li>
<li>
<p>Если ОС принудительно завершает процесс JVM; например, kill -9 &lt;pid&gt; на UNIX.</p>
</li>
<li>
<p>Если хост-система умирает; например, сбой питания, аппаратная ошибка и т.д.</p>
</li>
<li>
<p>Если, наконец, блок будет выполняться потоком демона, а все остальные, не являющиеся демонами, выйдут до вызова finally</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_метод_main_выбросить_исключение_во_вне_и_если_да_то_где_будет_происходить_обработка_данного_исключения">Может ли метод <code>main()</code> выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Может и оно будет передано в виртуальную машину Java (JVM).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_каком_порядке_следует_обрабатывать_исключения_в_catch_блоках">В каком порядке следует обрабатывать исключения в catch блоках?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Тут всегда нужно помнить одну особенность. При использовании множественных операторов catch обработчики подклассов исключений должные находиться выше, чем обработчики их суперклассов. Иначе, суперкласс будет перехватывать все исключения, имея большую область перехвата. Иными словами, <code>Exception</code> не должен находиться выше <code>ArithmeticException</code> и <code>ArrayIndexOutOfBoundsException</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_механизм_try_with_resources">Что такое механизм try-with-resources?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Она дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.</p>
</div>
<div class="paragraph">
<p>В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс <code>java.lang.AutoCloseable</code> или <code>java.io.Closable</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_произойдет_если_исключение_будет_выброшено_из_блока_catch_после_чего_другое_исключение_будет_выброшено_из_блока_finally">Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это плохая практика, потому что исключение из finally перекроет исключение из catch и потеряется исходная ошибка.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_дженерики">Что такое дженерики?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Generics — это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. Обобщения добавили в язык безопасность типов. Самый простой пример - List&lt;String&gt; myList = new ArrayList&lt;&gt;();</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужны_дженерики">Для чего нужны дженерики?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Обобщения позволяют нам уйти от жесткого определения используемых типов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_сырые_типы_raw_type">Что такое сырые типы (raw type)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Raw type — это класс-дженерик, из которого удалили его тип.</p>
</div>
<div class="paragraph">
<p>Raw type — это использование универсального класса без указания аргумента(ОВ) типа для его параметризованного типа(ов), например, использование List вместо List&lt;String&gt; . Когда дженерики были введены в Java, несколько классов были обновлены для использования дженериков. Использование этого класса в качестве raw type (без указания аргумента типа) позволило унаследованному коду все еще компилироваться.</p>
</div>
<div class="paragraph">
<p>Raw types используются для обратной совместимости. Их использование в новом коде не рекомендуется, поскольку использование универсального класса с аргументом типа позволяет усилить типизацию, что, в свою очередь, может улучшить понятность кода и привести к более раннему обнаружению потенциальных проблем.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_вайлдкарды">Что такое вайлдкарды?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Wildcard — это дженерик вида &lt;?&gt;, что означает, что тип может быть чем угодно. Используется, например, в коллекциях, где для всех коллекций базовым типом является Сollection&lt;?&gt;.</p>
</div>
<div class="paragraph">
<p>Чтобы наложить ограничение на wildcard необходимо использовать конструкции типа:</p>
</div>
<div class="paragraph">
<p>? extends SomeClass — означает, что может быть использован любой класс-наследник SomeClass</p>
</div>
<div class="paragraph">
<p>? super SomeClass — означает, что может быть использован класс SomeClass, либо класс-родитель (или интерфейс) SomeClass</p>
</div>
<div class="paragraph">
<p>Это называется bounded wildcard.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы определиться с выбором между extends и super был придуман принцип PECS.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_принцип_pecs">Расскажите про принцип PECS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Producer Extends Consumer Super</p>
</div>
<div class="paragraph">
<p>Если метод имеет аргументы с параметризованным типом (например, Collection или Predicate), то в случае, если аргумент - производитель (producer), нужно использовать ? extends T, а если аргумент - потребитель (consumer), нужно использовать ? super T.</p>
</div>
<div class="paragraph">
<p>Если метод читает данные из аргумента, то этот аргумент - производитель, а если метод передает данные в аргумент, то аргумент является потребителем.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)</p>
</div>
<div class="paragraph">
<p>Collections.max(List&lt;Integer&gt;, Comparator&lt;Number&gt;);</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_коллекция">Что такое «коллекция»?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Коллекция - это структура данных, основная цель которого – хранить набор других элементов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_иерархию_коллекций">Расскажите про иерархию коллекций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""paste-e54d1e3eb13428d640c4c32fc404b6fa82ace3a1.png""&gt;"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_map_это_не_collection_в_то_время_как_list_и_set_являются_collection">Почему Map — это не Collection, в то время как List и Set являются Collection?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Map реализовывает принцип «ключ — значение», в то время как List и Set - простые последовательные наборы элементов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_разница_между_классами_java_util_collection_и_java_util_collections">В чем разница между классами java.util.Collection и java.util.Collections?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>java.util.Collections - набор статических методов для работы с коллекциями</p>
</li>
<li>
<p>java.util.Collection - один из основных интерфейсов Java Collections Framework</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_разница_между_итераторами_с_fail_fast_и_fail_safe_поведением_с_примерами">Какая разница между итераторами с fail-fast и fail-safe поведением? (С примерами)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.</p>
</div>
<div class="paragraph">
<p>В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают ConcurrentModificationException, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора.</p>
</div>
<div class="paragraph">
<p>Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>при изменении коллекции счетчик модификаций также изменяется;</p>
</li>
<li>
<p>при создании итератора ему передается текущее значение счетчика;</p>
</li>
<li>
<p>при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.</p>
</div>
<div class="paragraph">
<p>Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_различаются_enumeration_и_iterator">Чем различаются <code>Enumeration</code> и <code>Iterator</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>с помощью Enumeration нельзя добавлять/удалять элементы</p>
</li>
<li>
<p>в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д)</p>
</li>
<li>
<p>Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных классах-коллекциях</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_между_собой_связаны_iterable_iterator_и_for_each">Как между собой связаны <code>Iterable</code>, <code>Iterator</code> и «for-each»?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Классы, реализующие интерфейс Iterable, могут применяться в конструкции for-each, которая использует Iterator.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_итерируясь_по_arraylist_удалить_элемент_какое_вылетит_исключение">Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Итератор ArrayList является fail-fast, то есть не поддерживает итерацию с параллельной модификацией. А параллельная модификация случается даже в одном потоке. Следующий шаг итератора после удаления элемента выбросит ConcurrentModificationException.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_поведёт_себя_коллекция_если_вызвать_iterator_remove">Как поведёт себя коллекция, если вызвать iterator.remove()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Единственный способ удалить элемент из коллекции при обходе, не получив при этом ConcurrentModificationException или неопределенное поведение – удалить с помощью remove() того же инстанса итератора.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_set_отличается_от_list">Чем Set отличается от List?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оба унаследованы от Collection, а значит имеют одинаковый набор и сигнатуры методов. List хранит объекты в порядке вставки, элемент можно получить по индексу. Set не может хранить одинаковых элементов и не имеет порядка.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_интерфейс_set">Расскажите про интерфейс Set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""paste-8b0b5338f64da3caf170f7222a739d6dcbfbb055.png""&gt;</p>
</div>
<div class="paragraph">
<p>Интерфейс Set расширяет интерфейс Collection и представляет набор уникальных элементов. Set не добавляет новых методов, только вносит изменения унаследованные.</p>
</div>
<div class="paragraph">
<p>В коллекции этого типа разрешено наличие только одной ссылки типа null.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_реализации_интерфейса_set">Расскажите про реализации интерфейса <code>Set</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>HashSet</code> — реализация интерфейса Set, базирующаяся на <code>HashMap</code>. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.</p>
</div>
<div class="paragraph">
<p><code>LinkedHashSet</code> — отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.</p>
</div>
<div class="paragraph">
<p><code>TreeSet</code> — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием ""natural ordering"".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_отличия_treeset_и_hashset">В чем отличия <code>TreeSet</code> и <code>HashSet</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>TreeSet</code> обеспечивает упорядоченное хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже O(log(N)) (Логарифмическое время).</p>
</div>
<div class="paragraph">
<p><code>HashSet</code> использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что в HashSet в качестве ключа и значения выступает сам элемент, кроме того, HashSet не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_linkedhashset_отличается_от_hashset">Чем <code>LinkedHashSet</code> отличается от <code>HashSet</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>LinkedHashSet</code> отличается от HashSet только тем, что в его основе лежит <code>LinkedHashMap</code> вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в Linked`HashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_будет_если_добавлять_элементы_в_treeset_по_возрастанию">Что будет, если добавлять элементы в <code>TreeSet</code> по возрастанию?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В основе <code>TreeSet</code> лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, <code>TreeSet</code> все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_hashset_сложность_основных_операций">Как устроен HashSet, сложность основных операций.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""clip_image002.gif""&gt;</p>
</div>
<div class="paragraph">
<p>Класс HashSet реализует интерфейс Set, поддерживаемый хеш-таблицей, которая на самом деле является экземпляром HashMap. Не дается никаких гарантий относительно порядка итераций набора, что означает, что класс не гарантирует постоянный порядок элементов во времени. Этот класс допускает нулевой элемент. Класс также обеспечивает постоянную производительность по времени для основных операций, таких как сложение, удаление, удержание и размер, при условии, что хеш-функция правильно распределяет элементы между сегментами, что мы увидим далее в статье.</p>
</div>
<div class="paragraph">
<p>Несколько важных функций <code>HashSet</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Реализует Set Interface .</p>
</li>
<li>
<p>Базовая структура данных для HashSet является хеш-таблицей.</p>
</li>
<li>
<p>Поскольку он реализует интерфейс Set, повторяющиеся значения не допускаются.</p>
</li>
<li>
<p>Объекты, которые вы вставляете в HashSet, не обязательно будут вставлены в том же порядке. Объекты вставляются на основе их хэш-кода.</p>
</li>
<li>
<p>Элементы NULL разрешены в HashSet.</p>
</li>
<li>
<p><code>HashSet</code> также реализует интерфейсы <code>Serializable</code> и <code>Cloneable</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Теперь для поддержания постоянной производительности по времени итерация по HashSet требует времени, пропорционального сумме размера экземпляра HashSet (количество элементов) плюс «емкость» резервного экземпляра HashMap (количество сегментов). Таким образом, очень важно не устанавливать слишком высокую начальную емкость (или слишком низкий коэффициент загрузки), если важна производительность итерации.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;Начальная емкость:&lt;/i&gt; Начальная емкость означает число сегментов, когда создается хеш-таблица (HashSet внутренне использует структуру данных хеш-таблицы). Количество сегментов будет автоматически увеличено, если текущий размер заполнится.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;Коэффициент загрузки:&lt;/i&gt; Коэффициент загрузки является мерой того, насколько полно HashSet может получить до того, как его емкость будет автоматически увеличена. Когда количество записей в хеш-таблице превышает произведение коэффициента загрузки и текущей емкости, хеш-таблица перефразируется (то есть внутренние структуры данных перестраиваются), так что хеш-таблица имеет приблизительно вдвое больше сегментов.</p>
</div>
<div class="paragraph">
<p>Пример: если внутренняя емкость равна 16, а коэффициент нагрузки равен 0,75, то количество сегментов автоматически увеличивается, если в таблице 12 элементов.</p>
</div>
<div class="paragraph">
<p>Внутренняя работа <code>HashSet</code></p>
</div>
<div class="paragraph">
<p>Все классы интерфейса Set внутренне поддерживаются Map. HashSet использует HashMap для внутреннего хранения своего объекта. Вам должно быть интересно, что для ввода значения в HashMap нам нужна пара ключ-значение, но в HashSet мы передаем только одно значение.</p>
</div>
<div class="paragraph">
<p>Хранение в <code>HashMap</code></p>
</div>
<div class="paragraph">
<p>На самом деле значение, которое мы вставляем в HashSet, действует как ключ к объекту карты, и для его значения java использует постоянную переменную. Таким образом, в паре ключ-значение все ключи будут иметь одинаковое значение.</p>
</div>
<div class="paragraph">
<p>Сложность времени операций HashSet: Базовая структура данных для HashSet является хеш-таблицей. Таким образом, амортизировать (в среднем или обычном случае) сложность времени для операций добавления, удаления и поиска (содержит метод) операции HashSet занимает O (1) времени.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_linkedhashset_сложность_основных_операций">Как устроен LinkedHashSet, сложность основных операций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""clip_image002.gif""&gt;</p>
</div>
<div class="paragraph">
<p>LinkedHashSet — это упорядоченная версия HashSet, которая поддерживает двусвязный список для всех элементов. Когда необходимо поддерживать порядок итераций, используется этот класс.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Содержит уникальные элементы, такие как HashSet . Он расширяет класс HashSet и реализует интерфейс Set.</p>
</li>
<li>
<p>Поддерживает порядок вставки.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_treeset_сложность_основных_операций">Как устроен TreeSet, сложность основных операций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""clip_image002.gif""&gt;</p>
</div>
<div class="paragraph">
<p>TreeSet обеспечивает реализацию интерфейса SortedSet, а SortedSet расширяет интерфейс Set. Он ведет себя как простой набор, за исключением того, что он хранит элементы в отсортированном формате. Следующими являются функции TreeSet.</p>
</div>
<div class="paragraph">
<p>TreeSet использует древовидную структуру данных для хранения.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Объекты хранятся в отсортированном порядке возрастания. Но мы можем выполнять итерацию в порядке убывания, используя метод TreeSet.descendingIterator ()</p>
</li>
<li>
<p>Время доступа и поиска очень быстрое, что делает TreeSet отличным выбором для хранения большого объема данных в отсортированном формате</p>
</li>
<li>
<p>TreeSet не использует методы hashCode () и equals () для сравнения своих элементов. Он использует метод compare () (или compareTo ()) для определения равенства двух элементов</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_интерфейс_list">Расскажите про интерфейс List</h2>
<div class="sectionbody">
<div class="paragraph">
<p>List – это упорядоченный список. Объекты хранятся в порядке их добавления в список. Доступ к элементам списка осуществляется по индексу.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_arraylist_сложность_основных_операций">Как устроен ArrayList, сложность основных операций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""clip_image002-18a075a02332e9dc5c081810380c7dfd9c7829ee.gif""&gt;</p>
</div>
<div class="paragraph">
<p>ВАЖНО! Вставка и удаление не включают в себя поиск элемента, поэтому у них сложность алгоритма O(1).</p>
</div>
<div class="paragraph">
<p>Класс ArrayList реализует интерфейс List и может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_linkedlist_сложность_основных_операций">Как устроен LinkedList, сложность основных операций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""clip_image002-18a075a02332e9dc5c081810380c7dfd9c7829ee.gif""&gt;</p>
</div>
<div class="paragraph">
<p>ВАЖНО! Вставка и удаление не включают в себя поиск элемента, поэтому у них сложность алгоритма O(1).</p>
</div>
<div class="paragraph">
<p>LinkedList — класс, реализующий два интерфейса — List и Deque. Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом (нодом). Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_linkedlist_реализует_и_list_и_deque">Почему <code>LinkedList</code> реализует и <code>List</code>, и <code>Deque</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_arraylist_и_linkedlist">Чем отличаются <code>ArrayList</code> и <code>LinkedList</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>ArrayList</code> это список, реализованный на основе массива, а LinkedList — это классический двусвязный список, основанный на объектах с ссылками между ними.</p>
</div>
<div class="paragraph">
<p><code>ArrayList</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>доступ к произвольному элементу по индексу за константное время O(1);</p>
</li>
<li>
<p>доступ к элементам по значению за линейное время O(N);</p>
</li>
<li>
<p>вставка в конец в среднем производится за константное время O(1);</p>
</li>
<li>
<p>удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);</p>
</li>
<li>
<p>вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;</p>
</li>
<li>
<p>минимум накладных расходов при хранении.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>LinkedList</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>на получение элемента по индексу или значению потребуется линейное время O(N);</p>
</li>
<li>
<p>на добавление и удаление в начало или конец списка потребуется константное O(1);</p>
</li>
<li>
<p>вставка или удаление в/из произвольного место константное O(1);</p>
</li>
<li>
<p>требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В целом, <code>LinkedList</code> в абсолютных величинах проигрывает <code>ArrayList</code> и по потребляемой памяти, и по скорости выполнения операций. <code>LinkedList</code> предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_queue">Что такое Queue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Обобщенный интерфейс <code>Queue</code>&lt;E&gt; расширяет базовый интерфейс Collection и определяет поведение класса в качестве однонаправленной очереди.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_deque_чем_отличается_от_queue">Что такое Deque? Чем отличается от Queue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс Deque расширяет интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (последний вошел - первый вышел).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_коллекция_реализует_fifo">Какая коллекция реализует FIFO?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>FIFO</strong>, <strong>First-In-First-Out</strong> («первым пришел-первым ушел») - по этому принципу построена коллекция <code>Queue</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_коллекция_реализует_lifo">Какая коллекция реализует LIFO?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>FILO</strong>, <strong>First-In-Last-Out</strong> («первым пришел, последним ушел») - по этому принципу построена коллекция <code>Stack</code>, <code>ArrayDeque</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_оцените_количество_памяти_на_хранение_одного_примитива_типа_byte_в_linkedlist">Оцените количество памяти на хранение одного примитива типа byte в LinkedList?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Каждый элемент <code>LinkedList</code> хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;private static class Node&lt;E&gt; {
 E item;
 Node&lt;E&gt; next;
 Node&lt;E&gt; prev;
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.</p>
</div>
<div class="paragraph">
<p>Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40 байт и 24 байта. Итого 64 байта.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_оцените_количество_памяти_на_хранение_одного_примитива_типа_byte_в_arraylist">Оцените количество памяти на хранение одного примитива типа byte в ArrayList?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соответственно.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_реализации_map">Какие существуют реализации <code>Map</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>HashMap</code></p>
</li>
<li>
<p><code>TreeMap</code></p>
</li>
<li>
<p><code>LinkedHashMap</code></p>
</li>
<li>
<p><code>WeakHashMap</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроена_hashmap_сложность_основных_операций_расскажите_про_принцип_корзин">Как устроена <code>HashMap</code>, сложность основных операций? (Расскажите про принцип корзин)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""paste-bdee2b64aaf86ecd6d5a4c4ce85f29a980441403.png""&gt;</p>
</div>
<div class="paragraph">
<p>HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении</p>
</div>
<div class="paragraph">
<p>новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент.</p>
</div>
<div class="paragraph">
<p>Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_linkedhashmap">Что такое <code>LinkedHashMap</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>LinkedHashMap</code> — хранит ключи в порядке их вставки в мапу. Работает немного медленнее чем HashMap.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроена_treemap_сложность_основных_операций">Как устроена <code>TreeMap</code>, сложность основных операций?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""paste-bdee2b64aaf86ecd6d5a4c4ce85f29a980441403.png""&gt;</p>
</div>
<div class="paragraph">
<p><code>TreeMap</code> — хранит ключи в отсортированном порядке. Работает медленнее чем хэшмап.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_iterator_vs_listiterator"><code>Iterator</code> vs <code>ListIterator</code></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>ListIterator</code> расширяет интерфейс <code>Iterator</code></p>
</li>
<li>
<p><code>ListIterator</code> может быть использован только для перебора элементов коллекции <code>List</code>;</p>
</li>
<li>
<p><code>Iterator</code> позволяет перебирать элементы только в одном направлении, при помощи метода <code>next()</code>. Тогда как <code>ListIterator</code> позволяет перебирать список в обоих направлениях, при помощи методов <code>next()</code> и <code>previous()</code>;</p>
</li>
<li>
<p><code>ListIterator</code> не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые возвращают методы <code>previous()</code> и <code>next()</code>.</p>
</li>
<li>
<p>При помощи <code>ListIterator</code> вы можете модифицировать список, добавляя/удаляя элементы с помощью методов <code>add()</code> и <code>remove()</code>. Iterator не поддерживает данного функционала.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_weakhashmap">Что такое WeakHashMap?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>WeakHashMap</code> - это структура данных, реализующая интерфейс <code>Map</code> и основанная на использовании WeakReference для хранения ключей. Таким образом, пара «ключ-значение» будет удалена из <code>WeakHashMap</code>, если на объект-ключ более не имеется сильных ссылок.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работает_hashmap_при_попытке_сохранить_в_него_два_элемента_по_ключам_с_одинаковым_hashcode_но_для_которых_equals_false">Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>По значению hashCode вычисляется индекс ячейки массива, в список которой будет происходить добавление элемента. Перед добавлением осуществляется проверка на наличие уже элементов в этой ячейке. Если элементов нет, то происходит добавление. Если возникает коллизия, то итеративно осуществляется обход списка в поисках элемента с таким же ключом и хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а старое - возвращается. Поскольку в условии сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало списка.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_будет_если_мы_кладем_в_hashmap_ключ_у_которого_equals_и_hashcode_определены_некорректно">Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Объект неправильно рассчитает hash и попадет в случайную корзину.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_возможна_ли_ситуация_когда_hashmap_выродится_в_список_даже_с_ключами_имеющими_разные_hashcode">Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_нельзя_использовать_byte_в_качестве_ключа_в_hashmap">Почему нельзя использовать byte[] в качестве ключа в HashMap?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива). Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_будет_ли_работать_hashmap_если_все_добавляемые_ключи_будут_иметь_одинаковый_hashcode">Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какое_худшее_время_работы_метода_getkey_для_ключа_которого_нет_в_hashmap">Какое худшее время работы метода get(key) для ключа, которого нет в HashMap?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какое_худшее_время_работы_метода_getkey_для_ключа_который_есть_в_hashmap">Какое худшее время работы метода get(key) для ключа, который есть в HashMap?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O(N). Аналогичные рассуждения, что и для предыдущего вопроса.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_функциональный_интерфейс">Что такое функциональный интерфейс?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Функциональный интерфейс в Java – это интерфейс, который содержит только 1 абстрактный метод, однако, методов по умолчанию (default) такой интерфейс может содержать сколько угодно. Основное назначение – использование в лямбда выражениях и method reference.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_functionalinterface">Для чего нужна аннотация @FunctionalInterface?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это позволит использовать интерфейс в лямбда выражениях, не остерегаясь того, что кто-то добавит в интерфейс новый абстрактный метод и он перестанет быть функциональным.&lt;/div&gt; &lt;div style=""text-align: justify; ""&gt;Предназначение аннотации — сообщить компилятору, что данный интерфейс функциональный и должен содержать не более одного абстрактного метода.&lt;/div&gt; &lt;div style=""text-align: justify; ""&gt;Это не обязательное условие, так как JVM считает функциональным любой интерфейс с одним абстрактным методом.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_встроенные_функциональные_интерфейсы_вы_знаете">Какие встроенные функциональные интерфейсы вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Они размещены в пакете java.util.function.</p>
</div>
<div class="paragraph">
<p>Наиболее часто используются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consumer&lt;T&gt; - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает:</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>Function&lt;T,R&gt; - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R:</p>
</li>
</ul>
</div>
<div class="literalblock">
<div class="content">
<pre>Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);
backToString.apply(""123""); // ""123""&lt;/i&gt;&lt;/div&gt;&lt;/i&gt;//</pre>
</div>
</div>
<div class="paragraph">
<p>Predicate&lt;T&gt; - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean.</p>
</div>
<div class="paragraph">
<p>Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (and, or, negate):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>predicate.test(""foo""); // true &lt;/i&gt;&lt;i&gt;- это как return ""foo"".length() &amp;gt; 0&lt;/i&gt;&lt;/div&gt;&lt;/i&gt;&lt;i&gt;&lt;i&gt;    predicate.negate().test(""foo""); // false - это как return *!*""foo"".length() &amp;gt; 0&lt;/i&gt;&lt;/div&gt;&lt;/i&gt;//</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Supplier&lt;T&gt; - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T:</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>UnaryOperator&lt;T&gt; - (унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;i&gt;    UnaryOperator&lt;Integer&gt; operator = x -&gt; x * x;&lt;/i&gt;&lt;/div&gt;&lt;i&gt;&lt;i&gt;    System.out.println(operator.apply(5)); // 25&lt;/i&gt;&lt;/div&gt;&lt;/i&gt;&lt;/div&gt;&lt;div style=""text-align: justify; ""&gt;//&lt;/div&gt;&lt;div style=""text-align: justify; ""&gt;</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;&lt;div style=""text-align: justify; ""&gt;BinaryOperator&lt;T&gt; - BinaryOperator&lt;T&gt; (бинарный оператор) - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T:&lt;/div&gt;&lt;div style=""text-align: justify; ""&gt;//&lt;/div&gt;&lt;i&gt;&lt;i&gt;    BinaryOperator&lt;Integer&gt; operator = (a, b) -&gt; a + b;
    System.out.println(operator.apply(1, 2)); // 3&lt;/i&gt;&lt;/div&gt;&lt;/i&gt;//</p>
</div>
<div class="paragraph">
<p><strong>И ИХ BI ВЕРСИИ (BiFunction и т.д.)</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_ссылка_на_метод">Что такое ссылка на метод?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ссылка на метод – это сокращенный синтаксис выражения лямбда, который выполняет только один метод.</p>
</div>
<div class="paragraph">
<p>Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом method reference (ссылка на метод) для непосредственной передачи этого метода. Такая ссылка передается в виде:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>имя_класса::имя_статического_метода для статического метода</p>
</li>
<li>
<p>объект_класса::имя_метода для метода экземпляра</p>
</li>
<li>
<p>название_класса::new для конструктора</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>private interface Measurable {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>public int length(String string);</pre>
</div>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>public static void main(String[] args) {&lt;/i&gt;&lt;i&gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;/i&gt;&lt;i&gt;Measurable a = String::length;&lt;/i&gt;&lt;i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;/i&gt;&lt;i&gt;System.out.println(a.length(""abc""));</pre>
</div>
</div>
<div class="paragraph">
<p>}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Виды ссылок на методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>на статический метод</p>
</li>
<li>
<p>на метод экземпляра</p>
</li>
<li>
<p>на конструктор</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_лямбда_выражение_чем_его_можно_заменить">Что такое лямбда-выражение? Чем его можно заменить?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Лямбда представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>
</div>
<div class="paragraph">
<p>Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку  <strong>-&gt;</strong>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.</p>
</div>
<div class="paragraph">
<p>Лямбда-выражение или просто лямбда в Java — упрощённая запись анонимного класса, реализующего функциональный интерфейс.</p>
</div>
<div class="paragraph">
<p>Лямбда-выражения, по сути, это анонимный класс или метод. Лямбда-выражение не выполняется само по себе. Вместо этого, оно используется для реализации метода, определенного в функциональном интерфейсе.</p>
</div>
<div class="paragraph">
<p>Как уже было написано, лямбда-выражения могут заменить анонимные классы, которые реализуют функциональные интерфейсы, но в остальных случаях анонимные классы не теряют актуальности.</p>
</div>
<div class="paragraph">
<p>Если одно и то же лямбда-выражение (или анонимный класс) используется в нескольких случаях, то появляется смысл сделать его членом класса или объекта, или и вовсе написать полноценный класс, реализующий необходимый интерфейс.</p>
</div>
<div class="paragraph">
<p>Но в большинстве случаев, там, где можно применять лямбда-выражения, например, в Stream, Optional или CompletableFuture, логичнее применять именно лямбды.</p>
</div>
<div class="paragraph">
<p>Лямбды имеют доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>неизменяемые (effectively final - не обязательно помеченные как final) локальные переменные;</p>
</li>
<li>
<p>поля класса;</p>
</li>
<li>
<p>статические переменные.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/div&gt;   &lt;div style=""text-align: justify; ""&gt;К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_stream_api_для_чего_нужны_стримы">Что такое Stream API? Для чего нужны стримы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Stream API — это новый способ работать со структурами данных в функциональном стиле. Stream (поток) API — это по своей сути поток данных.</p>
</div>
<div class="paragraph">
<p>Java Stream API был создан для того, чтобы помочь пользователям ускорить и упростить обработку данных. Сам по себе API предоставляет инструмент, который позволяет нам дать рецепт того как обрабатывать объекты.</p>
</div>
<div class="paragraph">
<p>Операции над стримами бывают или промежуточными (intermediate) или конечными (terminal). Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.</p>
</div>
<div class="paragraph">
<p>У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта Thread или Runnable, без вызова start()).</p>
</div>
<div class="paragraph">
<p>Операции над стримами могут выполняться как последовательно, так и параллельно.</p>
</div>
<div class="paragraph">
<p>Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:</p>
</div>
<div class="paragraph">
<p>используют специализированные лямбда-выражения, например IntFunction или IntPredicate вместо Function и Predicate;&lt;/div&gt; &lt;div style=""text-align: justify; ""&gt;поддерживают дополнительные конечные операции sum(), average(), mapToObj().</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_stream_называют_ленивым">Почему Stream называют ленивым?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Потому что стрим не начнет работать, пока не выполнится терминальная операция.&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_способы_создания_стрима">Какие существуют способы создания стрима?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""Снимок экрана (606).png""&gt;"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_промежуточные_методы_в_стримах_вы_знаете">Какие промежуточные методы в стримах вы знаете?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>filter(Predicate predicate)</p>
</li>
<li>
<p>map(Function mapper)</p>
</li>
<li>
<p>flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)</p>
</li>
<li>
<p>limit(long maxSize)</p>
</li>
<li>
<p>skip(long n)</p>
</li>
<li>
<p>sorted()</p>
</li>
<li>
<p>sorted(Comparator comparator)</p>
</li>
<li>
<p>distinct()</p>
</li>
<li>
<p>peek(Consumer action)</p>
</li>
<li>
<p>takeWhile(Predicate predicate) - возвращает элементы до тех пор, пока они удовлетворяют условию, то есть функция-предикат возвращает true. Это как limit, только не с числом, а с условием</p>
</li>
<li>
<p>dropWhile(Predicate predicate) - пропускает элементы до тех пор, пока они удовлетворяют условию, затем возвращает оставшуюся часть стрима. Если предикат вернул для первого элемента false, то ни единого элемента не будет пропущено. Оператор подобен skip, только работает по условию</p>
</li>
<li>
<p>boxed() - преобразует примитивный стрим в объектный</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_peek">Расскажите про метод peek()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Возвращает тот же стрим, но применяет функцию к каждому элементу стрима.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .map(String::toUpperCase)&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .peeke) -&gt; System.out.print("","" + e&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .collect(Collectors.toList());&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_map">Расскажите про метод map()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод map() является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.</p>
</div>
<div class="paragraph">
<p>Пример:&lt;/div&gt;&lt;i&gt;
collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .maps) -&gt; s + ""_1"") // к каждой стркое в стриме прибавляется ""_1""  &lt;/i&gt;&lt;i&gt;.collect(Collectors.toList(;&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_flatmap">Расскажите про метод flatMap()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Похоже на map, но может создавать из одного элемента несколько.</p>
</div>
<div class="paragraph">
<p>Пример: &lt;/div&gt;&lt;i&gt;
1) collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .flatMapp) -&gt; Arrays.asList(p.split("","" // из строки ""1,2,3,4,5"" делает массив [""1"",""2"",""3"",""4"",""5""]
 .stream())
 .toArray(String[]::new);
2) Stream&lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;&lt;i&gt;.of(""H e l l o"", ""w o r l d !"")</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;&lt;i&gt; &lt;/i&gt;&lt;i&gt;.flatMapp) -&gt; Arrays.stream(p.split("" "") &lt;/i&gt;&lt;i&gt;// [""H"", ""e"", ""l"", ""l"", ""o"", ""w"", ""o"", ""r"", ""l"", ""d"", ""!""]&lt;/i&gt;&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;&lt;i&gt; &lt;/i&gt;&lt;i&gt;.toArray(String[]::new); &lt;/i&gt;"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_filter">Расскажите про метод filter()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод filter() является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .filter(«a1»::equals) // ссылка на метод equals класс String&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .count();&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_limit">Расскажите про метод limit()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод limit() является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>collection.stream()</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.limit(2)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>.collect(Collectors.toList());</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_skip">Расскажите про метод skip()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Позволяет пропустить N первых элементов.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;collection.stream()
 &lt;/i&gt;&lt;i&gt;.skip(collection.size() - 1)
 &lt;/i&gt;&lt;i&gt;.findFirst()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .orElse(«1»);&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_sorted">Расскажите про метод sorted()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод sorted() является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator.</p>
</div>
<div class="paragraph">
<p>Порядок элементов в исходной коллекции остается нетронутым - sorted() всего лишь создает его отсортированное представление, по которому можно получить новый ArrayList.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;collection.stream()
 &lt;/i&gt;&lt;i&gt;.sorted()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .collect(Collectors.toList());&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_distinct">Расскажите про метод distinct()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Возвращает стрим без дубликатов (для метода equals).</p>
</div>
<div class="paragraph">
<p>Пример:&lt;/div&gt;&lt;i&gt;
collection.stream()
 &lt;/i&gt;&lt;i&gt;.distinct()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 .collect(Collectors.toList());&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_терминальные_методы_в_стримах_вы_знаете">Какие терминальные методы в стримах вы знаете?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>void forEach(Consumer action) - выполняет указанное действие для каждого элемента стрима</p>
</li>
<li>
<p>long count () - возвращает количество элементов стрима</p>
</li>
<li>
<p>R collect(Collector collector) - один из самых мощных операторов Stream API. С его помощью можно собрать все элементы в список, множество или другую коллекцию, сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.</p>
</li>
<li>
<p>R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner) - то же, что и collect (collector), только параметры разбиты для удобства. Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс Collector, достаточно передать три лямбда-выражения.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Supplier должен поставлять новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>List&lt;String&gt; list = Stream.of(""a"", ""b"", ""c"", ""d"")</p>
</div>
<div class="literalblock">
<div class="content">
<pre>.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); // list: [""a"", ""b"", ""c"", ""d""]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Object[] toArray() - возвращает нетипизированный массив с элементами стрима</p>
</li>
<li>
<p>A[] toArray(IntFunction&lt;A[]&gt; generator) - аналогично, только возвращает типизированный массив</p>
</li>
<li>
<p>T reduce(T identity, BinaryOperator accumulator) и U reduce(U identity, BiFunction accumulator, BinaryOperator combiner) - позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов, либо найти минимальный элемент</p>
</li>
<li>
<p>Optional reduce (BinaryOperator accumulator) - этот метод отличается тем, что у него нет начального объекта identity. В качестве него служит первый элемент стрима. Поскольку стрим может быть пустой и тогда identity объект не присвоится, то результатом функции служит Optional, позволяющий обработать и эту ситуацию, вернув Optional.empty()</p>
</li>
<li>
<p>Optional min(Comparator comparator)</p>
</li>
<li>
<p>Optional max(Comparator comparator) - поиск минимального/максимального элемента, основываясь на переданном компараторе. Внутри вызывается reduce</p>
</li>
<li>
<p>Optional findAny() - возвращает первый попавшийся элемент стрима. В параллельных стримах это может быть действительно любой элемент, который лежал в разбитой части последовательности</p>
</li>
<li>
<p>Optional findFirst() - гарантированно возвращает первый элемент стрима, даже если стрим параллельный</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если нужен любой элемент, то для параллельных стримов быстрее будет работать findAny()</p>
</div>
<div class="ulist">
<ul>
<li>
<p>boolean allMatch(Predicate predicate) - возвращает true, если все элементы стрима удовлетворяют условию predicate. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет false, то оператор перестаёт просматривать элементы и возвращает false</p>
</li>
<li>
<p>boolean anyMatch (Predicate predicate) - возвращает true, если хотя бы один элемент стрима удовлетворяет условию predicate</p>
</li>
<li>
<p>boolean noneMatch (Predicate predicate) - возвращает true, если, пройдя все элементы стрима, ни один не удовлетворил условию predicate</p>
</li>
<li>
<p>OptionalDouble average() - только для примитивных стримов. Возвращает среднее арифметическое всех элементов. Либо Optional.empty, если стрим пуст</p>
</li>
<li>
<p>sum() - возвращает сумму элементов примитивного стрима</p>
</li>
<li>
<p>IntSummaryStatistics summaryStatistics() - полезный метод примитивных стримов. Позволяет собрать статистику о числовой последовательности стрима, а именно: количество элементов, их сумму, среднее арифметическое, минимальный и максимальный элемент</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_collect">Расскажите про метод collect()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Представление результата в виде коллекций и других структур данных.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;&lt;i&gt;
collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
  .filters) -&gt; s.contains(«1»&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
  .collect(Collectors.toList());&lt;/i&gt;&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_метод_reduce">Расскажите про метод reduce()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Позволяет выполнять агрегатные функции над всей коллекцией и возвращать один результат.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;&lt;i&gt;
collection.stream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
  .reduce((s1, s2) -&gt; s1 + s2) // в случае array листа Integer {1,2,3,4,5}, это работает так: 1 + 2 + 3 + 4 + 5 = 15&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
  .orElse(0);&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_класс_collectors_и_его_методы">Расскажите про класс Collectors и его методы</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Коллекторы, это специальные классы, использующиеся для преобразования стрима в другую структуру данных.</p>
</div>
<div class="paragraph">
<p>Например, в list:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;List&lt;Integer&gt; list = Stream.of(1,2,3).collect(Collectors.toList());&lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>В Java 8 в классе Collectors реализовано несколько распространённых коллекторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>toList(), toCollection(), toSet() - представляют стрим в виде списка, коллекции или множества</p>
</li>
<li>
<p>toConcurrentMap(), toMap() - позволяют преобразовать стрим в Map</p>
</li>
<li>
<p>averagingInt(), averagingDouble(), averagingLong() - возвращают среднее значение</p>
</li>
<li>
<p>summingInt(), summingDouble(), summingLong() - возвращает сумму</p>
</li>
<li>
<p>summarizingInt(), summarizingDouble(), summarizingLong() - возвращают SummaryStatistics с разными агрегатными значениями</p>
</li>
<li>
<p>partitioningBy() - разделяет коллекцию на две части по соответствию условию и возвращает их как Map&lt;Boolean, List&gt;</p>
</li>
<li>
<p>joining() - склеивает элементы потока в одну строку</p>
</li>
<li>
<p>groupingBy() - разделяет коллекцию на несколько частей и возвращает Map&lt;N, List&lt;T&gt;&gt;</p>
</li>
<li>
<p>mapping() - дополнительные преобразования значений для сложных Collector-ов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Также существует возможность создания собственного коллектора через Collector.of():</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;Collector&lt;String, List&lt;String&gt;, List&lt;String&gt;&gt; toList = Collector.of(&lt;/i&gt;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;ArrayList::new,&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;List::add,&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  &lt;i&gt;(l1, l2) -&amp;gt; { l1.addAll(l2); return l1; }&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
);&lt;/i&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_о_параллельной_обработке_параллельных_стримах_в_java_8">Расскажите о параллельной обработке (параллельных стримах) в Java 8</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий ForkJoinPool доступный через статический ForkJoinPool.commonPool() метод. При этом, если окружение не является многоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.</p>
</div>
<div class="paragraph">
<p>Для создания параллельного потока из коллекции можно также использовать метод parallelStream() интерфейса Collection.</p>
</div>
<div class="paragraph">
<p>Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта Stream метод parallel(). Метод isParallel() позволяет узнать является ли стрим параллельным.</p>
</div>
<div class="paragraph">
<p>С помощью, методов parallel() и sequential() можно определять какие операции могут быть параллельными, а какие только последовательными. Также из любого последовательного стрима можно сделать параллельный и наоборот:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;collection&lt;/i&gt;&lt;i&gt;.stream()&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;.peek(...) // операция последовательна&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;.parallel()&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;.map(...) // операция может выполняться параллельно,&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;.sequential()&lt;/i&gt;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;.reduce(...) // операция снова последовательна&lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод forEach(), который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод forEachOrdered().</p>
</div>
<div class="paragraph">
<p>Критерии, которые могут повлиять на производительность в параллельных стримах:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.</p>
</li>
<li>
<p>Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.</p>
</li>
<li>
<p>Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из ArrayList легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа LinkedList - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.</p>
</li>
<li>
<p>Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Крайне не рекомендуется использовать параллельные стримы для скольких-нибудь долгих операций (например, сетевых соединений), так как все параллельные стримы работают c одним ForkJoinPool, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;</p>
</div>
<div class="paragraph">
<p>Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию unordered():</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;i&gt;collection.parallelStream()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
.sorted()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
.unordered()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
.collect(Collectors.toList());&lt;/i&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_intstream_и_doublestream">Что такое IntStream и DoubleStream?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных int, long и double: IntStream, LongStream и DoubleStream. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>используют специализированные лямбда-выражения, например IntFunction или IntPredicate вместо Function и Predicate</p>
</li>
<li>
<p>поддерживают дополнительные конечные операции sum(), average(), mapToObj()</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_нововведения_появились_в_java_8">Какие нововведения появились в Java 8?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Методы интерфейсов по умолчанию (default методы)</p>
</li>
<li>
<p>Лямбда-выражения</p>
</li>
<li>
<p>Функциональные интерфейсы</p>
</li>
<li>
<p>Ссылки на методы и конструкторы</p>
</li>
<li>
<p>Предикаты (predicate), Функции (function), Поставщики (suppliers), Потребители (consumers)</p>
</li>
<li>
<p>Опциональные значения (класс Optional)</p>
</li>
<li>
<p>Стримы</p>
</li>
<li>
<p>LocalTime, LocalDate, LocalDateTime</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_новые_классы_для_работы_с_датами_появились_в_java_8">Какие новые классы для работы с датами появились в Java 8?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>LocalDate – неизменяемый класс, который представляет объекты Date в формате по умолчанию yyyy-MM-dd.</p>
</li>
<li>
<p>LocalDateTime – представляет собой дату и время в формате по умолчанию: yyyy-MM-dd-HH-mm-ss.zzz.</p>
</li>
<li>
<p>java.time.Instant – используется для работы с машиночитаемым форматом времени — он сохраняет дату и время в так называемый «unix timestamp (отметку времени)»</p>
</li>
<li>
<p>ZonedDateTime - что-то связанное с часовым поясом, позже поискать поподробнее</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_класс_optional">Расскажите про класс Optional</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Опциональное значение Optional — это контейнер для объекта, который может содержать или не содержать значение null. Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/notNull проверок:</p>
</div>
<div class="paragraph">
<p>Методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Optional.orElse - возвращает переданное значение, если Optional пустой</p>
</li>
<li>
<p>Optional.orElseGet - возвращает переданное значение из лямда-выражение , если Optional пустой</p>
</li>
<li>
<p>Optional.orElseThrow - бросает переданное исключение , если Optional пустой</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_nashorn">Что такое Nashorn?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nashorn - это движок JavaScript, разрабатываемый на Java компанией Oracle. Призван дать возможность встраивать код JavaScript в приложения Java. В сравнении с Rhino, который поддерживается Mozilla Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую производительность, так как он компилирует код и передает байт-код виртуальной машине Java непосредственно в памяти. Nashorn умеет компилировать код JavaScript и генерировать классы Java, которые загружаются специальным загрузчиком. Так же возможен вызов кода Java прямо из JavaScript.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jjs">Что такое jjs?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для движка Nashorn JAVA 8 представляет новый инструмент командной строки, jjs, для выполнения JavaScript-кодов на консоли.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_класс_появился_в_java_8_для_кодированиядекодирования_данных">Какой класс появился в Java 8 для кодирования/декодирования данных?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Base64 - потокобезопасный класс, который реализует кодировщик и декодировщик данных, используя схему кодирования base64 согласно RFC 4648 и RFC 2045.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_создать_base64_кодировщик_и_декодировщик">Как создать Base64 кодировщик и декодировщик?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Base64 содержит 6 основных методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getEncoder()/getDecoder() - возвращает кодировщик/декодировщик base64, соответствующий стандарту RFC 4648;</p>
</li>
<li>
<p>getUrlEncoder()/getUrlDecoder() - возвращает URL-safe кодировщик/декодировщик base64, соответствующий стандарту RFC 4648;</p>
</li>
<li>
<p>getMimeEncoder()/getMimeDecoder() - возвращает MIME кодировщик/декодировщик, соответствующий стандарту RFC 2045.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_дополнительные_методы_для_работы_с_ассоциативными_массивами_maps_появились_в_java_8">Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>putIfAbsent() добавляет пару «ключ-значение», только если ключ отсутствовал.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;  map.putIfAbsent(""a"", ""Aa"");&lt;/i&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>forEach() принимает функцию, которая производит операцию над каждым элементом.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.forEach((k, v) -&amp;gt; System.out.println(v));</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>compute() создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.compute(""a"", (k, v) -&amp;gt; String.valueOf(k).concat(v)); //[""a"", ""aAa""]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>computeIfPresent() если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.computeIfPresent(""a"", (k, v) -&amp;gt; k.concat(v));</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>computeIfAbsent() если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.computeIfAbsent(""a"", k -&amp;gt; ""A"".concat(k)); //[""a"",""Aa""]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>getOrDefault() в случае отсутствия ключа, возвращает переданное значение по-умолчанию.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.getOrDefault(""a"", ""not found"");</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>merge() принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключем значение отсутствует, то записывает туда передаваемое значение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>map.merge(""a"", ""z"", (value, newValue) -&amp;gt; value.concat(newValue)); //[""a"",""Aaz""]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_localdatetime">Что такое LocalDateTime?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>java.time.LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_zoneddatetime">Что такое ZonedDateTime?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает временную зону, поэтому все операции с временными сдвигами этот класс проводит с её учётом.</p>
</div>
<div class="paragraph">
<p>Не путать ZoneId и ZonedDateTime!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_процесс_отличается_от_потока">Чем процесс отличается от потока?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Процесс (process) - это объект, который создается операционной системой, когда пользователь запускает приложение. Процессу выделяется отдельное адресное пространство, причем это пространство физически недоступно для других процессов. Процесс может работать с файлами или с каналами связи локальной или глобальной сети. Когда вы запускаете текстовый процессор или программу калькулятора, вы создаете новый процесс.</p>
</div>
<div class="paragraph">
<p>Поток. Для каждого процесса операционная система создает один главный поток (thread*-), который является потоком выполняющихся по очереди команд центрального процессора. При необходимости главный поток может создавать другие потоки, пользуясь для этого программным интерфейсом операционной системы.</p>
</div>
<div class="paragraph">
<p>Все потоки, созданные процессом, выполняются в адресном пространстве этого процесса и имеют доступ к ресурсам процесса. Однако поток одного процесса не имеет никакого доступа к ресурсам потока другого процесса, так как они работают в разных адресных пространствах. При необходимости организации взаимодействия между процессами или потоками, принадлежащими разным процессам, следует пользоваться системными средствами, специально предназначенными для этого.</p>
</div>
<div class="paragraph">
<p>Вариант 2:</p>
</div>
<div class="paragraph">
<p>Процесс это некоторая единица операционной системы, которой выделена память и другие ресурсы. Поток это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процесса - общая для всех его потоков. Потоки исполняются на ядрах процессора.&lt;/div&gt; &lt;div style=""text-align: justify; ""&gt;В некоторых OS разница между процессами и потоками сведена к минимуму.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_thread_отличается_от_runnable">Чем Thread отличается от Runnable?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда нужно использовать Thread, а когда Runnable? (Ответ что тред - это класс, а ранбл интерфейс – считается не полным, нужно рассказать подробно)</p>
</div>
<div class="paragraph">
<p>Thread - это класс, некоторая надстройка над физическим потоком.</p>
</div>
<div class="paragraph">
<p>Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.</p>
</div>
<div class="paragraph">
<p>Есть два способа создать новый поток выполнения. Один из них - объявить класс подклассом Thread. Этот подкласс должен переопределить метод запуска класса Thread. Затем можно выделить и запустить экземпляр подкласса.</p>
</div>
<div class="paragraph">
<p>Другой способ создать поток - объявить класс, реализующий интерфейс Runnable. Затем этот класс реализует метод запуска. Затем можно выделить экземпляр класса, передать его в качестве аргумента при создании потока и запустить.</p>
</div>
<div class="paragraph">
<p>Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_монитор_как_монитор_реализован_в_java">Что такое монитор? Как монитор реализован в java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Монитор</strong> – это специальный механизм (кусок кода) – надстройка над мютексом, который обеспечивает правильную работу с ним. Ведь мало пометить, что объект – занят, надо еще обеспечить, чтобы другие нити не пробовали воспользоваться занятым объектом.  В Java монитор реализован с помощью ключевого слова <code>synchronized</code>.  Когда мы пишем блок synchronized, то компилятор Java заменяет его тремя кусками кода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>В начале блока <code>synchronized</code> добавляется код, который отмечает мютекс как занятый.</p>
</li>
<li>
<p>В конце блока <code>synchronized</code> добавляется код, который отмечает мютекс как свободный.</p>
</li>
<li>
<p>Перед блоком <code>synchronized</code> добавляется код, который смотрит, если мютекс занят – то нить должна ждать его освобождения.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_синхронизация_какие_способы_синхронизации_существуют_в_java">Что такое синхронизация? Какие способы синхронизации существуют в java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Синхронизация - это процесс, который позволяет выполнять потоки параллельно.</p>
</div>
<div class="paragraph">
<p>В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.</p>
</div>
<div class="paragraph">
<p>Ниже приведены некоторые способы синхронизации в Java:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Системная синхронизация с использованием wait()/notify().</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток ""просыпается"" и продолжает свое выполнение.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Системная синхронизация с использованием join().</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, семафор (Semaphore), etc. Концепция данного подхода заключается в использовании атомарных операций и переменных.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работают_методы_wait_notify_и_notifyall">Как работают методы wait(), notify() и notifyAll()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Эти методы определены у класса Object и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.</p>
</div>
<div class="paragraph">
<p>wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();</p>
</div>
<div class="paragraph">
<p>notify(): продолжает работу потока, у которого ранее был вызван метод wait();</p>
</div>
<div class="paragraph">
<p>notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait().</p>
</div>
<div class="paragraph">
<p>Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.</p>
</div>
<div class="paragraph">
<p>Поток может вызвать методы wait() или notify() для определенного объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_каких_состояниях_может_находиться_поток">В каких состояниях может находиться поток?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Потоки могут находиться в одном из следующих состояний:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start(). В этом состоянии поток не считается живым.</p>
</li>
<li>
<p>Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start(). Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.</p>
</li>
<li>
<p>Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.</p>
</li>
<li>
<p>Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:</p>
<div class="ulist">
<ul>
<li>
<p>Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.</p>
</li>
<li>
<p>Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.</p>
</li>
<li>
<p>Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние</p>
</li>
<li>
<p>Работоспособный, когда ресурс становится доступен.</p>
</li>
<li>
<p>Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_семафор_как_он_реализован_в_java">Что такое семафор? Как он реализован в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_обозначает_ключевое_слово_volatile_почему_операции_над_volatile_переменными_не_атомарны">Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>volatile - этот модификатор вынуждает потоки отключить оптимизацию доступа (кеширование переменных) и использовать единственный экземпляр переменной из общей памяти. Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!</p>
</div>
<div class="paragraph">
<p>Если переменная объявлена как volatile, это означает, что ожидается ее изменение несколькими потоками. Естественно, вы думаете, что JRE наложит какие-то формы синхронизации для volatile переменных. Хорошо это или плохо, JRE неявно обеспечивает синхронизацию при доступе к volatile переменным, но с одной очень большой оговоркой: чтение volatile переменных синхронизировано и запись в volatile переменные синхронизирована, а неатомарные операции – нет.</p>
</div>
<div class="paragraph">
<p>Что означает, что следующий код не безопасен для потоков: &lt;i&gt;myVolatileVar++;&lt;/i&gt;&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужны_atomic_типы_данных_чем_отличаются_от_volatile">Для чего нужны Atomic типы данных? Чем отличаются от volatile?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Пакет java.util.concurrent.atomic содержит девять классов для выполнения атомарных операций. Операция называется атомарной, если ее можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.</p>
</div>
<div class="paragraph">
<p>Если переменная объявлена как volatile, это означает, что ожидается ее изменение несколькими потоками. Естественно, вы думаете, что JRE наложит какие-то формы синхронизации для volatile переменных. Хорошо это или плохо, JRE неявно обеспечивает синхронизацию при доступе к volatile переменным, но с одной очень большой оговоркой: чтение volatile переменных синхронизировано и запись в volatile переменные синхронизирована, а неатомарные операции – нет.</p>
</div>
<div class="paragraph">
<p>Что означает, что следующий код не безопасен для потоков: &lt;i&gt;myVolatileVar++;&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_потоки_демоны_для_чего_они_нужны_как_создать_поток_демон">Что такое потоки демоны? Для чего они нужны? Как создать поток-демон?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_приоритет_потока_на_что_он_влияет_какой_приоритет_у_потоков_по_умолчанию">Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению к другим потокам. Приоритеты потоков исполнения задаются целыми числами (обычно от 1 до 10), определяющими относительный приоритет одного потока над другими.</p>
</div>
<div class="paragraph">
<p>Приоритет потока исполнения используется для принятия решения при переходе от одного потока исполнения к другому. Это так называемое переключение контекста. Задается с помощью метода public final void setPriority(int newPriority).</p>
</div>
<div class="paragraph">
<p>По умолчанию приоритет потока 5.</p>
</div>
<div class="paragraph">
<p>Существуют следующие константы для определения приоритета потока:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Thread.MIN_PRIORITY (1)</p>
</li>
<li>
<p>Thread.NORM_PRIORITY (5)</p>
</li>
<li>
<p>Thread.MAX_PRIORITY (10)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>НЕ полагайтесь на приоритет потоков при проектировании многопоточных приложений! Скорее всего планировщик потоков будет использовать приоритеты при выборе следующего потока на выполнение, но это НЕ гарантируется.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работает_thread_join_для_чего_он_нужен">Как работает Thread.join()? Для чего он нужен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток, к которому он присоединяется, не будет завершён:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>void join()</p>
</li>
<li>
<p>void join(long millis)</p>
</li>
<li>
<p>void join(long millis, int nanos)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_методы_yield_и_sleep">Чем отличаются методы yield () и sleep()?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод yield() служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.</p>
</div>
<div class="paragraph">
<p>Метод sleep() вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_правильно_остановить_поток_для_чего_нужны_методы_stop_interrupt_interrupted_isinterrupted">Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted().</h2>
<div class="sectionbody">
<div class="paragraph">
<p>На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например stop(), suspend() и resume() - в следующих версиях JDK все они были помечены как deprecated из-за потенциальных угроз взаимной блокировки).</p>
</div>
<div class="paragraph">
<p>Для корректной остановки потока можно использовать метод класса Thread - interrupt(). Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted() или Thread.interrupted() (для текущего потока). Метод interrupt() также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы sleep() или wait() – текущее состояние прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется.</p>
</div>
<div class="paragraph">
<p>Схема действия при этом получается следующей:q</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Реализовать поток.</p>
</li>
<li>
<p>В потоке периодически проводить проверку статуса прерывания через вызов isInterrupted().</p>
</li>
<li>
<p>Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.</p>
</li>
<li>
<p>Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/div&gt;    Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов interrupt() из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода read(). Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.</p>
</div>
<div class="paragraph">
<p>Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог interrupt(). Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как volatile).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_методы_interrupt_interrupted_isinterrupted">Чем отличаются методы interrupt, interrupted, isInterrupted?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Метод interrupt() – устанавливает флаг прерывания потока.</p>
</li>
<li>
<p>Метод bool isInterrupted() – возвращает состояние флага прерывания и оставляет этот флаг нетронутым.</p>
</li>
<li>
<p>Статический метод bool Thread.interrupted() – возвращает состояние флага и сбрасывает его.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_runnable_отличается_от_callable">Чем Runnable отличается от Callable?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;</p>
</div>
<div class="paragraph">
<p>Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();</p>
</div>
<div class="paragraph">
<p>Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future, который может содержать результат вычислений;&lt;/div&gt; &lt;div style=""text-align: justify; ""&gt;Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_futuretask">Что такое FutureTask?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FutureTask представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_deadlock">Что такое deadlock?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Взаимная блокировка (deadlock) - явление, при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>взаимного исключения - по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.</p>
</li>
<li>
<p>удержания и ожидания - поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые удерживаются другими потоками.</p>
</li>
<li>
<p>отсутствия предочистки - операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.</p>
</li>
<li>
<p>цикличного ожидания - поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_livelock">Что такое livelock?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>livelock – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.</p>
</div>
<div class="paragraph">
<p>Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_race_condition">Что такое race condition?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает, когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.</p>
</div>
<div class="paragraph">
<p>Распространённые способы решения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), использование volatile.</p>
</li>
<li>
<p>Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).</p>
</li>
<li>
<p>Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.</p>
</li>
<li>
<p>Очевидных способов выявления и исправления состояний гонки не существует. Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_фреймворк_forkjoin_для_чего_он_нужен">Что такое Фреймворк fork/join? Для чего он нужен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.</p>
</li>
<li>
<p>Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.</p>
</div>
<div class="paragraph">
<p>Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.</p>
</div>
<div class="paragraph">
<p>Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_означает_ключевое_слово_synchronized_где_и_для_чего_может_использоваться">Что означает ключевое слово synchronized? Где и для чего может использоваться?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synchronized (с англ. ""синхронизированный"") - это ключевое слово, которое позволяет заблокировать доступ к методу или части кода, если его уже использует другой поток.</p>
</div>
<div class="paragraph">
<p>Синхронизировать прикладной код можно двумя способами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>С помощью синхронизированных методов. Метод объявляется с использованием ключевого слова synchronized:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;i&gt;public synchronized void someMethod(){}&lt;/i&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Заключить вызовы методов в блок оператора synchronized:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;i&gt;synchronized(объект) {} &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Только методы и блоки могут быть синхронизированы, но не переменные и классы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_является_монитором_у_статического_синхронизированного_класса">Что является монитором у статического синхронизированного класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для статического метода – объекта типа Class, соответствующий классу, в котором определен этот метод.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_является_монитором_у_нестатического_синхронизированного_класса">Что является монитором у нестатического синхронизированного класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для нестатического метода – текущий объект this.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_stream_api_forkjoinpool_как_связаны_что_это_такое">Stream API &amp; ForkJoinPool Как связаны, что это такое.</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://habr.com/ru/company/otus/blog/338770/" class="bare">https://habr.com/ru/company/otus/blog/338770/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_ddl_какие_операции_в_него_входят_рассказать_про_них">Что такое DDL? Какие операции в него входят? Рассказать про них.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data Definition Language (DDL) – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами (таблицами) этой базы, т.е. создаем, изменяем и удаляем их.</p>
</div>
<div class="paragraph">
<p>В эту группу входят следующие операторы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*CREATE *– используется для создания объектов базы данных</p>
</li>
<li>
<p>*ALTER *– используется для изменения объектов базы данных</p>
</li>
<li>
<p>*DROP *– используется для удаления объектов базы данных</p>
</li>
<li>
<p><strong>TRUNCATE *- операция мгновенного удаления всех строк в таблице. Логически схожа с операцией delete без оператора *WHERE</strong>, но в ситуациях на практике имеет отличия</p>
</li>
<li>
<p><strong>COMMENT</strong></p>
</li>
<li>
<p><strong>RENAME</strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_dml_какие_операции_в_него_входят_рассказать_про_них">Что такое DML? Какие операции в него входят? Рассказать про них</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data Manipulation Language (DML) – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими.</p>
</div>
<div class="paragraph">
<p>В эту группу входят самые распространенные операторы языка SQL:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*SELECT *– осуществляет выборку данных</p>
</li>
<li>
<p><strong>INSERT</strong> – добавляет новые данные</p>
</li>
<li>
<p>*UPDATE *– изменяет существующие данные</p>
</li>
<li>
<p>*DELETE *– удаляет данные</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Так же DML команды, но таких глубоких знаний от Java разраба требовать не будут (по идее), добавил их для общего понятия.&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*MERGE *– оператор языка SQL, который позволяет слить данные одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется Update, а если нет - Insert. Причём нельзя изменять поля таблицы в секции Update, по которым идет связывание двух таблиц</p>
</li>
<li>
<p><strong>CALL</strong> – вызывает процедуру. Если у процедуры есть выходные параметры, возвращается строка результата, содержащая значения этих параметров</p>
</li>
<li>
<p><strong>EXPLAIN PLAN</strong></p>
</li>
<li>
<p>*LOCK TABLE *</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_tcl_какие_операции_в_него_входят_рассказать_про_них">Что такое TCL? Какие операции в него входят? Рассказать про них</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transaction Control Language (TCL) – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены.</p>
</div>
<div class="paragraph">
<p>Группа операторов TCL предназначена как раз для реализации и управления транзакциями. Сюда можно отнести:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BEGIN – служит для определения начала транзакции</p>
</li>
<li>
<p>COMMIT – применяет транзакцию</p>
</li>
<li>
<p>ROLLBACK – откатывает все изменения, сделанные в контексте текущей транзакции</p>
</li>
<li>
<p>SAVEPOINT – устанавливает промежуточную точку сохранения внутри транзакции</p>
</li>
<li>
<p>SET TRANSACTION – начинает транзакцию и устанавливает ее базовые характеристики</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_dcl_какие_операции_в_него_входят_рассказать_про_них">Что такое DCL? Какие операции в него входят? Рассказать про них</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Data Control Language (DCL) – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных.</p>
</div>
<div class="paragraph">
<p>Сюда входят:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом</p>
</li>
<li>
<p>REVOKE – отзывает выданные разрешения</p>
</li>
<li>
<p>DENY– задаёт запрет, имеющий приоритет над разрешением</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_нюансы_работы_с_null_в_sql_как_проверить_поле_на_null">Нюансы работы с NULL в SQL. Как проверить поле на NULL?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NULL - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».</p>
</div>
<div class="paragraph">
<p>NULL означает отсутствие, неизвестность информации. Значение не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении с любым значением будет получен результат NULL, а не false и не 0 Более того, не равно NULL!</p>
</div>
<div class="paragraph">
<p>Команды для проверки поля на null: IS NULL, IS NOT</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_виды_joinов">Виды Join’ов?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>(INNER) JOIN Результатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным</p>
</li>
<li>
<p>LEFT (OUTER) JOIN Производит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (NULL). Порядок таблиц для оператора важен, поскольку оператор не является симметричным</p>
</li>
<li>
<p>RIGHT (OUTER) JOIN LEFT JOIN с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным</p>
</li>
<li>
<p>FULL (OUTER) JOIN Результатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным</p>
</li>
<li>
<p>CROSS JOIN (декартово произведение) При выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_лучше_использовать_join_или_вложенные_запросы_почему">Что лучше использовать join или вложенные запросы? Почему?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Также JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.</p>
</div>
<div class="paragraph">
<p>Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_делает_union">Что делает UNION?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что UNION сам по себе не гарантирует порядок записей.</p>
</div>
<div class="paragraph">
<p>Записи из второго запроса могут оказаться в начале, в конце или вообще перемещаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_where_отличается_от_having_ответа_про_то_что_используются_в_разных_частях_запроса_недостаточно">Чем WHERE отличается от HAVING? (ответа про то, что используются в разных частях запроса - недостаточно)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оператор SQL HAVING аналогичен оператору SQL WHERE за тем исключением, что применяется не для всего набора столбцов таблицы, а для набора созданного оператором SQL GROUP BY и применяется всегда строго после него.</p>
</div>
<div class="paragraph">
<p>Основное отличие WHERE от HAVING заключается в том, что WHERE сначала выбирает строки, а затем группирует их и вычисляет агрегатные функции (таким образом, она отбирает строки для вычисления агрегатов), тогда как HAVING отбирает строки групп после группировки и вычисления агрегатных функций. Как следствие, предложение WHERE не должно содержать агрегатных функций; не имеет смысла использовать агрегатные функции для определения строк для вычисления агрегатных функций. Предложение HAVING, напротив, всегда содержит агрегатные функции. (Строго говоря, вы можете написать предложение HAVING, не используя агрегаты, но это редко бывает полезно. То же самое условие может работать более эффективно на стадии WHERE.)</p>
</div>
<div class="paragraph">
<p>WHERE - это ограничивающее выражение. Оно выполняется до того, как будет получен результат операции.</p>
</div>
<div class="paragraph">
<p>HAVING - фильтрующее выражение. Оно применяется к результату операции и выполняется уже после того как этот результат будет получен, в отличии от where.</p>
</div>
<div class="paragraph">
<p>Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с SELECT и предложением GROUP BY.</p>
</div>
<div class="paragraph">
<p>Например, WHERE нельзя использовать таким образом:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;SELECT name, SUM(salary) FROM Employees WHERE SUM(salary) &gt; 1000 GROUP BY name &lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>В данном случае больше подходит HAVING:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;SELECT name, SUM(salary) FROM Employees GROUP BY name HAVING SUM(salary) &gt; 1000 &lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>То есть, использовать WHERE в запросах с агрегатными функциями нельзя, для этого и был введен HAVING.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_order_by">Что такое ORDER BY?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ORDER BY упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание ASC или убывание DESC для каждого столбца. По умолчанию установлено - возрастание.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_group_by">Что такое GROUP BY?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оператор SQL GROUP BY служит для распределения строк - результата запроса - по группам, в которых значения некоторого столбца, по которому происходит группировка, являются одинаковыми. Группировку можно производить как по одному столбцу, так и по нескольким.</p>
</div>
<div class="paragraph">
<p>Часто оператор SQL GROUP BY применяется вместе с агрегатными функциями (COUNT, SUM, AVG, MAX, MIN). В этих случаях агрегатные функции служат для вычисления соответствующего агрегатного значения ко всему набору строк, для которых некоторый столбец - общий.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_distinct">Что такое DISTINCT?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оператор DISTINCT используется для указания на то, что следует работать только с уникальными значениями столбца.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_limit">Что такое LIMIT?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LIMIT служит для извлечения диапазона строк из таблицы базы данных. В зависимости от того, как эта конструкция прописана в запросе, можно извлечь либо определённое число начальных строк, либо определённое число строк, следующих за пропущенными начальными строками.</p>
</div>
<div class="literalblock">
<div class="content">
<pre> &lt;/div&gt;&lt;i&gt;
LIMIT 2 - // вывести первые 2 строки&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
LIMIT 3, 2  - // пропустить первые 3 строки и вывести следующие за ними 2 строки&lt;/i&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Конструкция LIMIT располагается в конце запроса.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_exists">Что такое EXISTS?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Предикат EXISTS выполняет логическую задачу. В запросах SQL этот предикат используется в выражениях вида: EXISTS (SELECT * FROM ИМЯ_ТАБЛИЦЫ&#8230;&#8203;)</p>
</div>
<div class="paragraph">
<p>Это выражение возвращает истину, когда по запросу найдена одна или более строк, соответствующих условию, и ложь, когда не найдено ни одной строки.</p>
</div>
<div class="paragraph">
<p>Обычно предикат EXISTS применяется в случаях, когда необходимо найти значения, соответствующие основному условию, заданному в секции WHERE, и дополнительному условию, заключенному в подзапрос, являющийся аргументом предиката.</p>
</div>
<div class="paragraph">
<p>Для NOT EXISTS всё наоборот.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_операторы_in_between_like">Расскажите про операторы IN, BETWEEN, LIKE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Предикат IN в запросах на выборку данных применяется для извлечения из таблицы только тех строк, значения определенных столбцов в которых соответствуют набору значений, указываемых в скобках после IN.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Запрос с конструкцией NOT IN извлечет строки, значения определенных столбцов в которых не соответствуют набору указанных значений.</p>
</div>
<div class="paragraph">
<p>С помощью предиката BETWEEN можно извлечь из таблицы строки, в которых значения некоторого проверяемого столбца находятся в интервале, границы которого обозначены некоторым выражением. Границы интервала также включены в него.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;&lt;/i&gt;&lt;/div&gt;&lt;i&gt; &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Если перед предикатом BETWEEN поставить ключевое слово NOT, то в выборку попадут строки, в которых значение проверяемого столбца находится за пределами интервала: до 20 и после 25.</p>
</div>
<div class="paragraph">
<p>Предикат LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildcards) - специальные символы, которые могут соответствовать чему-нибудь:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>""_"" замещает любой одиночный символ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например: 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет соответствовать 'brat'.
* ""%"" замещает последовательность любого числа символов. Например '%p%t' будет соответствовать словам 'put', 'posit', или 'opt', но не 'spite'.</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_делает_оператор_merge_какие_у_него_есть_ограничения">Что делает оператор MERGE? Какие у него есть ограничения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MERGE позволяет осуществить слияние данных одной таблицы с данными другойsql таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT.</p>
</div>
<div class="paragraph">
<p>При этом изменять поля таблицы в секции UPDATE, покоторым идет связывание двух таблиц, нельзя.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_агрегатные_функции_вы_знаете">Какие агрегатные функции вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Агрегатные функции производят одиночное значение для всей группы таблицы.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>COUNT - производит номера строк или не-NULL значения полей которые выбрал запрос.</p>
</li>
<li>
<p>SUM - производит арифметическую сумму всех выбранных значений данного пол.</p>
</li>
<li>
<p>AVG - производит усреднение всех выбранных значений данного пол.</p>
</li>
<li>
<p>MAX - производит наибольшее из всех выбранных значений данного пол.</p>
</li>
<li>
<p>MIN - производит наименьшее из всех выбранных значений данного пол.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_ограничения_constraints_какие_вы_знаете">Что такое ограничения (constraints)? Какие вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ограничения SQL — это правила, применяемые к столбцам данных таблицы. Они используются, чтобы ограничить типы данных, которые могут храниться в таблице. Это обеспечивает точность и надежность данных в базе данных.</p>
</div>
<div class="paragraph">
<p>Ограничения могут применяться либо на уровне столбцов, либо на уровне таблицы. Ограничения на уровне столбца применяются только к одному столбцу, тогда как ограничения уровне таблицы применяются ко всей таблице.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NOT NULL — столбец не может иметь значение NULL</p>
</li>
<li>
<p>DEFAULT — задает значение по умолчанию для столбца, если оно не указано</p>
</li>
<li>
<p>UNIQUE — все значения в столбце должны быть разными</p>
</li>
<li>
<p>PRIMARY Key — уникальная идентификация каждой строки/записи в таблице базы данных</p>
</li>
<li>
<p>FOREIGN Key — уникально идентифицирует строку/запись в любой другой таблице базы данных</p>
</li>
<li>
<p>CHECK — ограничение CHECK обеспечивает, чтобы все значения в столбце удовлетворяли определенным условиям</p>
</li>
<li>
<p>INDEX — используется для быстрого создания данных базы данных</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_суррогатные_ключи">Что такое суррогатные ключи?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Суррогатный Ключ (СК) – автоматически сгенерированное поле, никак не связанное с информационным содержанием записи. Обычно в роли СК выступает автоинкрементное поле типа INTEGER.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_индексы_какие_они_бывают">Что такое индексы? Какие они бывают?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Индекс (index) — объект базы данных, создаваемый с целью повышения производительности выборки данных. Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию будет путем последовательного просмотра набора данных запись за записью может занимать много времени.</p>
</div>
<div class="paragraph">
<p>Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.</p>
</div>
<div class="paragraph">
<p>Преимущества</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ускорение поиска и сортировки по определенному полю или набору полей</p>
</li>
<li>
<p>обеспечение уникальности данных</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Недостатки</p>
</div>
<div class="ulist">
<ul>
<li>
<p>требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса</p>
</li>
<li>
<p>замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Индексы предпочтительней для:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле</p>
</li>
<li>
<p>Поля, по которому проводится сортировка данных</p>
</li>
<li>
<p>Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее</p>
</li>
<li>
<p>Поля, которое объявлено первичным ключом (primary key)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_truncate_отличается_от_delete">Чем TRUNCATE отличается от DELETE?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию WHERE при этом задействуются триггеры, ограничения и т.д.</p>
</div>
<div class="paragraph">
<p>Можно сделать ROLLBACK.</p>
</div>
<div class="paragraph">
<p>TRUNCATE - DDL оператор (удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки FOREIGN KEY или таблица используется в репликации, то пересоздать такую таблицу не получится).</p>
</div>
<div class="paragraph">
<p>Нельзя сделать ROLLBACK.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_хранимые_процедуры_для_чего_они_нужны">Что такое хранимые процедуры? Для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которые могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.</p>
</div>
<div class="paragraph">
<p>Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.</p>
</div>
<div class="paragraph">
<p>Например, пусть в базе данных есть таблица, которая хранит данные о товарах:</p>
</div>
<div class="paragraph">
<p><code>CREATE</code> <code>TABLE</code> <code>Products</code></p>
</div>
<div class="paragraph">
<p><code>(</code></p>
</div>
<div class="paragraph">
<p>`    <code>Id </code>INT` <code>IDENTITY <code>PRIMARY</code> <code>KEY</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>ProductName NVARCHAR(30) </code>NOT` <code>NULL`</code>,`</p>
</div>
<div class="paragraph">
<p>`    <code>Manufacturer NVARCHAR(20) </code>NOT` <code>NULL`</code>,`</p>
</div>
<div class="paragraph">
<p>`    <code>ProductCount </code>INT` <code>DEFAULT</code> <code>0,</code></p>
</div>
<div class="paragraph">
<p>`    <code>Price MONEY </code>NOT` <code>NULL</code></p>
</div>
<div class="paragraph">
<p><code>);</code>&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>Создадим хранимую процедуру для извлечения данных из этой таблицы:</p>
</div>
<div class="paragraph">
<p><code>{</code></p>
</div>
<div class="paragraph">
<p><code>&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;USE productsdb;</code></p>
</div>
<div class="paragraph">
<p><code>&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;GO</code></p>
</div>
<div class="paragraph">
<p><code>&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;CREATE</code> <code>PROCEDURE</code> <code>ProductSummary ``AS</code></p>
</div>
<div class="paragraph">
<p><code>&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;SELECT</code> <code>ProductName ``AS</code> <code>Product, Manufacturer, Price</code></p>
</div>
<div class="paragraph">
<p><code>&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;FROM</code> <code>Products</code></p>
</div>
<div class="paragraph">
<p><code>};</code>&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_представления_view_для_чего_они_нужны">Что такое представления (VIEW)? Для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.</p>
</div>
<div class="paragraph">
<p>Представления иногда называют «виртуальными таблицами». Такое название связано с тем, что представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему. Если данные изменены в базовой таблице, то пользователь получит актуальные данные при обращении к представлению, использующему данную таблицу; кэширования результатов выборки из таблицы при работе представлений не производится. При этом, механизм кэширования запросов (query cache) работает на уровне запросов пользователя безотносительно к тому, обращается ли пользователь к таблицам или представлениям.</p>
</div>
<div class="paragraph">
<p>Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).</p>
</div>
<div class="paragraph">
<p>Например, пусть у нас есть три связанных таблицы:</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p><code>CREATE</code> <code>TABLE</code> <code>Products</code></p>
</div>
<div class="paragraph">
<p><code>(</code></p>
</div>
<div class="paragraph">
<p>`    <code>Id </code>INT` <code>IDENTITY <code>PRIMARY</code> <code>KEY</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>ProductName NVARCHAR(30) </code>NOT` <code>NULL`</code>,`</p>
</div>
<div class="paragraph">
<p>`    <code>Manufacturer NVARCHAR(20) </code>NOT` <code>NULL`</code>,`</p>
</div>
<div class="paragraph">
<p>`    <code>ProductCount </code>INT` <code>DEFAULT</code> <code>0,</code></p>
</div>
<div class="paragraph">
<p>`    <code>Price MONEY </code>NOT` <code>NULL</code></p>
</div>
<div class="paragraph">
<p><code>);</code></p>
</div>
<div class="paragraph">
<p><code>CREATE</code> <code>TABLE</code> <code>Customers</code></p>
</div>
<div class="paragraph">
<p><code>(</code></p>
</div>
<div class="paragraph">
<p>`    <code>Id </code>INT` <code>IDENTITY <code>PRIMARY</code> <code>KEY</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>FirstName NVARCHAR(30) </code>NOT` <code>NULL</code></p>
</div>
<div class="paragraph">
<p><code>);</code></p>
</div>
<div class="paragraph">
<p><code>CREATE</code> <code>TABLE</code> <code>Orders</code></p>
</div>
<div class="paragraph">
<p><code>(</code></p>
</div>
<div class="paragraph">
<p>`    <code>Id </code>INT` <code>IDENTITY <code>PRIMARY</code> <code>KEY</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>ProductId </code>INT` <code>NOT</code> <code>NULL</code> <code>REFERENCES</code> <code>Products(Id) <code>ON</code> <code>DELETE</code> <code>CASCADE</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>CustomerId </code>INT` <code>NOT</code> <code>NULL</code> <code>REFERENCES</code> <code>Customers(Id) <code>ON</code> <code>DELETE</code> <code>CASCADE</code>,</code></p>
</div>
<div class="paragraph">
<p>`    <code>CreatedAt </code>DATE` <code>NOT</code> <code>NULL`</code>,`</p>
</div>
<div class="paragraph">
<p>`    <code>ProductCount </code>INT` <code>DEFAULT</code> <code>1,</code></p>
</div>
<div class="paragraph">
<p>`    <code>Price MONEY </code>NOT` <code>NULL</code></p>
</div>
<div class="paragraph">
<p><code>);</code></p>
</div>
<div class="paragraph">
<p>Теперь добавим в базу данных, в которой содержатся данные таблицы, следующее представление (VIEW):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>`{`

`&lt;span style=""font-family: Arial;""&gt; &lt;/span&gt;`    `&lt;span style=""font-family: Arial;""&gt;   &lt;/span&gt;CREATE` `VIEW` `OrdersProductsCustomers ``AS`

`&lt;span style=""font-family: Arial;""&gt; &lt;/span&gt;`    `&lt;span style=""font-family: Arial;""&gt;   &lt;/span&gt;SELECT` `Orders.CreatedAt ``AS` `OrderDate,`

`&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;`    ` ``Customers.FirstName ``AS` `Customer,`

`&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;  `    ` ``Products.ProductName ``As` `Product `

`&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;`    `FROM` `Orders

`INNER` `JOIN` `Products ``ON` `Orders.ProductId = Products.Id`

`&lt;span style=""font-family: Arial;""&gt;    &lt;/span&gt;`    `    `    `INNER` `JOIN` `Customers ``ON` `Orders.CustomerId = Customers.Id`

`};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_временные_таблицы_для_чего_они_нужны">Что такое временные таблицы? Для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Некоторые RDBMS (Relational Database Management System) поддерживают механизм временных таблиц.</p>
</div>
<div class="paragraph">
<p>Они позволяют нам хранить и обрабатывать промежуточные результаты используя все возможности SQL сервера.</p>
</div>
<div class="paragraph">
<p>Временные таблицы могут быть крайне полезными, когда нам необходимо хранить различные временные данные (например, список товаров в чеке, до момента осуществления оплаты). Главное преимущество таких таблиц заключается в том, что они будет удалены сразу же после завершения клиентской сессии.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_транзакции_расскажите_про_принципы_acid">Что такое транзакции? Расскажите про принципы ACID</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.</p>
</div>
<div class="paragraph">
<p>Основные свойства транзакции:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Атомарность (atomicity) - гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной</p>
</li>
<li>
<p>Согласованность (consistency) -  транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных</p>
</li>
<li>
<p>Изолированность (isolation) - во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат</p>
</li>
<li>
<p>Долговечность (durability) - независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_уровни_изолированности_транзакций">Расскажите про уровни изолированности транзакций</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В порядке увеличения изолированности транзакций и, соответственно, надежности работы с данными:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read) — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Чтение подтвержденных данных (read committed) — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Повторяемость чтения (repeatable read, snapshot) — чтение всех изменений своей транзакции, любые изменения, внесенные параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.</p>
</li>
<li>
<p>Упорядочиваемость (serializable) — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_нормализация_и_денормализация_расскажите_про_3_нормальные_формы">Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Подробно с примерами: &lt;a href=""https://habr.com/ru/post/254773/""&gt;https://habr.com/ru/post/254773/&lt;/a&gt;</p>
</div>
<div class="paragraph">
<p>Нормализация - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходно схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>
</div>
<div class="paragraph">
<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объема базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p>
</div>
<div class="paragraph">
<p>Денормализация базы данных — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Первая нормальная форма (1NF) - отношение находится в 1NF, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице. Значение в столбце должно быть атомарным, то есть не должно содержать несколько значений.</p>
<div class="ulist">
<ul>
<li>
<p>Устраните повторяющиеся группы в отдельных таблицах.</p>
</li>
<li>
<p>Создайте отдельную таблицу для каждого набора связанных данных.</p>
</li>
<li>
<p>Идентифицируйте каждый набор связанных данных с помощью первичного ключа.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Вторая нормальная форма (2NF) - Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.</p>
<div class="ulist">
<ul>
<li>
<p>Создайте отдельные таблицы для наборов значений, относящихся к нескольким записям.</p>
</li>
<li>
<p>Свяжите эти таблицы с помощью внешнего ключа</p>
</li>
</ul>
</div>
</li>
<li>
<p>Третья нормальная форма (3NF) - Отношение находится в 3NF, если оно находится в 2NF и все неключевые атрибуты не зависят друг от друга.</p>
<div class="ulist">
<ul>
<li>
<p>Устраните поля, не зависящие от ключа</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_timestamp">Что такое TIMESTAMP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>DATETIME</code> - предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт</p>
</div>
<div class="paragraph">
<p><code>TIMESTAMP</code> - хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усредненному времени Гринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_orm_что_такое_jpa_что_такое_hibernate">Что такое ORM? Что такое JPA? Что такое Hibernate?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Object Relational Mapping</strong> - это концепция/процесс преобразования данных из объектно-ориентированного языка в реляционные БД и наоборот. Например, в Java это делается с помощью рефлексии и JDBC.</p>
</div>
<div class="paragraph">
<p><a href="http://internetka.in.ua/orm-intro/" class="bare">http://internetka.in.ua/orm-intro/</a> подробнее</p>
</div>
<div class="paragraph">
<p><strong>JPA</strong> – это технология, обеспечивающая объектно-реляционное отображение простых JAVA объектов и предоставляющая API для сохранения, получения и управления такими объектами.</p>
</div>
<div class="paragraph">
<p><strong>JPA</strong> – это спецификация (документ, утвержденный как стандарт, описывающий все аспекты технологии), часть EJB3 спецификации.</p>
</div>
<div class="paragraph">
<p>Сам JP*A не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как что-то будет действовать. JPA также определяет интерфейсы, которые должны будут быть реализованы провайдерами. Плюс к этому JPA определяет правила о том, как должны описываться метаданные отображения и о том, как должны работать провайдеры. Дальше, каждый провайдер, реализуя JPA определяет получение, сохранение и управление объектами. У каждого провайдера реализация разная.</p>
</div>
<div class="paragraph">
<p><strong>Hibernate</strong> - это провайдер, реализующий спецификацию JPA. Hibernate полностью реализует JPA плюс добавляет функционал в виде своих классов и интерфейсов, расширяя свои возможности по работе с сущностями и БД.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_entitymanager_какие_функции_он_выполняет">Что такое EntityManager? Какие функции он выполняет?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это интерфейс JPA, используемый для взаимодействия с персистентным контекстом. EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других сущностей JPA. По сути - главный API для работы с JPA.</p>
</div>
<div class="paragraph">
<p>Персистентный контекст - это набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции - это и есть кэш первого уровня.</p>
</div>
<div class="paragraph">
<p>Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом. EntityManager автоматически сохраняет в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода flush().</p>
</div>
<div class="paragraph">
<p>Один или несколько EntityManager образуют или могут образовать persistence context.</p>
</div>
<div class="paragraph">
<p>Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource, а EntityManager аналогом Connection.</p>
</div>
<div class="paragraph">
<p>Интерфейс Session из Hibernate представлен в JPA как раз интерфейсом EntityManager.</p>
</div>
<div class="paragraph">
<p>Основные функции EntityManager&lt;/div&gt; Операции над Entity:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>persist (добавление Entity под управление JPA)</p>
</li>
<li>
<p>merge (изменение)</p>
</li>
<li>
<p>remove (удаление)</p>
</li>
<li>
<p>refresh (обновление данных)</p>
</li>
<li>
<p>detach (удаление из-под управления контекста персистентности)</p>
</li>
<li>
<p>lock (блокирование Entity от изменений в других thread)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Получение данных:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>find (поиск и получение Entity)</p>
</li>
<li>
<p>createQuery</p>
</li>
<li>
<p>createNamedQuery</p>
</li>
<li>
<p>createNativeQuery</p>
</li>
<li>
<p>contains</p>
</li>
<li>
<p>createNamedStoredProcedureQuery</p>
</li>
<li>
<p>createStoredProcedureQuery</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Получение других сущностей JPA:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getTransaction</p>
</li>
<li>
<p>getEntityManagerFactory</p>
</li>
<li>
<p>getCriteriaBuilder</p>
</li>
<li>
<p>getMetamodel</p>
</li>
<li>
<p>getDelegate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Работа с EntityGraph:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>createEntityGraph</p>
</li>
<li>
<p>getEntityGraph</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Общие операции над EntityManager или всеми Entities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>close</p>
</li>
<li>
<p>isOpen</p>
</li>
<li>
<p>getProperties</p>
</li>
<li>
<p>setProperty</p>
</li>
<li>
<p>clear</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_условиям_должен_удовлетворять_класс_чтобы_являться_entity">Каким условиям должен удовлетворять класс чтобы являться Entity?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate позволяет определить обычный Java класс, как часть модели реляционной реляционной базы данных, точнее соответствие определенного класса к таблице модели базы данных. Что необходимо определить на уровне Java кода рассмотрим в данном материале.</p>
</div>
<div class="paragraph">
<p>Для начала, остановимся на основных требованиях JPA спецификации, которые необходимо учитывать при создании Entity класса (выполнение следующих требований позволяет переносить Entity классы под иную реализацию JPA):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Entity класс должен быть отмечен аннотацией @Entity или описан в XML файле конфигурации JPA</p>
</li>
<li>
<p>Enity класс должен содержать первичный ключ (ID), то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных</p>
</li>
<li>
<p>Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами)</p>
</li>
<li>
<p>Entity класс должен быть классом верхнего уровня (top-level class)</p>
</li>
<li>
<p>Entity класс не может быть enum или интерфейсом</p>
</li>
<li>
<p>Entity класс не может быть финальным классом (final class)</p>
</li>
<li>
<p>Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables)</p>
</li>
<li>
<p>Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс</p>
</li>
<li>
<p>Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_абстрактный_класс_быть_entity">Может ли абстрактный класс быть Entity?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Абстрактный класс может быть Entity классом. Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого класса. Имена абстрактных классов могут использоваться в запросах.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_entity_класс_наследоваться_от_не_entity_классов_non_entity_classes">Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, сущности могут наследоваться от не Entity классов, которые, в свою очередь, могут быть как абстрактными, так и обычными. Состояние (поля) не Entity суперкласса не является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом, также не будет отображаться в БД.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_entity_класс_наследоваться_от_других_entity_классов">Может ли Entity класс наследоваться от других Entity классов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_не_entity_класс_наследоваться_от_entity_класса">Может ли не Entity класс наследоваться от Entity класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_встраиваемый_embeddable_класс_какие_требования_jpa_устанавливает_к_встраиваемым_embeddable_классам">Что такое встраиваемый (Embeddable) класс?  Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов. Hibernate называет эти классы компонентами. JPA называет их встраиваемыми. В любом случае, концепция одна и та же: композиция значений.</p>
</div>
<div class="paragraph">
<p>Встраиваемый класс помечается аннотацией @Embeddable.</p>
</div>
<div class="paragraph">
<p>Встраиваемый класс может быть встроен в несколько классов-сущностей, но встроенный объект с конкретным состоянием принадлежит исключительно владеющей им сущности и не может использоваться одновременно другими сущностями, он не является общим для нескольких сущностей. То есть, если класс Person с полями name и age встроен и в класс Driver, и в класс Baker, то у обоих последних классов появятся оба поля из класса Person. Но если у объекта Driver эти поля будут иметь значения “Иван” и “35”, то эти же поля у объекта Baker могут иметь совершенно иные значения, никак не связанные с объектом Driver.</p>
</div>
<div class="paragraph">
<p>В целом, встраиваемый класс служит для того, чтобы выносить определение общих атрибутов для нескольких сущностей, можно считать что JPA просто встраивает в сущность вместо объекта такого класса те атрибуты, которые он содержит.</p>
</div>
<div class="paragraph">
<p>Особенности встраиваемых классов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>все поля встраиваемого класса, даже коллекции, станут полями класса, в который происходит встраивание</p>
</li>
<li>
<p>встраиваемые классы могут быть встроены в одну и ту же сущность несколько раз, нужно только поменять имена полей</p>
</li>
<li>
<p>экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они принадлежат</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Встраиваемые классы могут использовать в качестве полей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>базовые типы</p>
</li>
<li>
<p>коллекции базовых типов (с аннотацией @ElementCollection)</p>
</li>
<li>
<p>другие встраиваемые классы</p>
</li>
<li>
<p>коллекции других встраиваемых классов (с аннотацией @ElementCollection)</p>
</li>
<li>
<p>сущности</p>
</li>
<li>
<p>коллекции сущностей</p>
</li>
<li>
<p>сущность может использовать в качестве полей одиночные встраиваемые</p>
</li>
<li>
<p>классы и коллекции встраиваемых классов</p>
</li>
<li>
<p>встраиваемые классы могут использоваться в качестве ключей и значений Map</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Требования к встраиваемым классам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Должны соответствовать требованиям для сущностей (раздел 2.1 Java Persistence API), за исключением того, что у встраиваемых классов не ставится аннотация @Entity и может отсутствовать первичный ключ (@Id).</p>
</li>
<li>
<p>Должны быть аннотированы @Embeddable.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_mapped_superclass">Что такое Mapped Superclass?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mapped Superclass (сопоставленный суперкласс) - это класс, от которого наследуются Entity, он может содержать аннотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования, установленные для Entity (например, он может не содержать первичного ключа). Эти суперклассы чаще всего используются, когда у нас есть общая для нескольких классов сущностей информация о состоянии и отображении, которую можно вынести в Mapped Superclass.</p>
</div>
<div class="paragraph">
<p>Особенности Mapped Superclass:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Должен быть помечен аннотацией @MappedSuperclass или описан в xml файле.</p>
</li>
<li>
<p>Не может использоваться в операциях EntityManager или Query, вместо этого нужно использовать классы-наследники.</p>
</li>
<li>
<p>Не может состоять в отношениях с другими сущностями (в сущности нельзя создать поле с типом сопоставленного суперкласса).</p>
</li>
<li>
<p>Может быть абстрактным.</p>
</li>
<li>
<p>Не имеет своей таблицы в БД.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mapped Superclass vs. Embeddable class</p>
</div>
<div class="paragraph">
<p>Сходства:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>не являются сущностями и могут иметь все аннотации, кроме @Entity;</p>
</li>
<li>
<p>не имеют своих таблиц в БД;</p>
</li>
<li>
<p>не могут использоваться в операциях EntityManager или Query.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Различия:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mapped Superclass - наследование, Embeddable class - композиция;</p>
</li>
<li>
<p>поля из Mapped Superclass могут быть у сущности в одном экземпляре, полей из Embeddable class может быть сколько угодно (встроив в сущность Embeddable class несколько раз и поменяв имена полей);</p>
</li>
<li>
<p>в сущности нельзя создать поле с типом сопоставленного суперкласса, а с Embeddable можно и нужно.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_три_стратегии_наследования_маппинга_inheritance_mapping_strategies_описаны_в_jpa">Какие три стратегии наследования маппинга (Inheritance Mapping Strategies) описаны в JPA?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники. Для этого нам нужно декорировать родительский класс аннотацией @Inheritance и указать один из типов отображения: SINGLE_TABLE, TABLE_PER_CLASS, JOINED.</p>
</div>
<div class="paragraph">
<p>Следующие три стратегии используются для отображения данных сущности- наследника и родительской сущности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Одна таблица на всю иерархию классов</p>
</li>
<li>
<p>Таблица для каждого конкретного класса сущностей</p>
</li>
<li>
<p>Стратегия «соединения», при которой поля или свойства, специфичные для подклассов, отображаются в таблицах этих подклассов, а поля или свойства родительского класса отображаются в таблице родительского класса</p>
</li>
<li>
<p>одна таблица на всю иерархию наследования (a single table per class hierarchy) — все entity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog».Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соответственно.</p>
</li>
<li>
<p>объединяющая стратегия (joined subclass strategy) — в этой стратегии каждый класс entity сохраняет данные в свою таблицу, но только уникальные колонки (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций.</p>
</li>
<li>
<p>одна таблица для каждого класса (table per concrete class strategy) — тут все просто каждый отдельный класс-наследник имеет свою таблицу, т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_мапятся_enumы">Как мапятся Enumы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>По порядковым номерам.</p>
</div>
<div class="paragraph">
<p>Если мы сохраняем в БД сущность, у которой есть поле-перечисление (Enum), то в таблице этой сущности создаётся колонка для значений этого перечисления и по умолчанию в ячейки сохраняется порядковый номер этого перечисления (ordinal).</p>
</div>
<div class="paragraph">
<p>В JPA типы Enum могут быть помечены аннотацией @Enumerated, которая может принимать в качестве атрибута EnumType.ORDINAL или EnumType.STRING, определяющий, отображается ли перечисление (enum) на столбец с типом Integer или String соответственно.</p>
</div>
<div class="paragraph">
<p>@Enumerated(EnumType.ORDINAL) - значение по умолчанию, говорит о том, что в базе будут храниться порядковые номера Enum (0, 1, 2…). Проблема с этим типом отображения возникает, когда нам нужно изменить наш Enum. Если мы добавим новое значение в середину или просто изменим порядок перечисления, мы сломаем существующую модель данных. Такие проблемы могут быть трудно уловимыми, и нам придется обновлять все записи базы данных.</p>
</div>
<div class="paragraph">
<p>По именам</p>
</div>
<div class="paragraph">
<p>@Enumerated(EnumType.STRING) - означает, что в базе будут храниться имена Enum. С @Enumerated(EnumType.STRING) мы можем безопасно добавлять новые значения перечисления или изменять порядок перечисления. Однако переименование значения enum все равно нарушит работу базы данных. Кроме того, даже несмотря на то, что это представление данных гораздо более читаемо по сравнению с параметром @Enumerated(EnumType.ORDINAL), оно потребляет намного больше места, чем необходимо. Это может оказаться серьезной проблемой, когда нам нужно иметь дело с большим объемом данных.</p>
</div>
<div class="paragraph">
<p>@PostLoad и @PrePersist</p>
</div>
<div class="paragraph">
<p>Другой вариант - использование стандартных методов обратного вызова из JPA. Мы можем смаппить наши перечисления в БД и обратно в методах с аннотациями @PostLoad и @PrePersist.</p>
</div>
<div class="paragraph">
<p>Идея состоит в том, чтобы в сущности иметь не только поле с Enum, но и вспомогательное поле. Поле с Enum аннотируем @Transient, а в БД будет храниться значение из вспомогательного поля.</p>
</div>
<div class="paragraph">
<p>Несмотря на то, что этот вариант дает нам бОльшую гибкость по сравнению с ранее описанными решениями, он не идеален. Просто кажется неправильным иметь в сущности целых два атрибута, представляющих одно перечисление. Кроме того, если мы используем этот вариант, мы не сможем использовать значение Enum в запросах JPQL.</p>
</div>
<div class="paragraph">
<p>Converter</p>
</div>
<div class="paragraph">
<p>В JPA с версии 2.1 можно использовать Converter для конвертации Enum’а в некое его значение для сохранения в БД и получения из БД. Все, что нам нужно сделать, это создать новый класс, который реализует javax.persistence.AttributeConverter и аннотировать его с помощью @Converter.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_мапятся_даты_до_java_8_и_после">Как мапятся даты (до Java 8 и после)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При работе с датами рекомендуется установить определенный часовой пояс для драйвера JDBC. Таким образом, наше приложение будет независимым от текущего часового пояса системы.</p>
</div>
<div class="paragraph">
<p>Другой способ - настроить свойство hibernate.jdbc.time_zone в файле свойств Hibernate, который используется для создания фабрики сессий. Таким образом, мы можем указать часовой пояс один раз для всего приложения.</p>
</div>
<div class="paragraph">
<p>java.sql</p>
</div>
<div class="paragraph">
<p>Стандарт SQL определяет три типа даты/времени:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DATE - Представляет календарную дату путем хранения лет, месяцев и дней. Эквивалентом JDBC является java.sql.Date.</p>
</li>
<li>
<p>TIME - Представляет время дня и хранит часы, минуты и секунды. Эквивалентом JDBC является java.sql.Time.</p>
</li>
<li>
<p>TIMESTAMP - Хранит как DATE, так и TIME плюс наносекунды. Эквивалентом JDBC является java.sql.Timestamp.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Поскольку эти типы соответствуют SQL, их сопоставление относительно простое. Мы можем использовать аннотацию @Basic или @Column.</p>
</div>
<div class="paragraph">
<p>java.sql не рекомендуют использовать, т.к. содержит устаревшие функции. Лучше использовать java.sql</p>
</div>
<div class="paragraph">
<p>java.sql</p>
</div>
<div class="paragraph">
<p>Так как классы из этого пакета не имели прямого соответствия типам данных SQL, приходилось использовать над полями java.util.Date аннотацию @Temporal, чтобы дать понять SQL, с каким конкретно типом данных она работает.</p>
</div>
<div class="paragraph">
<p>Для этого у аннотации @Temporal нужно было указать параметр TemporalType, который принимал одно из трёх значений: DATE, TIME или TIMESTAMP, что позволяло указать базе данных с какими конкретными типами данных она работает.</p>
</div>
<div class="paragraph">
<p>java.time</p>
</div>
<div class="paragraph">
<p>Начиная с Java 8, доступен новый API даты и времени для работы с временными значениями. Этот API-интерфейс устраняет многие проблемы классов java.util.Date и java.util.Calendar. Все классы в новом API неизменяемые (immutable) и, как следствие, потоко-безопасные. Точность представления времени составляет одну наносекунду, что в миллион раз точнее чем в пакете java.util. Типы данных из пакета java.time напрямую отображаются (маппятся) на соответствующие типы SQL. Поэтому нет необходимости явно указывать аннотацию @Temporal:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LocalDate соответствует DATE.</p>
</li>
<li>
<p>LocalTime и OffsetTime соответствуют TIME.</p>
</li>
<li>
<p>Instant, LocalDateTime, OffsetDateTime и ZonedDateTime соответствуют TIMESTAMP.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это означает, что мы можем пометить эти поля только аннотацией @Basic (или @Column).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_смапить_коллекцию_примитивов">Как “смапить” коллекцию примитивов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для маппинга коллекции элементов используется аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции базовых или встраиваемых типов. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну дл сущности, вторую для коллекции элементов.</p>
</div>
<div class="paragraph">
<p>Конфигурация для таблицы коллекции элементов указывается с помощью аннотации @CollectionTable, которая используется для указания имени таблицы коллекции и JoinColumn, который ссылается на первичную таблицу.</p>
</div>
<div class="paragraph">
<p>Аннотация @ElementCollection похожа на отношение @OneToMany, за исключением того, что целью являются базовые и встраиваемые типы, а не сущности.</p>
</div>
<div class="paragraph">
<p>Можно использовать аннотации @AttributeOverrides и @AttributeOverride для настройки отображения в таблице полей базовых или встраиваемых типов.</p>
</div>
<div class="paragraph">
<p>Коллекции могут иметь тип java.util.Map, которые состоят из ключа и значения.</p>
</div>
<div class="paragraph">
<p>Для этого типа коллекций применяются следующие правила:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ключ или значение Map может быть базовым типом языка программирования Java, встраиваемым классом или сущностью.</p>
</li>
<li>
<p>Если значение Map является встраиваемым классом или базовым типом, используйте аннотацию @ElementCollection.</p>
</li>
<li>
<p>Если значение Map является сущностью, используйте аннотацию @OneToMany или @ManyToMany. Использовать тип Map только на одной стороне двунаправленной связи.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Аннотация @MapKeyColumn позволяет настроить столбец «ключ» в таблице Map. Аннотация @Column позволяет настроить столбец «значение» в таблице Map.</p>
</div>
<div class="paragraph">
<p>Работать в Hibernate с коллекциями не рекомендуется, потому что Hibernate не умеет работать с каждым элементом индивидуально и при удалении или вставке элемента Hibernate очищает всю таблицу и заполняет ее заново. Желательно работать только с коллекциями с малым количеством элементов</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_есть_виды_связей">Какие есть виды связей?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Существуют 4 типа связей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.</p>
</li>
<li>
<p>OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.</p>
</li>
<li>
<p>ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.</p>
</li>
<li>
<p>ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Каждую из которых можно разделить ещё на два вида:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*Bidirectional *— ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).</p>
</li>
<li>
<p>*Undirectional *—  ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_владелец_связи">Что такое владелец связи?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.</p>
</div>
<div class="paragraph">
<p>По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.</p>
</div>
<div class="paragraph">
<p>В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_каскады">Что такое каскады?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Каскадирование - это когда мы выполняем какое-то действие с целевой Entity, то же самое действие будет применено к связанной Entity.</p>
</div>
<div class="paragraph">
<p>JPA CascadeType:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ALL -  гарантируют, что все персистентные события, которые происходят на родительском объекте, будут переданы дочернему объекту.</p>
</li>
<li>
<p>PERSIST -  означает, что операции save () или persist () каскадно передаются связанным объектам.</p>
</li>
<li>
<p>MERGE - означает, что связанные entity объединяются, когда объединяется entity-владелец.</p>
</li>
<li>
<p>REMOVE - удаляет все entity, связанные с удаляемой entity.</p>
</li>
<li>
<p>DETACH - отключает все связанные entity, если происходит «ручное отключение».</p>
</li>
<li>
<p>REFRESH - повторно считывают значение данного экземпляра и связанных сущностей из базы данных при вызове refresh().</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_два_типа_fetch_стратегии_в_jpa_вы_знаете">Какие два типа fetch стратегии в JPA вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В JPA описаны два типа fetch-стратегии:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>LAZY — данные поля сущности будут загружены только во время первого обращения к этому полю.</p>
</li>
<li>
<p>EAGER — данные поля будут загружены немедленно вместе с сущностью. FetchType.EAGER: Hibernate должен сразу загрузить соответствующее аннотированное поле или свойство. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FetchType.LAZY: Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и ElementCollection.</p>
</div>
<div class="paragraph">
<p>Раньше у Hibernate все поля были LAZY, но в последних версиях - всё как в JPA.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_четыре_статуса_жизненного_цикла_entity_объекта_entity_instances_life_cycle_вы_можете_перечислить">Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Согласно JPA объект сущности может иметь один из четырех статусов жизненного цикла:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>new - объект создан, не имеет primary key, не является частью контекста персистентности (не управляется JPA)</p>
</li>
<li>
<p>managed - объект создан, имеет primary key, является частью контекста персистентности (управляется JPA)</p>
</li>
<li>
<p>detached - объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA)</p>
</li>
<li>
<p>removed - объект создан, является частью контекста персистентности (управляется JPA), будет удален при commit-е транзакции</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_влияет_операция_persist_на_entity_объекты_каждого_из_четырех_статусов">Как влияет операция persist на Entity объекты каждого из четырех статусов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций</p>
</div>
<div class="paragraph">
<p>managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений</p>
</div>
<div class="paragraph">
<p>detached → exception сразу или на этапе commit-а транзакции</p>
</div>
<div class="paragraph">
<p>removed → managed, но только в рамках одной транзакции.</p>
</div>
<div class="paragraph">
<p>new -&gt; managed</p>
</div>
<div class="paragraph">
<p>managed -&gt; ignore</p>
</div>
<div class="paragraph">
<p>detached -&gt; exeption</p>
</div>
<div class="paragraph">
<p>removed -&gt; managed</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_влияет_операция_remove_на_entity_объекты_каждого_из_четырех_статусов">Как влияет операция remove на Entity объекты каждого из четырех статусов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed</p>
</div>
<div class="paragraph">
<p>managed → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)</p>
</div>
<div class="paragraph">
<p>detached → exception сразу или на этапе commit-а транзакции</p>
</div>
<div class="paragraph">
<p>removed → операция игнорируется</p>
</div>
<div class="paragraph">
<p>new -&gt; ignore</p>
</div>
<div class="paragraph">
<p>managed -&gt; removed</p>
</div>
<div class="paragraph">
<p>detached -&gt; exeption</p>
</div>
<div class="paragraph">
<p>removed -&gt; ignore</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_влияет_операция_merge_на_entity_объекты_каждого_из_четырех_статусов">Как влияет операция merge на Entity объекты каждого из четырех статусов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>new → будет создан новый managed entity, в который будут скопированы данные прошлого объекта</p>
</div>
<div class="paragraph">
<p>managed → операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed</p>
</div>
<div class="paragraph">
<p>detached → либо данные будут скопированы в существующий managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные</p>
</div>
<div class="paragraph">
<p>removed → exception сразу или на этапе commit-а транзакции</p>
</div>
<div class="paragraph">
<p>new -&gt; managed</p>
</div>
<div class="paragraph">
<p>managed -&gt; ignore</p>
</div>
<div class="paragraph">
<p>detached -&gt; managed</p>
</div>
<div class="paragraph">
<p>remove -&gt; exception</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_влияет_операция_refresh_на_entity_объекты_каждого_из_четырех_статусов">Как влияет операция refresh на Entity объекты каждого из четырех статусов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов</p>
</div>
<div class="paragraph">
<p>new, removed, detached → exception</p>
</div>
<div class="paragraph">
<p>new, remove, detached -&gt; e</p>
</div>
<div class="paragraph">
<p>managed -&gt; update from db</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_влияет_операция_detach_на_entity_объекты_каждого_из_четырех_статусов">Как влияет операция detach на Entity объекты каждого из четырех статусов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>managed, removed → detached.</p>
</div>
<div class="paragraph">
<p>new, detached → операция игнорируется</p>
</div>
<div class="paragraph">
<p>new -&gt; ignore</p>
</div>
<div class="paragraph">
<p>managed -&gt; detached</p>
</div>
<div class="paragraph">
<p>removed -&gt; detached</p>
</div>
<div class="paragraph">
<p>detached -&gt; ignore</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_basic">Для чего нужна аннотация Basic?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Basic — аннотация используется для сопоставления базового типа атрибута столбцу таблицы базы данных.</p>
</div>
<div class="paragraph">
<p>@Basic —  указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет.</p>
</div>
<div class="paragraph">
<p>Может быть применена к полю любого из следующих типов:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Примитивы и их обертки.</p>
</li>
<li>
<p>java.lang.String</p>
</li>
<li>
<p>java.math.BigInteger</p>
</li>
<li>
<p>java.math.BigDecimal</p>
</li>
<li>
<p>java.util.Date</p>
</li>
<li>
<p>java.util.Calendar</p>
</li>
<li>
<p>java.sql.Date</p>
</li>
<li>
<p>java.sql.Time</p>
</li>
<li>
<p>java.sql.Timestamp</p>
</li>
<li>
<p>byte[] or Byte[] char[] or Character[]</p>
</li>
<li>
<p>enums любые другие типы, которые реализуют Serializable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Вообще, аннотацию @Basic можно не ставить, так как это происходит по умолчанию.</p>
</div>
<div class="paragraph">
<p>Аннотация @Basic определяет 2 атрибута:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.</p>
</li>
<li>
<p>fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_column">Для чего нужна аннотация Column?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Column — аннотирование используется для указания соответствия между атрибутом базовой сущности (Entity класса) и столбцом таблицы базы данных.</p>
</div>
<div class="paragraph">
<p>Спецификация JPA определяет правила для неявного определения имени столбцов (column). Для атрибутов базового типа правило неявного именования состоит в том, что имя столбца совпадает с именем атрибута. Если это неявное правило именования не удовлетворяет вашим требованиям, вы можете явно указать Hibernate (и другим провайдерам) имя столбца, которое будет использоваться явно.</p>
</div>
<div class="paragraph">
<p>@Basic vs @Column:&lt;/div&gt; Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:  insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;  length - длина, для строковых типов данных, по умолчанию 255.</p>
</div>
<div class="paragraph">
<p>Коротко, в Column мы задаем constraints (ограничения), а в Basic - ФЕТЧ ТАЙП.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_access">Для чего нужна аннотация Access?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Она определяет тип доступа (access type) для класса entity, суперкласса, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).</p>
</div>
<div class="paragraph">
<p>В хибере автоматически выбирается по аннотации первичного ключа айди. Если айди над полем, то доступ через поля, а если над геттером, то через проперти.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_cacheable">Для чего нужна аннотация Cacheable?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня.</p>
</div>
<div class="paragraph">
<p>Аннотация @Cacheable размещается над классом сущности. Ее действие распространяется на эту сущность и её наследников, если они не определили другое поведение.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужны_аннотации_embedded_и_embeddable">Для чего нужны аннотации @Embedded и @Embeddable?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.</p>
</li>
<li>
<p>@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_смапить_составной_ключ">Как смапить составной ключ?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Существует три стратегии использования составного первичного ключа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Отметьте его как @Embeddable и добавьте в свой класс сущности нормальное свойство для него, помеченное @Id.</p>
</li>
<li>
<p>Добавьте к классу сущности нормальное свойство для него, помеченное @EmbeddedId.</p>
</li>
<li>
<p>Добавить свойства в класс сущности для всех его полей, пометить их @Id и пометить класс сущности @IdClass, предоставив класс вашего основного класса ключей.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Использование @Id с классом, помеченным как @Embeddable, является наиболее естественным подходом. Тег @Embeddable может использоваться для вложенных значений не первичного ключа. Он позволяет обрабатывать составной первичный ключ как одно свойство и позволяет повторно использовать класс @Embeddable в других таблицах.</p>
</div>
<div class="paragraph">
<p>Следующим наиболее естественным подходом является использование тега @EmbeddedId. Здесь класс первичного ключа не может использоваться в других таблицах, поскольку он не является объектом @Embeddable, но он позволяет нам рассматривать ключ как единственный атрибут некоторого класса.</p>
</div>
<div class="paragraph">
<p>Наконец, использование аннотаций @IdClass и @Id позволяет нам отображать составной класс первичного ключа, используя свойства самого объекта, соответствующие именам свойств в классе первичного ключа. Имена должны соответствовать (нет механизма для переопределения этого), а класс первичного ключа должен выполнять те же обязательства, что и в отношении двух других методов. Единственным преимуществом этого подхода является его способность ""скрыть"" использование класса первичного ключа из интерфейса охватывающего объекта. Аннотация @IdClass принимает параметр значения типа Class, который должен быть классом, который будет использоваться в качестве составного первичного ключа. Поля, соответствующие свойствам класса первичного ключа, которые должны использоваться, должны быть аннотированы с помощью @Id.</p>
</div>
<div class="paragraph">
<p>@IdClass vs @EmbeddedId:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>с @IdClass нам пришлось указывать столбцы дважды - в AccountId и в Account. Но с @EmbeddedId мы этого не сделали;</p>
</li>
<li>
<p>JPQL-запросы с @IdClass проще. С @EmbeddedId, чтобы получить доступ к полю, нам нужно из сущности обратиться к встраиваемому классу и потом к его полю:</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;i&gt;SELECT account.accountNumber FROM Account account // с @IdClass&lt;/i&gt;&lt;i&gt;</p>
</div>
<div class="paragraph">
<p>SELECT book.bookId.title FROM Book book // с @EmbeddedId</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;
* @EmbeddedId более подробна, чем @IdClass, поскольку мы можем получить доступ ко всему объекту первичного ключа, используя метод доступа к полю в классе-сущности. Это также дает четкое представление о полях, которые являются частью составного ключа, поскольку все они агрегированы в классе, который доступен только через метод доступа к полям</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@IdClass может быть предпочтительным выбором по сравнению с @EmbeddedId в ситуациях, когда класс составного первичного ключа поступает из другого модуля или устаревшего кода, а также когда мы не можем его изменить, например, чтобы установить аннотацию @EmbeddedId. Для таких сценариев, где мы не можем изменить класс составного ключа, аннотация @IdClass является единственным выходом</p>
</li>
<li>
<p>если мы собираемся получить доступ к частям составного ключа по отдельности, мы можем использовать @IdClass, но в тех местах, где мы часто используем полный идентификатор в качестве объекта, @EmbeddedId предпочтительнее</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_id_какие_generatedvalue_вы_знаете">Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>примитивные типы и их обертки</p>
</li>
<li>
<p>строки</p>
</li>
<li>
<p>BigDecimal и BigInteger</p>
</li>
<li>
<p>java.util.Date и java.sql.Date</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Стратегии генерации Id</p>
</div>
<div class="paragraph">
<p>Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue. Согласно спецификации JPA возможно 4 различных варианта: AUTO, IDENTITY, SEQUENCE, TABLE. Если мы не укажем значение явно, типом генерации по умолчанию будет AUTO. Спецификация JPA строго не определяет поведение этих стратегий.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AUTO - указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию.</p>
</li>
<li>
<p>IDENTITY - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.</p>
</li>
<li>
<p>SEQUENCE - тип генерации, рекомендуемый документацией Hibernate.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе.</p>
</li>
<li>
<p>TABLE - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотации_joincolumn_и_jointable_где_и_для_чего_они_используются">Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Аннотация JoinColumn используется для указания столбца для присоединения ассоциированных сущностей или коллекции элементов.</p>
</div>
<div class="paragraph">
<p>В этой аннотации можно указать различные constraints для колонки, которая будет являться foreign key. Например unique, nullable, name, updatable, insertable и т.д.</p>
</div>
<div class="paragraph">
<p>@JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице.</p>
</div>
<div class="paragraph">
<p>Особенности использования:</p>
</div>
<div class="paragraph">
<p>@OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.</p>
</div>
<div class="paragraph">
<p>@OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.</p>
</div>
<div class="paragraph">
<p>@JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.</p>
</div>
<div class="paragraph">
<p>В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.</p>
</div>
<div class="paragraph">
<p>@JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужны_аннотации_orderby_и_ordercolumn_чем_они_отличаются">Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет. Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany.</p>
</div>
<div class="paragraph">
<p>При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.</p>
</div>
<div class="paragraph">
<p>Если это коллекция встраиваемых типов (@Embeddable), то используя точку (""""."""") мы можем сослаться на атрибут внутри встроенного атрибута.</p>
</div>
<div class="paragraph">
<p>Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности:</p>
</div>
<div class="paragraph">
<p>Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу.</p>
</div>
<div class="paragraph">
<p>В случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy (""""supervisor.name"""") повлечет Runtime Exceprtion.</p>
</div>
<div class="paragraph">
<p>@OrderColumn создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса.</p>
</div>
<div class="paragraph">
<p>Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.</p>
</div>
<div class="paragraph">
<p>@OrderBy vs @OrderColumn</p>
</div>
<div class="paragraph">
<p>Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужна_аннотация_transient">Для чего нужна аннотация Transient?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Transient – указывает, что свойство не нужно записывать. Значения под этой аннотацией не записываются в базу данных (так же не участвуют в сериализации). static и final переменные экземпляра всегда transient.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_шесть_видов_блокировок_lock_описаны_в_спецификации_jpa_или_какие_есть_значения_у_enum_lockmodetype_в_jpa">Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В порядке от самого ненадежного и быстрого, до самого надежного и медленного:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NONE — без блокировки</p>
</li>
<li>
<p>OPTIMISTIC (синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException</p>
</li>
<li>
<p>OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательн о после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение)</p>
</li>
<li>
<p>PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException</p>
</li>
<li>
<p>PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.</p>
</li>
<li>
<p>PESSIMISTIC_FORCE_INCREMENT — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путем внедрения в сущность специального поля версии:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Version</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>private long version;</pre>
</div>
</div>
<div class="paragraph">
<p>Поле, аннотирование @Version, может быть целочисленным или временным. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.</p>
</div>
<div class="paragraph">
<p>Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.</p>
</div>
<div class="paragraph">
<p>Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:</p>
</div>
<div class="paragraph">
<p>EntityManager em = entityManagerFactory.createEntityManager();</p>
</div>
<div class="paragraph">
<p>em.lock(company1, LockModeType.OPTIMISTIC).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_два_вида_кэшей_cache_вы_знаете_в_jpa_и_для_чего_они_нужны">Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;a href=""https://sysout.ru/kesh-pervogo-i-vtorogo-urovnya-v-hibernate-i-read_only-cacheconcurrencystrategy/""&gt;https://sysout.ru/kesh-pervogo-i-vtorogo-urovnya-v-hibernate-i-read_only-cacheconcurrencystrategy/&lt;/a&gt; - подробнее с примерами</p>
</div>
<div class="paragraph">
<p>Кеширование является одним из способов оптимизации работы приложения, ключевой задачей которого является уменьшить количество прямых обращений к базе данных.</p>
</div>
<div class="paragraph">
<p>Кэш первого уровня – это кэш Сессии (Session), который является обязательным. Через него проходят все запросы. Перед тем, как отправить объект в БД, сессия хранит объект за счёт своих ресурсов.</p>
</div>
<div class="paragraph">
<p>В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление для того, чтобы сократить количество выполненных запросов. Если мы закроем сессию, то все объекты, находящиеся в кэше теряются, а далее – либо сохраняются, либо обновляются. Кэш первого уровня это и есть PersistenceContext.</p>
</div>
<div class="paragraph">
<p>Кэш второго уровня является необязательным (опциональным) и изначально Hibernate будет искать необходимый объект в кэше первого уровня. В основном, кэширование второго уровня отвечает за кэширование объектов. Кэш второго уровня привязан к EntityManagerFactory.</p>
</div>
<div class="paragraph">
<p>Кэш запросов (Query Cache)</p>
</div>
<div class="paragraph">
<p>В Hibernate предусмотрен кэш для запросов и он интегрирован с кэшем второго уровня. Это требует двух дополнительных физических мест для хранения кэшированных запросов и временных меток для обновления таблицы БД. Этот вид кэширования эффективен только для часто используемых запросов с одинаковыми параметрами.</p>
</div>
<div class="paragraph">
<p>Особенности кэша первого уровня:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>включен по умолчанию, его нельзя отключить;</p>
</li>
<li>
<p>связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;</p>
</li>
<li>
<p>при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;</p>
</li>
<li>
<p>при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;</p>
</li>
<li>
<p>если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;</p>
</li>
<li>
<p>сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;</p>
</li>
<li>
<p>метод clear() очищает весь кэш сессии.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работать_с_кешем_2_уровня">Как работать с кешем 2 уровня?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.</p>
</div>
<div class="paragraph">
<p>Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.</p>
</div>
<div class="paragraph">
<p>В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache. Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. Что нужно сделать:</p>
</div>
<div class="paragraph">
<p>добавить мавен-зависимость кэш-провайдера нужной версии</p>
</div>
<div class="ulist">
<ul>
<li>
<p>включить кэш второго уровня и определить конкретного провайдера</p>
</li>
<li>
<p>hibernate.cache.use_second_level_cache=true</p>
</li>
<li>
<p>hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory</p>
</li>
<li>
<p>установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Стратегии параллельного доступа к объектам</p>
</div>
<div class="paragraph">
<p>Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно надо как-то обеспечивать их одинаковым представлением этого объекта.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>READ_ONLY: Используется только для сущностей, которые никогда не изменяются (будет выброшено исключение, если попытаться обновить такую сущность). Очень просто и производительно. Подходит для некоторых статических данных, которые не меняются.</p>
</li>
<li>
<p>NONSTRICT_READ_WRITE: Кэш обновляется после совершения транзакции, которая изменила данные в БД и закоммитила их. Таким образом, строгая согласованность не гарантируется, и существует небольшое временное окно между обновлением данных в БД и обновлением тех же данных в кэше, во время которого параллельная транзакция может получить из кэша устаревшие данные.</p>
</li>
<li>
<p>READ_WRITE: Эта стратегия гарантирует строгую согласованность, которую она достигает, используя «мягкие» блокировки: когда обновляется кэшированная сущность, на нее накладывается мягкая блокировка, которая снимается после коммита транзакции. Все параллельные транзакции, которые пытаются получить доступ к записям в кэше с наложенной мягкой блокировкой, не смогут их прочитать или записать и отправят запрос в БД. Ehcache использует эту стратегию по умолчанию.</p>
</li>
<li>
<p>TRANSACTIONAL: полноценное разделение транзакций. Каждая сессия и каждая транзакция видят объекты, словно они работали с ними последовательно одна транзакция за другой. Плата за это — блокировки и потеря производительности.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>@Cache</p>
</div>
<div class="paragraph">
<p>Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>include - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.</p>
</li>
<li>
<p>region - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша.</p>
</li>
<li>
<p>usage - задаёт стратегию одновременного доступа к объектам.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jpqlhql_и_чем_он_отличается_от_sql">Что такое JPQL/HQL и чем он отличается от SQL?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL. JPQL - это подмножество HQL. JPQL-запрос всегда является допустимым HQL - запросом, однако обратное неверно.</p>
</div>
<div class="paragraph">
<p>Java Persistence query language (JPQL)</p>
</div>
<div class="paragraph">
<p>Это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм. Также в JPQL используются функции, которых нет в SQL: такие как KEY (ключ Map’ы), VALUE (значение Map’ы), TREAT (для приведения суперкласса к его объекту - наследнику, downcasting), ENTRY и т.п.</p>
</div>
<div class="paragraph">
<p>Полиморфные запросы</p>
</div>
<div class="paragraph">
<p>В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования (например, запрос select * from Animal, вернет не только объекты Animal, но и объекты классов Cat и Dog, которые унаследованы от Animal). Чтобы исключить такое поведение используется функция TYPE в where условии (например select * from Animal a where TYPE(a) IN (Animal, Cat) уже не вернет объекты класса Dog).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_criteria_api_и_для_чего_он_используется">Что такое Criteria API и для чего он используется?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Criteria API</p>
</div>
<div class="paragraph">
<p>Это тоже язык запросов, аналогичный JPQL (Java Persistence query language), однако запросы основаны на методах и объектах. Hibernate Criteria API является более объектно-ориентированным для запросов, которые получают результат из базы данных. Для операций update, delete или других DDL манипуляций использовать Criteria API нельзя. Критерии используются только для выборки из базы данных в более объектно-ориентированном стиле. Используется для динамических запросов.</p>
</div>
<div class="paragraph">
<p>Запросы выглядят так:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt; session.createCriteria(Person.class)
 &lt;/i&gt;&lt;i&gt;.setMaxResults(10)
 &lt;/i&gt;&lt;i&gt;.list()
 &lt;/i&gt;&lt;i&gt;.forEach(System.out::println);&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Запрос выше полностью аналогичен запросу HQL ""from Person"". С Criteria также работают и все те вещи, которые работают и с Query: пейджинг, таймауты и т.д. Разумеется, в Criteria запросах можно и нужно накладывать условия, по которым объекты будут отбираться:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt; &lt;/i&gt;&lt;i&gt;session.createCriteria(Person.class)
 &lt;/i&gt;&lt;i&gt;.add(Restrictions.eq(""lastName"", ""Testoff""))
 &lt;/i&gt;&lt;i&gt;.list()
 &lt;/i&gt;&lt;i&gt;.forEach(System.out::println);&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>JPA Criteria API</p>
</div>
<div class="paragraph">
<p>Criteria API - это актуальный API, используемый для определения запросов для сущностей. Это альтернативный способ определения JPQL-запроса. Эти запросы типобезопасны, переносимы и легко меняются путем изменения синтаксиса.</p>
</div>
<div class="paragraph">
<p>Основные преимущества JPA Criteria API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ошибки могут быть обнаружены во время компиляции;</p>
</li>
<li>
<p>позволяет динамически формировать запросы на этапе выполнения приложения.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Запросы на основе строк JPQL и запросы на основе критериев JPA одинаковы по производительности и эффективности.</p>
</div>
<div class="paragraph">
<p>Для простых статических запросов предпочтительнее использовать строковые запросы JPQL (например, в виде именованных запросов). Для динамических запросов, которые создаются во время выполнения - JPA Criteria API может быть</p>
</div>
<div class="paragraph">
<p>предпочтительней. Например, построение динамического запроса на основе полей, которые пользователь заполняет в рантайме в форме, которая содержит много необязательных полей. Ожидается, что построение этого запроса будет более ясным и понятным при использовании JPA Criteria API, поскольку устраняет необходимость в создании запроса с использованием многих операций конкатенации строк.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_проблему_n1_select_и_путях_ее_решения">Расскажите про проблему N+1 Select и путях ее решения.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;a href=""https://sysout.ru/n-1-problema-v-hibernate/""&gt;https://sysout.ru/n-1-problema-v-hibernate/&lt;/a&gt; - подробно с примерами</p>
</div>
<div class="paragraph">
<p>Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.</p>
</div>
<div class="paragraph">
<p>N+1 при FetchType.EAGER</p>
</div>
<div class="paragraph">
<p>Так как у @ManyToOne план извлечения по умолчанию - EAGER, то при</p>
</div>
<div class="paragraph">
<p>получении из БД сущности немедленно будет загружена связанная с ней сущность</p>
</div>
<div class="paragraph">
<p>N+1 при FetchType.LAZY</p>
</div>
<div class="paragraph">
<p>Даже если мы явно переключимся на использование FetchType.LAZY для всех ассоциаций, мы всё равно можем столкнуться с проблемой N+1.</p>
</div>
<div class="paragraph">
<p>Решения проблемы N+1:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JOIN FETCH</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>EntityGraph</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@Fetch(FetchMode.SUBSELECT)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это Аннотация Hibernate, в JPA её нет. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@Batch fetching</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HibernateSpecificMapping, SqlResultSetMapping</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для нативных запросов рекомендуется использовать именно их.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_entitygraph_как_и_для_чего_их_использовать">Что такое EntityGraph? Как и для чего их использовать?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Основная цель JPA Entity Graph - улучшить производительность в рантайме при загрузке базовых полей сущности и связанных сущностей и коллекций.</p>
</div>
<div class="paragraph">
<p>Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все указанные связи от нужной нам сущности. Если надо загрузить дополнительные сущности, находящиеся в связанных сущностях - используется Subgraph.</p>
</div>
<div class="paragraph">
<p>EntityGraph можно определить с помощью аннотации @NamedEntityGraph для Entity, она определяет уникальное имя и список атрибутов ( attributeNodes ), которые должны быть загружены, и используя entityManager из JPA API:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;EntityGraph&lt;Post&gt; entityGraph = entityManager.createEntityGraph(Post.class);&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
entityGraph.addAttributeNodes(""""subject"""");&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
entityGraph.addAttributeNodes(""""user"""");&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
entityGraph.addSubgraph(""""comments"""").addAttributeNodes(""""user"""");&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
 &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>JPA определяет два свойства или подсказки, с помощью которых Hibernate может выбирать стратегию извлечения графа сущностей во время выполнения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>fetchgraph - все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные на LAZY</p>
</li>
<li>
<p>loadgraph - все атрибуты перечисленные в EntityGraph меняют fetchType на EAGER, все остальные сохраняют свой fetchType. С помощью NamedSubgraph можно также изменить fetchType вложенных объектов Entity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Загрузить EntityGraph можем тремя способами:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Используя перегруженный метод find(), который принимает Map с настройками EntityGraph</p>
</li>
<li>
<p>Используя JPQL и передав подсказку через setHint()</p>
</li>
<li>
<p>С помощью Criteria API</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_инверсия_контроля_ioc_и_внедрение_зависимостей_di_как_эти_принципы_реализованы_в_spring">Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Inversion  of Control (IoC)</strong>**</p>
</div>
<div class="paragraph">
<p>Инверсия контроля (инверсия управления) - это принцип в разработке программного обеспечения, при котором управление объектами или частями программы передается контейнеру или фреймворку. Чаще всего этот принцип используется в контексте объектно-ориентированного программирования.</p>
</div>
<div class="paragraph">
<p>В отличие от традиционного программирования, в котором наш пользовательский код обращается напрямую к библиотекам, IoC позволяет фреймворку контролировать ход программы и обращаться к нашему коду, когда это необходимо. Для этого, фреймворки используют абстракции со встроенным дополнительным поведением. Если мы хотим добавить наше собственное поведение, нам нужно расширить классы фреймворка или подключить наши собственные классы.</p>
</div>
<div class="paragraph">
<p>Преимущества этой архитектуры:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>отделение выполнения задачи от ее реализации;</p>
</li>
<li>
<p>легкое переключение между различными реализациями;</p>
</li>
<li>
<p>бо́льшая модульность программы;</p>
</li>
<li>
<p>более легкое тестирование программы путем изоляции компонента или проверки его зависимостей и обеспечения взаимодействия компонентов через контракты.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Инверсия управления может быть достигнута с помощью различных механизмов, таких как: шаблон проектирования “Стратегия”, шаблон “Локатор служб”, шаблон “Фабрика” и внедрение зависимостей (DI).</p>
</div>
<div class="paragraph">
<p><strong>Dependency Injection (DI)</strong></p>
</div>
<div class="paragraph">
<p>Внедрение зависимостей - это шаблон проектирования для реализации IoC, где инвертируемым элементом контроля является зависимостей объекта.</p>
</div>
<div class="paragraph">
<p>Соединение объектов с другими объектами или «внедрение» объектов в другие объекты выполняется контейнером IoC, а не самими объектами.</p>
</div>
<div class="paragraph">
<p>В Spring Framework инверсия контроля достигается именно внедрением зависимостей. В Spring Framework инверсия контроля и внедрение зависимостей считаются одним и тем же.</p>
</div>
<div class="paragraph">
<p>В Spring Framework внедрение зависимостей описывается как процесс, посредством которого объекты определяют свои зависимости (то есть другие объекты, с которыми они работают) только через аргументы конструктора, аргументы фабричного метода или свойства, которые устанавливаются в экземпляре объекта после того, как он создан или возвращен из метода фабрики. После чего контейнер IoC внедряет эти зависимости в компонент при его создании.</p>
</div>
<div class="paragraph">
<p>Внедрение зависимостей в Spring Framework может быть сделано через конструкторы, сеттеры или поля.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_ioc_контейнер">Что такое IoC контейнер?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Spring Framework контейнер отвечает за создание, настройку и сборку объектов, известных как бины, а также за управление их жизненным циклом. Он представлен интерфейсом ApplicationContext.</p>
</div>
<div class="paragraph">
<p>Spring Framework предоставляет несколько реализаций интерфейса ApplicationContext:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ClassPathXmlApplicationContext и FileSystemXmlApplicationContext - для автономных приложений;</p>
</li>
<li>
<p>WebApplicationContext - для веб-приложений;</p>
</li>
<li>
<p>AnnotationConfigApplicationContext - для обычной Java-конфигурации, в качестве аргумента которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Контейнер получает инструкции о том, какие объекты создавать, настраивать и собирать, через метаданные конфигурации, которые представлены в виде XML, Java-аннотаций или Java-кода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XML - Метаданные считываются из файла с расширением *.xml;</p>
</li>
<li>
<p>Java-аннотации - В Spring 2.5 появилась поддержка метаданных конфигурации на основе аннотаций, которая использует данные байт-кода для подключения компонентов. Вместо того, чтобы использовать XML-файл для описания связывания компонентов, разработчик перемещает конфигурацию в сам класс компонента, используя аннотации к соответствующему классу, методу или полю. При этом, сам XML-файл с базовыми настройками остаётся. Контейнер считывает аннотации перед считыванием XML, поэтому, если бин конфигурируется и через аннотации, и через XML-файл, то настройки XML переопределят настройки аннотаций.</p>
</li>
<li>
<p>Java-код - Начиная со Spring 3.0, используя Java-код, а не файлы XML, мы можем определять настройки в специальном классе, помеченном аннотацией @Configuration. Появились аннотации @Configuration, @Bean, @Import и @DependsOn и т.д.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_bean_в_спринге">Что такое Bean в спринге?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Spring объекты, образующие основу приложения и управляемые контейнером Spring IoC, называются бинами. Бин - это объект, который создается, собирается и управляется контейнером Spring IoC. Иначе говоря, бин - это просто один из множества объектов в вашем приложении. Бины и их зависимости отражаются в метаданных конфигурации, используемых контейнером.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_bean">Расскажите про аннотацию @Bean?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это аннотация Spring Framework, она используется над методом для указания того, что данный метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component (или её наследниках).</p>
</div>
<div class="paragraph">
<p>Позволяет дополнительно определить у бина:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name - имя (уникальный идентификатор) бина</p>
</li>
<li>
<p>initMethod - имя метода для вызова во время инициализации бина</p>
</li>
<li>
<p>destroyMethod - имя метода для вызова во время удаления бина из контекста</p>
</li>
<li>
<p>autowireCandidate - является ли этот бин кандидатом на автоматическое внедрение в другой бин.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Классы, аннотированные @Configuration, проксируются через CGLIB.</p>
</div>
<div class="paragraph">
<p>Классы @Component или обычные классы не проксируются и не перехватывают вызовы методов с аннотациями @Bean, что означает, что вызовы не будут маршрутизироваться через контейнер и каждый раз будет возвращаться новый экземпляр бина.</p>
</div>
<div class="paragraph">
<p>Также методы бинов, вызывая друг друга в таких классах, не будут создавать бины, а будет просто выполняться код метода, ведь в данном случае они отработают не через прокси.</p>
</div>
<div class="paragraph">
<p>Имена бинов</p>
</div>
<div class="paragraph">
<p>Имя бина, которое в контейнере является одновременно и его уникальным идентификатором, по умолчанию соответствует имени метода, аннотированного @Bean. Но если требуется указать иное имя, то можно использовать атрибут name, который принимает String. Однако, атрибут name также может принимать массив String, что позволяет использовать несколько имен. Первый элемент массива будет являться именем и уникальным идентификатором бина, а остальные будут его псевдонимами.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_cglib">Что такое CGLIB?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Классы в Java загружаются динамически во время выполнения. Cglib использует эту особенность языка Java, чтобы сделать возможным добавление новых классов в уже запущенную программу Java.</p>
</div>
<div class="paragraph">
<p>Hibernate использует cglib для генерации динамических прокси. Например, он не вернет полный объект, хранящийся в базе данных, но вернет инструментальную версию сохраненного класса, которая лениво загружает значения из базы данных по требованию.</p>
</div>
<div class="paragraph">
<p>Популярные макетные фреймворки, такие как Mockito, используют cglib для макетных методов. Макет - это инструментальный класс, в котором методы заменяются пустыми реализациями.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_component">Расскажите про аннотацию @Component?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это аннотация Spring Framework, ею мы помечаем класс, если хотим, чтобы из этого класса был создан бин. Именно эту аннотацию ищет Spring Framework, когда сканирует наши классы. Можно указать имя (Id) для создаваемого бина, а можно не указывать, тогда по умолчанию именем будет название класса с маленькой буквы.</p>
</div>
<div class="paragraph">
<p>Аннотация @Component имеет наследников: @Repository, @Service и @Controller. Все они являются частными случаями использования @Component для слоёв DAO, сервиса и контроллера MVC соответственно. Также эти аннотации могут иметь дополнительный смысл в будущих версиях Spring Framework. В остальных же случаях достаточно использовать аннотацию @Component.</p>
</div>
<div class="paragraph">
<p>Итог:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@Component - Spring определяет этот класс как кандидата для создания bean.</p>
</li>
<li>
<p>@Service - класс содержит бизнес-логику и вызывает методы на уровне хранилища. Ничем не отличается от классов с @Component.</p>
</li>
<li>
<p>@Repository - указывает, что класс выполняет роль хранилища (объект доступа к DAO).  Задача @Repository заключается в том, чтобы отлавливать определенные исключения пробрасывать их как одно непроверенное исключение Framework. Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть PersistenceExceptionTranslationPostProcessor.</p>
</li>
<li>
<p>@Controller - указывает, что класс выполняет роль контроллера MVC. DispatcherServlet просматривает такие @RequestMapping.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_аннотации_bean_и_component">Чем отличаются аннотации @Bean и @Component?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Аннотация @Component (как и @Service и @Repository) используется для автоматического обнаружения и автоматической настройки бинов в ходе сканирования путей к классам.</p>
</div>
<div class="paragraph">
<p>Аннотация @Bean используется для явного объявления бина, а не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>прописываем вручную метод для создания бина;</p>
</li>
<li>
<p>делает возможным объявление бина независимо объявления класса, что позволяет использовать классы из сторонних библиотек, у которых мы не можем указать аннотацию @Component;</p>
</li>
<li>
<p>с аннотацией @Bean можно настроить initMethod, destroyMethod, autowireCandidate, делая создание бина более гибким.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотации_service_и_repository_чем_они_отличаются">Расскажите про аннотации @Service и @Repository. Чем они отличаются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Service и @Repository являются частными случаями @Component. Технически они одинаковы, но мы используем их для разных целей.</p>
</div>
<div class="paragraph">
<p>Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.</p>
</div>
<div class="paragraph">
<p>Мы помечаем бины аннотацией @Service, чтобы указать, что они содержат бизнес-логику. Так что нет никакого другого предназначения, кроме как использовать ее на уровне сервиса.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_autowired">Расскажите про аннотацию @Autowired</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это аннотация Spring Framework, ею помечают конструктор, поле, сеттер-метод или метод конфигурации, сигнализируя, что им обязательно требуется внедрение зависимостей.</p>
</div>
<div class="paragraph">
<p>Если в контейнере не будет обнаружен необходимый для вставки бин, то будет выброшено исключение, либо можно указать @Autowired(required = false), означающее, что внедрение зависимости в данном месте не обязательно.</p>
</div>
<div class="paragraph">
<p>Аннотация @Autowired является альтернативой Java-аннотации @Inject, не имеющей required = false (зависимость должна быть обязательно внедрена).</p>
</div>
<div class="paragraph">
<p>Начиная со Spring Framework 4.3, аннотация @Autowired для конструктора больше не требуется, если целевой компонент определяет только один конструктор. Однако, если доступно несколько конструкторов и нет основного/стандартного конструктора, по крайней мере один из конструкторов должен быть аннотирован @Autowired, чтобы указать контейнеру, какой из них использовать.</p>
</div>
<div class="paragraph">
<p>По умолчанию Spring распознает объекты для вставки по типу. Если в контейнере доступно более одного бина одного и того же типа, будет исключение. Во избежание этого можно указать аннотацию Spring Framework - @Qualifier(""fooFormatter""), где fooFormatter - это имя (Id) одного из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_resource">Расскажите про аннотацию @Resource</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java-аннотация @Resource может применяться к классам, полям и методам. Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name. При аннотировании классов имя не извлекается из имени класса по умолчанию, поэтому оно должно быть указано явно.</p>
</div>
<div class="paragraph">
<p>Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с данным именем, и в контейнере должен быть бин с таким именем:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Resource(name=""namedFile"")&lt;/u&gt;
&lt;u&gt;private File defaultFile;&lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Если указать ее без аргументов, то Spring Framework поможет найти бин по типу.</p>
</div>
<div class="paragraph">
<p>Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Resource&lt;/u&gt;
&lt;u&gt;@Qualifier(""defaultFile"")&lt;/u&gt;
&lt;u&gt;private File dependency1;&lt;/u&gt;
&lt;u&gt;@Resource&lt;/u&gt;
&lt;u&gt;@Qualifier(""namedFile"")&lt;/u&gt;
&lt;u&gt;private File dependency2;&lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Разница с @Autowired:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ищет бин сначала по имени, а потом по типу</p>
</li>
<li>
<p>не нужна дополнительная аннотация для указания имени конкретного бина</p>
</li>
<li>
<p>@Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false)</p>
</li>
<li>
<p>при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_inject">Расскажите про аннотацию @Inject</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java-аннотация @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;dependency&gt;
&lt;groupId&gt;javax.inject&lt;/groupId&gt;
&lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
&lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Размещается над полями, методами, и конструкторами с аргументами. @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но они одинакового типа, зависимость все равно будет разрешена:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Inject&lt;/u&gt;
&lt;u&gt;private ArbitraryDependency fieldInjectDependency;&lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>отличается от имени компонента, настроенного в контексте приложения:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Bean&lt;/u&gt;
&lt;u&gt;public ArbitraryDependency injectDependency() {&lt;/u&gt;
&lt;u&gt;ArbitraryDependency injectDependency = new ArbitraryDependency();&lt;/u&gt;
&lt;u&gt;return injectDependency;&lt;/u&gt;
&lt;u&gt;}&lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу ArbitraryDependency.</p>
</div>
<div class="paragraph">
<p>Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию @Qualifier:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Inject&lt;/u&gt;
&lt;u&gt;@Qualifier(""defaultFile"")&lt;/u&gt;
&lt;u&gt;private ArbitraryDependency defaultDependency;&lt;/u&gt;
&lt;u&gt;@Inject&lt;/u&gt;
&lt;u&gt;@Qualifier(""namedFile"")&lt;/u&gt;
&lt;u&gt;private ArbitraryDependency namedDependency;&lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>При использовании конкретного имени (Id) бина используем @Named:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@Inject&lt;/u&gt;
&lt;u&gt;@Named(""yetAnotherFieldInjectDependency"")&lt;/u&gt;
&lt;u&gt;private ArbitraryDependency yetAnotherFieldInjectDependency;&lt;/u&gt;&lt;/i&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_lookup">Расскажите про аннотацию @Lookup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.</p>
</div>
<div class="paragraph">
<p>Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean). Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь-то и пригодится внедрение бина с помощью Lookup-метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.</p>
</div>
<div class="paragraph">
<p>Суть в том, что мы создаем метод-заглушку в бине Car и помечаем его специальным образом – аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в нашей заглушке он возвращает (а так и надо делать - всё равно этот метод будет переопределен в прокси-подклассе):</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@Component&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
public class Car {&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
@Lookup&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
public Passenger createPassenger() {&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
return null;&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
}&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
public String drive(String name) {&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
Passenger passenger = createPassenger();&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
passenger.setName(name);&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
return ""car with "" + passenger.getName();&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
}&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Допустим, в бине есть метод drive(), и при каждом вызове метода drive() бину Car требуется новый экземпляр бина Passenger – сегодня пассажир Петя, завтра – Вася. То есть бин Passenger прототипный. Для получения этого бина надо написать метод-заглушку createPassenger() и аннотировать его с помощью @Lookup.</p>
</div>
<div class="paragraph">
<p>Контейнер Spring переопределит этот метод-заглушку и будет выдавать при его вызове каждый раз новый экземпляр Passenger.</p>
</div>
<div class="paragraph">
<p>Осталось только определить бин Passenger как прототипный:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Component
@Scope(""prototype"")
public class Passenger {

private String name;

public String getName() {

return name;

}

public void setName(String name) {

this.name = name;

}

}</pre>
</div>
</div>
<div class="paragraph">
<p>Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передается в аргументе метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_вставить_бин_в_статическое_поле_почему">Можно ли вставить бин в статическое поле? Почему?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring не позволяет внедрять бины напрямую в статические поля, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;i&gt;@Component
public class TestDataInit {
@Autowired
private static OrderItemService orderItemService;
}&lt;/i&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Если вы распечатаете TestDataInit.orderItemService, там будет null. Это связано с тем, что, когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен.</p>
</div>
<div class="paragraph">
<p>Чтобы исправить это, создайте нестатический сеттер-метод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;i&gt;@Component
public class TestDataInit {
private static OrderItemService orderItemService;
@Autowired
public void setOrderItemService(OrderItemService orderItemService) {
TestDataInit.orderItemService = orderItemService;
}
}&lt;/i&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотации_primary_и_qualifier">Расскажите про аннотации @Primary и @Qualifier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Мы используем @Primary, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа. Эта аннотация полезна, когда мы хотим указать, какой компонент определенного типа должен внедряться по умолчанию.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;i&gt;@Configuration
public class Config {
@Bean
public Employee JohnEmployee() {
return new Employee(""John"");
}
@Bean
@Primary
public Employee TonyEmployee() {
return new Employee(""Tony"");
}
}&lt;/i&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>или с аннотацией @Component</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@Component
public class DepartmentManager implements Manager {
@Override
public String getManagerName() {
return ""Department manager"";
}
}
@Component
@Primary
public class GeneralManager implements Manager {
@Override
public String getManagerName() {
return ""General manager"";
}
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Теперь, где будут требоваться бины типа Employee и Manager будут созданы и внедрены TonyEmployee и GeneralManager.</p>
</div>
<div class="paragraph">
<p>Когда есть несколько бинов одного типа, подходящих для внедрения, аннотация @Qualifier позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить.</p>
</div>
<div class="paragraph">
<p>Стоит отметить, что если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет. По сути, @Primary определяет значение по умолчанию, в то время как @Qualifier более специфичен.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_заинжектить_примитив">Как заинжектить примитив?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом.</p>
</div>
<div class="paragraph">
<p>Такие значения можно получать из property файлов, из бинов, и т.п.</p>
</div>
<div class="paragraph">
<p>@Value(""""${some.key}"""")</p>
</div>
<div class="paragraph">
<p>public String stringWithDefaultValue;</p>
</div>
<div class="paragraph">
<p>В эту переменную будет внедрена строка, например из property или из view.</p>
</div>
<div class="paragraph">
<p>Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_заинжектить_коллекцию">Как заинжектить коллекцию?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных).</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@Autowired&lt;/i&gt;
&lt;i&gt;List&lt;Employee&gt; employees // создастья лист с бином эмлои если он у нас есть &lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>В случае с map ключом будет имя бина.</p>
</div>
<div class="paragraph">
<p>Используя аннотацию @Qualifier можно настроить тип искомого бина.</p>
</div>
<div class="paragraph">
<p>Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.</p>
</div>
<div class="paragraph">
<p>Метод который возвращает коллекцию с аннотацией @Bean</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_conditional">Расскажите про аннотацию @Conditional</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;a href=""https://www.baeldung.com/spring-conditional-annotations""&gt;https://www.baeldung.com/spring-conditional-annotations&lt;/a&gt; - подробно</p>
</div>
<div class="paragraph">
<p>Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;matches(ConditionContext var1, AnnotatedTypeMetadata var2) - &lt;/i&gt;возвращающий boolean.</p>
</div>
<div class="paragraph">
<p>Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.</p>
</div>
<div class="paragraph">
<p>Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.</p>
</div>
<div class="paragraph">
<p>Условия проверяются непосредственно перед тем, как должен быть зарегистрирован BeanDefinition компонента, и они могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы взаимодействовали с бинами, которых еще не существует, с их BeanDefinition-ами можно.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями:</p>
</div>
<div class="paragraph">
<p>@Conditional(HibernateCondition.class, OurConditionClass.class)</p>
</div>
<div class="paragraph">
<p>Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.</p>
</div>
<div class="paragraph">
<p>Для более детальной настройки классов, аннотированных @Configuration, предлагается использовать интерфейс ConfigurationCondition.</p>
</div>
<div class="paragraph">
<p>В одном классе - одно условие. Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.</p>
</div>
<div class="paragraph">
<p>В Spring Framework имеется множество готовых аннотаций (и связанных с ними склассами-условиями, имплементирующими интерфейс Condition), которые можно применять совместно над одним определением бина:</p>
</div>
<div class="paragraph">
<p>&lt;img src=""paste-76100e152911bdf394b166343f288c1d048cf8b8.png""&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_profile">Расскажите про аннотацию @Profile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod.</p>
</div>
<div class="paragraph">
<p>Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны.</p>
</div>
<div class="paragraph">
<p>Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional.</p>
</div>
<div class="paragraph">
<p>Ее можно ставить на @Configuration и Component классы.</p>
</div>
<div class="paragraph">
<p>В качестве быстрого обозначения имена профилей также могут начинаться с оператора NOT, например «!dev», чтобы исключить их из профиля.</p>
</div>
<div class="paragraph">
<p>По умолчанию, если профиль бина не определен, то он относится к профилю “default”. Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя свойство «spring.profiles.default».</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_applicationcontext_и_beanfactory_чем_отличаются_в_каких_случаях_что_стоит_использовать">Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;a href=""https://www.baeldung.com/spring-beanfactory-vs-applicationcontext""&gt;https://www.baeldung.com/spring-beanfactory-vs-applicationcontext&lt;/a&gt; - подробнее</p>
</div>
<div class="paragraph">
<p>BeanFactory</p>
</div>
<div class="paragraph">
<p>BeanFactory - это самая базовая версия IOC контейнера.</p>
</div>
<div class="paragraph">
<p>ApplicationContext</p>
</div>
<div class="paragraph">
<p>ApplicationContext - это наследник BeanFactory и он расширяет возможности BeanFactory.</p>
</div>
<div class="paragraph">
<p>ApplicationContext vs. BeanFactory&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию.</p>
</li>
<li>
<p>ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят для корпоративных приложений:&lt;/li&gt;</p>
</li>
<li>
<p>поддержка  внедрения зависимостей на основе аннотаций;</p>
</li>
<li>
<p>удобный  доступ к MessageSource (для использования в интернационализации);</p>
</li>
<li>
<p>публикация  ApplicationEvent - для бинов, реализующих интерфейс ApplicationListener,  с помощью ApplicationEventPublisher;</p>
</li>
<li>
<p>простая  интеграция с функциями Spring AOP.
&lt;li&gt;ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и BeanFactoryPostProcessor. Поэтому всегда желательно использовать ApplicationContext, потому что Spring 2 (и выше) интенсивно использует BeanPostProcessor.</p>
</li>
<li>
<p>ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory поддерживает только два - Singleton и Prototype.</p>
</li>
<li>
<p>В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к путанице, потому что конфигурация с виду будет корректной.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_жизненный_цикл_бина_аннотации_postconstruct_и_predestroy">Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;a href=""https://stackoverflow.com/questions/30455536/beanfactorypostprocessor-and-beanpostprocessor-in-lifecycle-events""&gt;https://stackoverflow.com/questions/30455536/beanfactorypostprocessor-and-beanpostprocessor-in-lifecycle-events&lt;/a&gt; - про beanFPP/beanPP</p>
</div>
<div class="paragraph">
<p>&lt;a href=""https://habr.com/ru/post/222579/""&gt;https://habr.com/ru/post/222579/&lt;/a&gt; - подробно и хорошо объяснено</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;BeanDefinition&lt;/i&gt; — это специальный интерфейс, через который можно получить доступ к метаданным будущего бина. В зависимости от того, какая у вас конфигурация, будет использоваться тот или иной механизм парсирования конфигурации.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Загрузка BeanDefenition (описание бинов), создание графа зависимостей(между бинами)</p>
</li>
<li>
<p>Создание и запуск BeanFactoryPostProcessors</p>
</li>
<li>
<p>Создание бинов</p>
</li>
<li>
<p>Spring внедряет значения и зависимости в свойства бина</p>
</li>
<li>
<p>Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод</p>
</li>
<li>
<p>Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через setBeanFactory() из этого интерфейса.</p>
</li>
<li>
<p>Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через setApplicationContext().</p>
</li>
<li>
<p>BeanPostProcessor это специальный интерфейс(о нем ниже), и Spring позволяет бинам имплементировать этот интерфейс. Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией(установка свойств и т.п.)</p>
</li>
<li>
<p>Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный @PostConstruct или метод initMethod из аннотации @Bean.</p>
</li>
<li>
<p>Теперь бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().</p>
</li>
<li>
<p>После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.</p>
</li>
<li>
<p>Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод. Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy(), чтобы очистить ресурсы или убить процессы в приложении. Если в аннотации @Bean определен метод destroyMethod, то вызовется и он.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;img src=""paste-28f62fb27ca70ec2486f4d93e133965cff2db513.png""&gt;</p>
</div>
<div class="paragraph">
<p>&lt;img src=""paste-f712ac186b1df05dfab31686bcd71319315d194b.png""&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_скоупы_бинов_какой_скоуп_используется_по_умолчанию_что_изменилось_в_пятом_спринге">Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в пятом спринге?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework поддерживает шесть scopes:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>singleton</p>
</li>
<li>
<p>prototype</p>
</li>
<li>
<p>request</p>
</li>
<li>
<p>session</p>
</li>
<li>
<p>application</p>
</li>
<li>
<p>websocket</p>
</li>
<li>
<p>не активированный по умолчанию Custom thread scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>С 3 по 6 доступны только в веб-приложениях. Мы также можем создать свой собственный scope.</p>
</div>
<div class="paragraph">
<p>Singleton</p>
</div>
<div class="paragraph">
<p>Является дефолтным scope. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин. Этот бин хранится в контейнере, и все запросы и ссылки на этот бин возвращают закэшированный экземпляр.</p>
</div>
<div class="paragraph">
<p>Prototype</p>
</div>
<div class="paragraph">
<p>Scope “prototype” приводит к созданию нового бина каждый раз, когда он запрашивается.</p>
</div>
<div class="paragraph">
<p>Для бинов со scope “prototype” Spring не вызывает метод destroy(). Spring не берет на себя контроль полного жизненного цикла бина со scope @prototype”. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).</p>
</div>
<div class="paragraph">
<p>И 4 области видимости в веб-приложении.</p>
</div>
<div class="paragraph">
<p>Request - Область видимости — 1 HTTP запрос. Контейнер создает новый экземпляр для каждого HTTP-запроса. Любое изменение состояния одного  кземпляра не будет видимодругим экземплярам. Эти экземпляры уничтожаются, как только HTTP-запрос завершен.</p>
</div>
<div class="paragraph">
<p>@Scope(""request"")</p>
</div>
<div class="paragraph">
<p>@RequestScope</p>
</div>
<div class="paragraph">
<p>Session - Область видимости — 1 сессия. На каждую сессию создается новый бин. Бин создается в одном экземпляре для одной HTTP-сессии. Все HTTP-запросы в пределах времени жизни одной сессии будут иметь доступ к одному и тому же бину.</p>
</div>
<div class="paragraph">
<p>@Scope(""session"")</p>
</div>
<div class="paragraph">
<p>@SessionScope</p>
</div>
<div class="paragraph">
<p>Application - Область видимости — жизненный цикл ServletContext</p>
</div>
<div class="paragraph">
<p>Бин со scope “application” создается в одном экземпляре для жизненного цикла ServletContext. Виден как атрибут ServletContext. Синглтон - в одном экземпляре для ApplicationContext.</p>
</div>
<div class="paragraph">
<p>@Scope(""application"")</p>
</div>
<div class="paragraph">
<p>@ApplicationScope</p>
</div>
<div class="paragraph">
<p>WebSocket - Область видимости — жизненный цикл WebSocket</p>
</div>
<div class="paragraph">
<p>Бин со scope “websocket” создается в одном экземпляре для определенного сеанса WebSocket. Один и тот же бин возвращается всякий раз, когда к нему обращаются в течение всего сеанса WebSocket.</p>
</div>
<div class="paragraph">
<p>@Scope(""websocket"")</p>
</div>
<div class="paragraph">
<p>В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотацию_componentscan">Расскажите про аннотацию @ComponentScan</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.</p>
</div>
<div class="paragraph">
<p>@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты. Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>бин конфигурационного класса;</p>
</li>
<li>
<p>бины, объявленные в конфигурационном классе с помощью @Bean;</p>
</li>
<li>
<p>все бины из пакета и его подпакетов.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если указать @ComponentScan с атрибутом basePackages, то это изменит пакет по умолчанию на указанный:</p>
</div>
<div class="paragraph">
<p>Если указать @ComponentScan с атрибутом excludeFilters, то это позволит использовать фильтр и исключить ненужные классы из процесса сканирования:</p>
</div>
<div class="paragraph">
<p>@ComponentScan(excludeFilters =</p>
</div>
<div class="paragraph">
<p>@ComponentScan.Filter(type=FilterType.REGEX,</p>
</div>
<div class="paragraph">
<p>pattern=""com\\.baeldung\\.componentscan\\.springapp\\.flowers\\..*""))</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_спринг_работает_с_транзакциями_расскажите_про_аннотацию_transactional">Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>marcobehler.com/guides/spring-transaction-management-transactional-in-depth</p>
</div>
<div class="paragraph">
<p>Коротко: Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее: proxy, который создал Spring, создаёт persistence context (или соединение с базой), открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal). По мере надобности всё сохранённое достаётся и внедряется в бины. Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.</p>
</div>
<div class="paragraph">
<p>Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional? Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода. То есть у них будет ОДНА транзакция.</p>
</div>
<div class="paragraph">
<p>Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional? Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода. То есть транзакция запущена НЕ БУДЕТ.</p>
</div>
<div class="paragraph">
<p>Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода? Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить.</p>
</div>
<div class="paragraph">
<p>Значения атрибута propagation у аннотации:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>REQUIRED - транзакция требуется, сгодится уже открытая, если есть, или новая</p>
</li>
<li>
<p>SUPPORTS - если транзакция открыта, она будет использована, если нет, метод исполнится нетранзакционно (метод не будет проксирован)</p>
</li>
<li>
<p>MANDATORY - обязательно наличие открытой транзакции, если её нету, будет выброшено исключение</p>
</li>
<li>
<p>REQUIRED_NEW - останавливает текущую транзакцию и исполняет метод в новой транзакции</p>
</li>
<li>
<p>NOT_SUPPORTED - останавливает текущую транзакцию и исполняет метод нетранзакционно</p>
</li>
<li>
<p>NEVER - транзакции не должно быть</p>
</li>
<li>
<p>NESTED - обращает к savepoint если какая-то непредвиденная ситуация</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_аннотации_controller_и_restcontroller_чем_они_отличаются_как_вернуть_ответ_со_своим_статусом_например_213">Расскажите про аннотации @Controller и @RestController. Чем они отличаются? Как вернуть ответ со своим статусом (например 213)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>@Controller</p>
</div>
<div class="paragraph">
<p>@Controller помечает класс как контроллер HTTP-запросов. @Controller обычно используется в сочетании с аннотацией используемой в методах обработки запросов. Это просто дочерняя аннотация аннотации @Component и позволяет автоматически определять классы при сканировании пакетов.</p>
</div>
<div class="paragraph">
<p>@RestController</p>
</div>
<div class="paragraph">
<p>Аннотация @RestController была введена в Spring 4 для упрощения создания RESTful веб-сервисов. Это удобная аннотация, которая объединяет @Controller и @ResponseBody, что устраняет необходимость аннотировать каждый метод обработки запросов аннотацией @ResponseBody.</p>
</div>
<div class="paragraph">
<p>@ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется в json или xml и передается обратно в объект HttpResponse. Контроллер использует Jackson message конвертации входящих/исходящих данных. Как правило целевые данные представлены в json или xml.</p>
</div>
<div class="paragraph">
<p>ResponseEntity</p>
</div>
<div class="paragraph">
<p>Данный класс используется для формирования ответа пользовательскими параметрами (заголовки, код статуса и тело ответа). ResponseEntity необходим, только если мы хотим кастомизировать ответ. Во всех остальных случаях достаточно использовать @ResponseBody.</p>
</div>
<div class="paragraph">
<p>Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_viewresolver">Что такое ViewResolver?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Model</p>
</div>
<div class="paragraph">
<p>Интерфейс, лежит в пакете spring-context. В методах контроллера мы можем использовать объекты Model для того, чтобы складывать туда данные, предназначенные для формирования представлений. Кроме того, в Model мы можем передать даже Map с атрибутами.</p>
</div>
<div class="paragraph">
<p>ModelMap</p>
</div>
<div class="paragraph">
<p>Этот класс наследуется от LinkedHashMap&lt;String, Object&gt; и по сути служит общим контейнером модели для Servlet MVC, но не привязан к нему, и лежит в пакете spring-context. Имеет все преимущества LinkedHashMap плюс несколько удобных методов.</p>
</div>
<div class="paragraph">
<p>ModelAndView</p>
</div>
<div class="paragraph">
<p>Этот класс лежит в пакете spring-webmvc и может одновременно хранить модели и представление, чтобы контроллер мог отдавать их в одном возвращаемом значении. Внутри содержит поле private Object view, куда записывает нужное представление, а также поле private ModelMap model, куда и складывает все атрибуты модели.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_паттерн_mvc_как_он_реализован_в_spring">Расскажите про паттерн MVC, как он реализован в Spring?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MVC (Model-View-Controller)</p>
</div>
<div class="paragraph">
<p>Это шаблон проектирования программного обеспечения, который делит программную логику на три отдельных, но взаимосвязанных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние. Она содержит всю бизнес-логику приложения.</p>
</li>
<li>
<p>Представление (View) отвечает за отображение пользователю данных из модели в нужном формате.</p>
</li>
<li>
<p>Контроллер (Controller) содержит код, который отвечает за обработку действий пользователя и обменивается данными с моделью (любое действие пользователя в системе обрабатывается в контроллере).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Основная цель следования принципам MVC — отделить реализацию бизнес-логики приложения (модели) от ее визуализации (вида). Такое разделение повысит возможность повторного использования кода.</p>
</div>
<div class="paragraph">
<p>Польза применения MVC наиболее наглядна в случаях, когда пользователю нужно предоставлять одни и те же данные в разных формах. Например, в виде таблицы, графика или диаграммы (используя различные виды). При этом, не затрагивая реализацию видов, можно изменить реакции на действия пользователя (нажатие мышью на кнопке, ввод данных).</p>
</div>
<div class="paragraph">
<p>Spring Web MVC</p>
</div>
<div class="paragraph">
<p>Spring MVC - это оригинальный веб-фреймворк, основанный на Servlet API, предназначенный для создания веб-приложений на языке Java, с использованием двух самых популярных шаблонов проектирования - Front controller и MVC.</p>
</div>
<div class="paragraph">
<p>Front controller (Единая точка входа) - паттерн, где центральный сервлет, DispatcherServlet, принимает все запросы и распределяет их между контроллерами, обрабатывающими разные URL.</p>
</div>
<div class="paragraph">
<p>Spring MVC реализует четкое разделение задач, что позволяет нам легко разрабатывать и тестировать наши приложения. Данные задачи разбит между разными компонентами: Dispatcher Servlet, Controllers, View Resolvers, Views, Models, ModelAndView, Model and Session Attributes, которые полностью независимы друг от друга, и отвечают только за одно направление. Поэтому MVC дает нам довольно большую гибкость. Он основан на интерфейсах (с предоставленными классами реализации), и мы можем настраивать каждую часть фреймворка с помощью пользовательских интерфейсов.</p>
</div>
<div class="paragraph">
<p>Основные интерфейсы для обработки запросов:</p>
</div>
<div class="paragraph">
<p>HandlerMapping. По запросу определяет, какие перехватчики (interceptors) с пре- и пост-процессорной обработкой запроса должны отработать, а затем решает, какому контроллеру (обработчику) нужно передать данный запрос на исполнение. Процесс их определения основан на некоторых критериях, детали которых зависят от реализации HandlerMapping.</p>
</div>
<div class="paragraph">
<p>Двумя основными реализациями HandlerMapping являются RequestMappingHandlerMapping (который поддерживает аннотированные методы @RequestMapping) и SimpleUrlHandlerMapping (который поддерживает явную регистрацию путей URI для обработчиков).</p>
</div>
<div class="paragraph">
<p>HandlerAdapter. Помогает DispatcherServlet вызвать обработчик, сопоставленный с запросом. Для вызова аннотированного контроллера необходимо прочитать аннотации над методами контроллера и принять решение. Основная цель HandlerAdapter - избавить DispatcherServlet от этой рутины.</p>
</div>
<div class="paragraph">
<p>ViewResolver. Сопоставляет имена представлений, возвращаемых методами контроллеров, с фактическими представлениями (html-файлами).</p>
</div>
<div class="paragraph">
<p>View. Отвечает за возвращение ответа клиенту в виде текстов и изображений. Используются встраиваемые шаблонизаторы (Thymeleaf, FreeMarker и т.д.), так как у Spring нет родных. Некоторые запросы могут идти прямо во View, не заходя в Model, другие проходят через все слои.</p>
</div>
<div class="paragraph">
<p>LocaleResolver. Определение часового пояса и языка клиента для того, чтобы предложить представления на его языке.</p>
</div>
<div class="paragraph">
<p>MultipartResolver. Обеспечивает Upload — загрузку на сервер локальных файлов клиента. По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации. После настройки любой запрос о загрузке будет отправляться этому интерфейсу.</p>
</div>
<div class="paragraph">
<p>FlashMapManager. Сохраняет и извлекает «входной» и «выходной» FlashMap, который можно использовать для передачи атрибутов из одного запроса в другой, обычно через редирект.</p>
</div>
<div class="paragraph">
<p>&lt;img src=""clip_image002-bd34790f3b2fe74f73f0b55a545d3591ee5f7762.gif""&gt;</p>
</div>
<div class="paragraph">
<p>Ниже приведена последовательность событий, соответствующая входящему HTTP-запросу:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой Контроллер (Controller) должен быть вызван, после чего HandlerAdapter, отправляет запрос в нужный метод Контроллера.</p>
</li>
<li>
<p>Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET, POST и т.д. Вызванный метод формирует данные Модели</p>
</li>
<li>
<p>(например, набор данных из БД) и возвращает их в DispatcherServlet вместе с именем Представления (View) (как правило имя html-файла).</p>
</li>
<li>
<p>При помощи интерфейса ViewResolver DispatcherServlet определяет, какое Представление нужно использовать на основании полученного имени и получает в ответе имя представления View.</p>
</li>
<li>
<p>если это REST-запрос на сырые данные (JSON/XML), то DispatcherServlet сам его отправляет;</p>
</li>
<li>
<p>если обычный запрос, то DispatcherServlet отправляет данные Модели в виде атрибутов в Представление (View) - шаблонизаторы Thymeleaf, FreeMarker и т.д., которые сами отправляют ответ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Как мы видим все действия происходят через один единственный DispatcherServlet.</p>
</div>
<div class="paragraph">
<p>Сконфигурировать наше Spring MVC-приложение мы можем с помощью Java-config, добавив зависимость spring-webmvc и установив над классом конфигурации @EnableWebMvc, которая применит дефолтные настройки - зарегистрирует некоторые специальные бины из Spring MVC и адаптирует их к нашим бинам. Но, если требуется тонкая настройка, то мы можем имплементировать интерфейс необходимые методы.</p>
</div>
<div class="paragraph">
<p>Теперь нужно зарегистрировать конфигурацию в Spring Context это позволит сделать созданный нами класс MyWebAppInitializer, который нужно унаследовать от AbstractAnnotationConfigDispatcherServletInitializer, и передать в его методы классы нашей конфигурации RootConfig.class и App1Config.class:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer
@Override
protected Class&lt;?&gt;[] getRootConfigClasses() {
return new Class&lt;?&gt;[] { RootConfig.class };
}
@Override
protected Class&lt;?&gt;[] getServletConfigClasses() { &lt;/i&gt;&lt;i&gt;return new Class&lt;?&gt;[] { App1Config.class };
}
@Override
protected String[] getServletMappings() {
return new String[] { ""/*"" };
}
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Своими внутренними методами он создает два экземпляра WebApplicationContext в виде объектов класса AnnotationConfigWebApplicationContext.</p>
</div>
<div class="paragraph">
<p>Если же у нас только один класс конфигурации, то его нужно передать в метод getRootConfigClasses(), а getServletConfigClasses() должен возвращать null.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_паттерн_front_controller_как_он_реализован_в_spring">Расскажите про паттерн Front Controller, как он реализован в Spring?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Паттерн Front Controller обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним фрагментом кода, который затем может делегировать ответственность за обработку запроса другим объектам приложения. Он также обеспечивает интерфейс для общего поведения, такого как безопасность, интернационализация и передача определенных представлений определенным пользователям.</p>
</div>
<div class="paragraph">
<p>В Spring в качестве Front Controller выступает DispatcherServlet, все действия проходят через него. Как правило в приложении задаётся только один DispatcherServlet с маппингом “/”, который перехватывает все запросы. Это и есть реализация паттерна Front Controller.</p>
</div>
<div class="paragraph">
<p>Однако иногда необходимо определить два и более DispatcherServlet-а, которые будут отвечать за свой собственный функционал. Например, чтобы один обрабатывал REST-запросы с маппингом “/api”, а другой обычные запросы с маппингом “/default”. Spring предоставляет нам такую возможность, начала нужно понять, что:</p>
</div>
<div class="paragraph">
<p>Spring может иметь несколько контекстов одновременно. Одним из них будет корневой контекст, а все остальные контексты будут дочерними.</p>
</div>
<div class="paragraph">
<p>Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот. Корневой контекст не может получить доступ к бинам дочерних контекстов.</p>
</div>
<div class="paragraph">
<p>Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста. Каждый DispatcherServlet имеет свой дочерний контекст приложения. DispatcherServlet по сути является сервлетом (он расширяет HttpServlet), основной целью которого является обработка входящих веб-запросов, соответствующих настроенному шаблону URL. Он принимает входящий URI и находит правильную комбинацию контроллера и вида. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext (на рисунке - Servlet WebApplicationContext) с вьюшками, контроллерами и т.д. Например, когда нам нужно в одном Servlet WebApplicationContext определить обычные контроллеры, а в другом REST - контроллеры.</p>
</div>
<div class="paragraph">
<p>&lt;img alt=""HTTP запросы не делегируются контроллерам корневого WebApplicationContext -  CodeRoad"" src=""clip_image002-0cf1bc96e920e70891b366e362c235bb98faf51d.gif""&gt;</p>
</div>
<div class="paragraph">
<p>WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у.</p>
</div>
<div class="paragraph">
<p>ContextLoaderListener создает корневой контекст приложения (на рисунке - Root WebApplicationContext) и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet. Напомню, что корневой контекст приложения будет общим и может быть только один. Root WebApplicationContext содержит компоненты, которые видны всем дочерним контекстам, такие как сервисы, репозитории, компоненты инфраструктуры и т.д. После создания корневого контекста приложения он сохраняется в ServletContext как атрибут, имя которого:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;WebApplicationContext.class.getName() + "".ROOT"" &lt;/u&gt;&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Чтобы из контроллера любого дочернего контекста обратиться к корневому контексту приложения, мы можем использовать класс WebApplicationContextUtils, содержащий статические методы:</p>
</div>
<div class="paragraph">
<p>@Autowired</p>
</div>
<div class="paragraph">
<p>ServletContext context;</p>
</div>
<div class="paragraph">
<p>ApplicationContext ac =WebApplicationContextUtils.getWebApplicationContext(context);</p>
</div>
<div class="paragraph">
<p>if(ac == null){</p>
</div>
<div class="paragraph">
<p>return ""root application context is null"";</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>ContextLoaderListener vs DispatcherServlet&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ContextLoaderListener создает корневой контекст приложения.</p>
</li>
<li>
<p>Каждый DispatcherServlet создаёт себе один дочерний контекст.</p>
</li>
<li>
<p>Дочерние контексты могут обращаться к бинам, определенным в корневом контексте.</p>
</li>
<li>
<p>Бины в корневом контексте не могут получить доступ к бинам в дочерних контекстах (напрямую).</p>
</li>
<li>
<p>Все контексты добавляются в ServletContext.</p>
</li>
<li>
<p>Мы можем получить доступ к корневому контексту, используя класс WebApplicationContextUtils.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;img alt=""ContextLoaderListener vs DispatcherServlet"" src=""clip_image004.jpg""&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_аоп_как_реализовано_в_спринге">Что такое АОП? Как реализовано в спринге?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>&lt;a href=""https://habr.com/ru/post/428548/""&gt;https://habr.com/ru/post/428548/&lt;/a&gt; - подробно</p>
</div>
<div class="paragraph">
<p>Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является повышение  модульности за счет разделения междисциплинарных задач. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.</p>
</div>
<div class="paragraph">
<p>АОП предоставляет возможность реализации в одном месте сквозной логики - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению.</p>
</div>
<div class="paragraph">
<p>Подход Spring к АОП заключается в создании ""динамических прокси"" для целевых объектов и ""привязывании"" объектов к конфигурированному совету для выполнения сквозной логики.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_concurrent_collections">Расскажите про Concurrent Collections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"&lt;img src=""Java 8 ConcurrentCollections.png"" width=""872"" data-editor-shrink=""true""&gt;</p>
</div>
<div class="paragraph">
<p>Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wail-free алгоритмам.</p>
</div>
<div class="paragraph">
<p>Коллекции:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>BlockingQueue</strong>- При обработке больших потоков данных через очереди становится явно недостаточно использования ConcurrentLinkedQueue. Если потоки, разгребающие очередь перестанут справляться с наплывом данных, то можно довольно быстро схлопотать out of memory или перегрузить IO/Net настолько, что производительность упадет в разы пока не настанет отказ системы по таймаутам или из за отсутствия свободных дескрипторов в системе. Для таких случаев нужна queue с возможностью задать размер очереди или с блокировками по условиям. Тут то и появляется интерфейс BlockingQueue, открывающий дорогу к целому набору полезных классов. Помимо возможности задавать размер queue, добавились новые методы, которые реагируют по-разному на незаполнение или переполнение queue. Так, например, при добавлении элемента в переполненную queue, один метод кинет IllegalStateException, другой вернет false, третий заблокирует поток, пока не появится место, четвертый же заблокирует поток с таймаутом и вернет false, если место так и не появится. Также стоит отметить, что блокирующие очереди не поддерживают null значения, т.к. это значение используется в методе poll как индикатор таймаута.</p>
</li>
<li>
<p><strong>ArrayBlockingQueue</strong>- Класс блокирующей очереди, построенный на классическом кольцевом буфере. Помимо размера очереди, доступна возможность управлять «честностью» блокировок. Если fair=false (по умолчанию), то очередность работы потоков не гарантируется. Более подробно о «честности» можно посмотреть в описании ReentrantLock&#8217;a.</p>
</li>
<li>
<p><strong>LinkedBlockingQueue</strong>- Блокирующая очередь на связанных нодах, реализованная на «two lock queue» алгоритме: один лок на добавление, другой на вытаскивание элемента. За счет двух локов, по сравнению с ArrayBlockingQueue, данный класс показывает более высокую производительность, но и расход памяти у него выше. Размер очереди задается через конструктор и по умолчанию равен Integer.MAX_VALUE.</p>
</li>
<li>
<p><strong>ConcurrentLinkedQueue</strong>- в имплементации используется wait-free алгоритм от Michael &amp; Scott, адаптированный для работы с garbage collector&#8217;ом. Этот алгоритм довольно эффективен и, что самое важное, очень быстр, т.к. построен на CAS. Метод size() может работать долго, т.ч. лучше постоянно его не дергать.</p>
</li>
<li>
<p>*ConcurrentLinkedDeque *- Deque расшифровывается как Double ended queue и читается как «Deck». Это означает, что данные можно добавлять и вытаскивать с обоих сторон. Соответственно, класс поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out). На практике, ConcurrentLinkedDeque стоит использовать только, если обязательно нужно LIFO, т.к. за счет двунаправленности нод данный класс проигрывает по производительности на 40% по сравнению с ConcurrentLinkedQueue.</p>
</li>
<li>
<p>*CopyOnWrightArrayList *- потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом.</p>
</li>
<li>
<p>*CopyOnWriteArraySet&lt;E&gt; *- имплементация Set, использующая за основу CopyOnWriteArrayList. В отличии от CopyOnWriteArrayList, дополнительных методов нет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Название говорит само за себя. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Тем самым гарантируется, что при проходе итератором по коллекции не кинется ConcurrentModificationException. Следует помнить, что при копировании массива копируются только референсы (ссылки) на объекты (shallow copy), т.ч. доступ к полям элементов не thread-safe. CopyOnWrite коллекции удобно использовать, когда write операции довольно редки, например при реализации механизма подписки listeners и прохода по ним.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*ConcurrentMap *- интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.</p>
</li>
<li>
<p>*ConcurrentHashMap *- в отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash&#8217;ам ключей. В результате, для доступ к данным лочится по сегментам, а не по одному объекту. В дополнение, итераторы представляют данные на определенный срез времени и не кидают ConcurrentModificationException.</p>
</li>
<li>
<p>*ConcurrentNavigableMap *- расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений. Все итераторы декларируются как безопасные к использованию и не кидают ConcurrentModificationException.</p>
</li>
<li>
<p>*ConcurrentSkipListMap *- является аналогом TreeMap с поддержкой многопоточности. Данные также сортируются по ключу и гарантируется усредненная производительность log(N) для containsKey, get, put, remove и других похожих операций.</p>
</li>
<li>
<p>*ConcurrentSkipListSet *- имплементация Set интерфейса, выполненная на основе ConcurrentSkipListMap.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_ключевое_слово_synchronized_плохое_решение">Почему ключевое слово synchronized плохое решение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Потому что многопоточность сводится к однопотоку, нет параллельного выполнения кода, все потоки ждут друг друга. Это обеспечивает безопасность, но код все равно как буд-то выполняется в одном потоке.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_канкаренси_java_utill_concurrent">Что такое канкаренси (java.utill.concurrent)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Concurrency</strong> – это библиотека классов в Java, в которой собрали специальные классы, оптимизированные для работы из нескольких нитей. Эти классы собраны в пакете <code>java.util.concurrent</code>. Их можно схематично поделить по функциональному признаку следующим образом:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Concurrent Collections</strong> — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из <code>java.util</code> пакета. Вместо базового враппера <code>Collections.synchronizedList</code> с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.</p>
</li>
<li>
<p><strong>Queues</strong> — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.</p>
</li>
<li>
<p><strong>Synchronizers</strong> — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.</p>
</li>
<li>
<p><strong>Executors</strong> — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.</p>
</li>
<li>
<p><strong>Locks</strong> — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми <code>synchronized</code>, <code>wait</code>, <code>notify</code>, <code>notifyAll</code>.</p>
</li>
<li>
<p><strong>Atomics</strong> — классы с поддержкой атомарных операций над примитивами и ссылками.</p>
<div class="literalblock">
<div class="content">
<pre>&lt;img src=""ff8e9d719402e1b164febae3fd8c0ff5.png""&gt;</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_классы_из_канкаренси_java_utill_concurrent_ты_знаешь">Какие классы из «канкаренси» (java.utill.concurrent) ты знаешь?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>ConcurrentHashMap&lt;K, V&gt;</strong> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash&#8217;ам ключей. В результате, для доступа к данным лочится по сегментам, а не по одному объекту. В дополнение, итераторы представляют данные на определенный срез времени и не кидают ConcurrentModificationException.</p>
</div>
<div class="paragraph">
<p><strong>AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray</strong> — Что если в классе нужно синхронизировать доступ к одной простой переменной типа int? Можно использовать конструкции с synchronized, а при использовании атомарных операций set/get, подойдет также и volatile. Но можно поступить еще лучше, использовав новые классы Atomic*. За счет использования CAS, операции с этими классами работают быстрее, чем если синхронизироваться через synchronized/volatile. Плюс существуют методы для атомарного добавления на заданную величину, а также инкремент/декремент.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроен_класс_concurrenthashmap">Как устроен класс ConcurrentHashMap?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>&lt;div style=""display: inline !important;""&gt;В отличие от элементов <code>HashMap</code>, <code>Entry</code> в <code>ConcurrentHashMap</code> объявлены как <code>volatile</code>. Это важная особенность, также связанная с изменениями в JMM.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/div&gt;
*  <strong>Хэш-функция</strong></p>
</div>
<div class="paragraph">
<p>В чём необходимость усложнения хэш-функции? Таблицы в хэш-карте имеют длину, определяемую степенью двойки. Для хэш-кодов, двоичные представления которых не различаются в младшей и старшей позиции, мы будем иметь коллизии. Усложнение хэш-функции как раз решает данную проблему, уменьшая вероятность коллизий в карте.</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;
*  <strong>Сегменты</strong></p>
</div>
<div class="paragraph">
<p>Карта делится на N различных сегментов (16 по умолчанию, максимальное значение может быть 16-битным и представлять собой степень двойки). Каждый сегмент представляет собой потокобезопасную таблицу элементов карты. Увеличение количества сегментов будет способствовать тому, что операции модификации будут затрагивать различные сегменты, что уменьшит вероятность блокировок во время выполнения.</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;
*  <strong>ConcurrencyLevel</strong></p>
</div>
<div class="paragraph">
<p>Данный параметр влияет на использование картой памяти и количество сегментов в карте.</p>
</div>
<div class="paragraph">
<p>Количество сегментов будет выбрано как ближайшая степень двойки, большая чем concurrencyLevel. Занижение concurrencyLevel ведёт к тому, что более вероятны блокировки потоками сегментов карты при записи. Завышение показателя ведёт к неэффективному использованию памяти. Если лишь один поток будет изменять карту, а остальные будут производить чтение — рекомендуется использовать значение 1.</p>
</div>
<div class="paragraph">
<p>&lt;/div&gt;
*  <strong>Итого</strong></p>
</div>
<div class="paragraph">
<p>Итак, основные преимущества и особенности реализации <code>ConcurrentHashMap</code>:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Карта имеет схожий с <code>hashmap</code> интерфейс взаимодействия</p>
</li>
<li>
<p>Операции чтения не требуют блокировок и выполняются параллельно</p>
</li>
<li>
<p>Операции записи зачастую также могут выполняться параллельно без блокировок</p>
</li>
<li>
<p>При создании указывается требуемый <code>concurrencyLevel</code>, определяемый по статистике чтения и записи</p>
</li>
<li>
<p>Элементы карты имеют значение <code>value</code>, объявленное как <code>volatile</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_mutex">Что такое mutex?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Мютекс</strong> – это специальный объект для синхронизации нитей/процессов. Он может принимать два состояния – занят и свободен. Если упростить, то мютекс – это boolean-переменная, которая принимает два значения: занят(true) и свободен(false).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Когда нить хочет монопольно владеть некоторым объектом, она помечает его мютекс занятым, а когда закончила работу с ним – помечает его мютекс свободным.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Мютекс прикреплен к каждому объекту в Java. Прямой доступ к мютексу есть только у Java-машины. От программиста он скрыт.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_включает_в_себя_аннотация_springbootapplication">Что включает в себя аннотация @SpringBootApplication?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>@EnableAutoConfiguration: включить механизм автоконфигурации Spring Boot</p>
</li>
<li>
<p>@ComponentScan: включить сканирование @Component для пакета, в котором находится приложение</p>
</li>
<li>
<p>@Configuration: позволяет регистрировать дополнительные компоненты (beans) в контексте или импортировать дополнительные классы конфигурации</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_записать_pid_processor_id_и_port_приложения_в_файл_при_старте">Как записать PID (processor ID) и port приложения в файл при старте?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>org.springframework.boot.system.ApplicationPidFileWriter</strong> — это класс istener, который отвечает за запись PID (processor ID) в указанную конфигурацию.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@SpringBootApplication</p>
</div>
<div class="paragraph">
<p>@ComponentScan // Using a root package also allows the @ComponentScan annotation to be used without needing to specify a basePackage attribute</p>
</div>
<div class="paragraph">
<p>public class SpringBootConfig {     public static void main(String[] args) throws Exception {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>springApplication.addListeners(new ApplicationPidFileWriter());     // register PID write to spring boot. It will write PID to file</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>SpringApplication springApplication = new SpringApplication(SpringBootConfig.class);</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>springApplication.run(args);     }</pre>
</div>
</div>
<div class="paragraph">
<p>}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Когда приложение запустится, оно запишет идентификатор процесса в указанный файл в конфигурации spring.pid.file.</p>
</div>
<div class="paragraph">
<p>spring.pid.file является необязательным. Если это свойство не указано, то spring boot создаст файл application.pid в корневой папке jar-файла приложения spring boot.</p>
</div>
<div class="paragraph">
<p>spring.pid.file=e:\\spring-boot-pid\\pid.txt #Location of the PID file to write</p>
</div>
<div class="ulist">
<ul>
<li>
<p>*org.springframework.boot.web.context.WebServerPortFileWriter *- это класс listener для записи порта приложения в файл.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы записать порт в файл, нам нужно зарегистрировать WebServerPortFileWriter в приложении. Есть два способа зарегистрировать WebServerPortFileWriter в приложении весенней загрузки.</p>
</div>
<div class="paragraph">
<p>Добавьте WebServerPortFileWriter, используя метод SpringApplication.addListeners().</p>
</div>
<div class="paragraph">
<p>WebServerPortFileWriter в файл spring.factories в качестве слушателя. убедитесь, что spring.factories должен находиться внутри каталога resources/META-INF.</p>
</div>
<div class="paragraph">
<p>После регистрации WebServerPortFileWriter Listener, когда приложение запустится, оно автоматически создаст файл application.port в корневом каталоге, где доступен файл .jar.</p>
</div>
<div class="paragraph">
<p><strong>WebServerPortFileWriter доступен только после весенней загрузки 2 (spring-boot-starter-parent-2.0.0.RELEASE)!!</strong></p>
</div>
<div class="paragraph">
<p>Пример 1-ого способа:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@SpringBootApplication&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@ComponentScan // Using a root package also allows the @ComponentScan annotation to be used without needing to specify a basePackage attribute&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;public class SpringBootConfig {&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;    public static void main(String[] args) throws Exception {&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt; SpringApplication application = new SpringApplication(SpringBootConfig.class);&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;i&gt; &lt;/i&gt;application.addListeners(new WebServerPortFileWriter());  &lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;i&gt; &lt;/i&gt;//application.addListeners(new WebServerPortFileWriter(""YourFileName""));</p>
</div>
<div class="paragraph">
<p>&lt;i&gt; &lt;/i&gt;for custom file name, default file name is application.port &lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;i&gt; &lt;/i&gt;application.run(); &lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;    } &lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;}</p>
</div>
<div class="paragraph">
<p>&lt;/i&gt;Пример 2-ого способа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">org.springframework.context.ApplicationListener=\ org.springframework.boot.web.context.WebServerPortFileWriter</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_разница_между_статическим_и_динамическим_полиморфизмом">Разница между статическим и динамическим полиморфизмом?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Переопределение метода (overright) - является примером статического полиморфизма во время компиляции, поскольку привязка метода между вызовом метода и определением метода происходит во время компиляции и зависит от ссылки на класс (ссылка создается во время компиляции и отправляется в стек).</p>
</li>
<li>
<p>Перегрузка Переопределение метода (overload) - является примером динамического полиморфизма во время выполнения, потому что привязка метода между вызовом метода и определением метода происходит во время выполнения и зависит от объекта класса (объект создается во время выполнения и отправляется в кучу).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работает_spring_security_как_сконфигурировать_какие_интерфейсы_используются">Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"</p>
</div>
<div class="paragraph">
<p>Spring Security обеспечивает всестороннюю поддержку аутентификации, авторизации и защиты от распространенных эксплойтов. Он также обеспечивает интеграцию с другими библиотеками, чтобы упростить его использование.</p>
</div>
<div class="paragraph">
<p>Spring Security - это список фильтров в виде класса FilterChainProxy, интегрированного в контейнер сервлетов, и в котором есть поле List&lt;SecurityFilterChain&gt;. Каждый фильтр реализует какой-то механизм безопасности. Важна последовательность фильтров в цепочке.</p>
</div>
<div class="paragraph">
<p>Когда мы добавляем аннотацию @EnableWebSecurity добавляется DelegatingFilterProxy, его задача заключается в том, чтобы вызвать цепочку фильтров (FilterChainProxy) из Spring Security.</p>
</div>
<div class="paragraph">
<p>В Java-based конфигурации цепочка фильтров создается неявно. Если мы хотим настроить свою цепочку фильтров, мы можем сделать это, создав класс, конфигурирующий наше Spring Security приложение, и унаследовавшись от абстрактного класса WebSecurityConfigurerAdapter. В данном классе, мы можем переопределить метод:</p>
</div>
<div class="paragraph">
<p>&lt;i&gt;@Override &lt;/i&gt;&lt;/div&gt;&lt;i&gt;
protected void configure(HttpSecurity http) throws Exception {&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
http&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
.csrf().disable()&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
.authorizeRequests();&lt;/i&gt;&lt;/div&gt;&lt;i&gt;
}&lt;/i&gt;</p>
</div>
<div class="paragraph">
<p>Именно этот метод конфигурирует цепочку фильтров Spring Security и</p>
</div>
<div class="paragraph">
<p>логика, указанная в этом методе, настроит цепочку фильтров.</p>
</div>
<div class="paragraph">
<p>Основные классы и интерфейсы</p>
</div>
<div class="paragraph">
<p>SecurityContext - интерфейс, отражающий контекст безопасности для текущего потока. Является контейнером для объекта типа Authentication. (Аналог - ApplicationContext, в котором лежат бины).</p>
</div>
<div class="paragraph">
<p>По умолчанию на каждый поток создается один SecurityContext. SecurityContext-ы хранятся в SecurityContextHolder. Имеет только два метода: getAuthentication() setAuthentication(Authentication authentication).</p>
</div>
<div class="paragraph">
<p>SecurityContextHolder - это место, где Spring Security хранит информацию о том, кто аутентифицирован. Класс, хранящий в ThreadLocal SecurityContext-ы для каждого потока, и содержащий статические методы для работы с SecurityContext-ами, а через них с текущим объектом Authentication, привязанным к нашему веб-запросу.</p>
</div>
<div class="paragraph">
<p>&lt;img src=""clip_image002-2d7fdc76353aa2c82dbfe771ee2a732c8d1d527c.gif""&gt;</p>
</div>
<div class="paragraph">
<p>Authentication - объект, отражающий информацию о текущем пользователе и его привилегиях. Вся работа Spring Security будет заключаться в том, что различные фильтры и обработчики будут брать и класть объект Authentication для каждого посетителя. Кстати объект Authentication можно достать в Spring MVC контроллере командой SecurityContextHolder.getContext().getAuthentication(). Authentication имеет реализацию по умолчанию - класс UsernamePasswordAuthenticationToken, предназначенный для хранения логина, пароля и коллекции Authorities.</p>
</div>
<div class="paragraph">
<p>Principal - интерфейс из пакета java.security, отражающий учетную запись пользователя. В терминах логин-пароль это логин. В интерфейсе Authentication есть метод getPrincipal(), возвращающий Object. При аутентификации с использованием имени пользователя/пароля Principal аутентификации с использованием имени пользователя/пароля Principal реализуется объектом типа UserDetails.</p>
</div>
<div class="paragraph">
<p>Credentials - любой Object; то, что подтверждает учетную запись пользователя, как правило пароль (отпечатки пальцев, пин - всё это Credentials, а владелец отпечатков и пина - Principal).</p>
</div>
<div class="paragraph">
<p>GrantedAuthority - полномочия, предоставленные пользователю, например, роли или уровни доступа.</p>
</div>
<div class="paragraph">
<p>UserDetails - интерфейс, представляющий учетную запись пользователя. Как правило модель нашего пользователя должна имплементировать его. Она просто хранит пользовательскую информацию в виде логина, пароля и флагов isAccountNonExpired, isAccountNonLocked, isCredentialsNonExpired, isEnabled, а также коллекции прав (ролей) пользователя. Данная информация позже инкапсулируется в объекты Authentication.</p>
</div>
<div class="paragraph">
<p>UserDetailsService - интерфейс объекта, реализующего загрузку пользовательских данных из хранилища. Созданный нами объект с этим интерфейсом должен обращаться к БД и получать оттуда юзеров.</p>
</div>
<div class="paragraph">
<p>AuthenticationManager - основной стратегический интерфейс для аутентификации. Имеет только один метод, который срабатывает, когда пользователь пытается аутентифицироваться в системе:</p>
</div>
<div class="paragraph">
<p>AuthenticationManager - основной стратегический интерфейс для аутентификации. Имеет только один метод, который срабатывает, когда пользователь пытается аутентифицироваться в системе:</p>
</div>
<div class="paragraph">
<p>public interface AuthenticationManager {</p>
</div>
<div class="paragraph">
<p>Authentication authenticate(Authentication authentication)</p>
</div>
<div class="paragraph">
<p>throws AuthenticationException;</p>
</div>
<div class="paragraph">
<p>}</p>
</div>
<div class="paragraph">
<p>AuthenticationManager может сделать одну из 3 вещей в своем методе authenticate():</p>
</div>
<div class="paragraph">
<p>вернуть Authentication (с authenticated=true), если предполагается, что вход осуществляет корректный пользователь.</p>
</div>
<div class="paragraph">
<p>бросить AuthenticationException, если предполагается, что вход осуществляет некорректный пользователь.</p>
</div>
<div class="paragraph">
<p>вернуть null, если принять решение не представляется возможным.</p>
</div>
<div class="paragraph">
<p>Наиболее часто используемая реализация AuthenticationManager - родной класс ProviderManager, который содержит поле private List&lt;AuthenticationProvider&gt; providers</p>
</div>
<div class="paragraph">
<p>со списком AuthenticationProvider-ов и итерирует запрос аутентификации по этому списку AuthenticationProvider-ов. Идея такого разделения - поддержка различных механизмов аутентификации на сайтах.</p>
</div>
<div class="paragraph">
<p>AuthenticationProvider - интерфейс объекта, аутентификацию. Имеет массу готовых реализаций. Также можем задать свой тип аутентификации. Как правило в небольших проектах одна логика аутентификации - по логину и паролю. В проектах побольше логик может быть несколько: Google-аутентификация и т.д., и для каждой из них создается свой</p>
</div>
<div class="paragraph">
<p>объект AuthenticationProvider.</p>
</div>
<div class="paragraph">
<p>AuthenticationProvider немного похож на AuthenticationManager, но у него есть дополнительный метод, позволяющий вызывающей стороне спрашивать, поддерживает ли он переданный ему объект Authentication, возможно этот AuthenticationProvider может</p>
</div>
<div class="paragraph">
<p>поддерживать аутентификацию по логину и паролю, но не поддерживать</p>
</div>
<div class="paragraph">
<p>аутентификацию:</p>
</div>
<div class="paragraph">
<p>boolean supports(java.lang.Class&lt;?&gt; authentication)</p>
</div>
<div class="paragraph">
<p>PasswordEncoder - интерфейс для шифрования/расшифровывания паролей. Одна из популярных реализаций - BCryptPasswordEncoder.</p>
</div>
<div class="paragraph">
<p>В случае, если нам необходимо добавить логику при успешной/ неудачной аутентификации, мы можем создать класс и имплементировать интерфейсы AuthenticationSuccessHandler и соответственно, переопределив их методы.</p>
</div>
<div class="paragraph">
<p>Как это работает с формой логина и UserDetailsService:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Пользователь вводит в форму и отправляет логин и пароль.</p>
</li>
<li>
<p>UsernamePasswordAuthenticationFilter создает объект Authentication - UsernamePasswordAuthenticationToken, где в качестве Principal - логин, а в качестве Credentials - пароль.</p>
</li>
<li>
<p>Затем UsernamePasswordAuthenticationToken передаёт Authentication с логином и паролем AuthenticationManager-у.</p>
</li>
<li>
<p>AuthenticationManager в виде конкретного ProviderManager внутри своего списка объектов AuthenticationProvider, имеющих разные логики аутентификации, пытается аутентифицировать посетителя, вызывая его метод authenticate(). AuthenticationProvider-а:</p>
</li>
<li>
<p>Метод authenticate() принимает в качестве аргумента незаполненный объект Authentication, например только с логином и паролем, полученными в форме логина на сайте. Затем с помощью UserDetailsService метод идёт в БД и ищет такого пользователя.</p>
</li>
<li>
<p>Если такой пользователь есть в БД, AuthenticationProvider получает его из базы в виде объекта UserDetails. Объект Authentication заполняется данными из UserDetails - в него включаются Authorities, а в Principal записывается сам объект UserDetails, содержащий пользователя.</p>
</li>
<li>
<p>Затем этот метод возвращает заполненный объект Authentication (прошли аутентификацию). AuthenticationSuccessHandler.</p>
</li>
<li>
<p>Если логин либо пароль неверные, то выбрасывается исключение. Вызывается AuthenticationFailureHandler.</p>
</li>
<li>
<p>Затем этот объект Authentication передается в AccessDecisionManager и получаем решение на получение доступа к запрашиваемой странице (проходим авторизацию).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_springboot_какие_у_него_преимущества_как_конфигурируется_подробно">Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.`</p>
</div>
<div class="paragraph">
<p>Spring Boot представляет собой комбинацию Spring Framework и встроенного контейнера сервлетов и отсутствие (или минимальное наличие) конфигурации приложения.</p>
</div>
<div class="paragraph">
<p>Преимущества Spring Boot:&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Простота управления зависимостями. Для упрощения процесса конфигурации есть starter-пакеты (набор удобных дескрипторов зависимостей).</p>
</li>
<li>
<p>Автоматическая конфигурация.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Автоматическая конфигурация включается аннотацией @EnableAutoConfiguration. (входит в состав аннотации @SpringBootApplication)</p>
</div>
<div class="paragraph">
<p>После выбора необходимых для приложения starter-пакетов Spring Boot попытается автоматически настроить Spring-приложение на основе выбранных jar-зависимостей, доступных в classpath классов, свойств в application.properties и т.п. Например, если добавим spring-boot-starter-web, то Spring boot автоматически сконфигурирует такие бины как DispatcherServlet, ResourceHandlers, MessageSource итд</p>
</div>
<div class="paragraph">
<p>Автоматическая конфигурация работает в последнюю очередь, после регистрации пользовательских бинов и всегда отдает им приоритет. Если ваш код уже зарегистрировал бин DataSource — автоконфигурация не будет его переопределять.&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Встроенная поддержка сервера и контейнера сервлетов</p>
</li>
<li>
<p>Дополнительные функции: метрики, проверки работоспособности, security и внешняя конфигурациии</p>
</li>
<li>
<p>Инструмент CLI(command-line interface) для разработки и тестирования приложения Spring Boot.</p>
</li>
<li>
<p>Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Как происходит автоконфигурация в Spring Boot:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>&lt;/div&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;i&gt;&lt;u&gt;@SpringBootApplication&lt;/u&gt;
&lt;u&gt;public class DemoApplication {&lt;/u&gt;
&lt;u&gt;public static void main(String[] args) {&lt;/u&gt;
&lt;u&gt;SpringApplication.run(DemoApplication.class, args);&lt;/u&gt;
&lt;u&gt;}&lt;/u&gt;
&lt;u&gt;}&lt;/u&gt;&lt;/i&gt;&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует так называемые фабрики.</p>
</li>
<li>
<p>Класс EnableAutoConfigurationImportSelector смотрит в файл META-INF/spring.factories и загружает оттуда список значений, которые являются именами классов (авто)конфигураций, которые Spring Boot импортирует. Т.е. аннотация @EnableAutoConfiguration просто импортирует ВСЕ (более 150) перечисленные в spring.factories конфигурации, чтобы предоставить нужные бины в контекст приложения.</p>
</li>
<li>
<p>Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан, и в большинстве случаев конфигурация ничего делать и создавать не будет.</p>
</li>
<li>
<p>Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.</p>
</li>
<li>
<p>Servlet container запускается, приложение готово к работе!</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_нововведения_spring_5">Расскажите про нововведения Spring 5</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)</p>
</li>
<li>
<p>Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)</p>
</li>
<li>
<p>Поддержка HTTP/2 (TLS, Push), NIO/NIO.2</p>
</li>
<li>
<p>Поддержка Kotlin</p>
</li>
<li>
<p>Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)</p>
</li>
<li>
<p>Null-safety аннотации(@Nullable), новая документация</p>
</li>
<li>
<p>Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)</p>
</li>
<li>
<p>Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)</p>
</li>
<li>
<p>Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jwt_токен">Что такое JWT токен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"JWT (JSON Web Token) - это открытый стандарт для создания токенов доступа, основанный на формате JSON.</p>
</div>
<div class="paragraph">
<p>JWT токен состоит из 3 частей, которые разделены точками:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Header (заголовок) - хранит пары ключ-значения, которые хранят служебную информацию об этом JWT токене.</p>
</li>
<li>
<p>Payload (тело / полезная нагрузка) - хранит данные сесси пользователя, это может быть: email, login и все остальное, что хранилось бы в сессии.</p>
</li>
<li>
<p>Signature (подпись) - часть токена, которая гаранитрует его неизменяемость, вычисляетя хеш от: header + payload + secret.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>""Secret"" - секретный ключ на стороне сервера, который никому кроме него не известен. Алгоритм хеширования может быть любой, но чаще всего используется SHA256.</p>
</div>
<div class="paragraph">
<p>&lt;span style=""color: rgb(170, 0, 0);""&gt;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9&lt;/span&gt;. // Header</p>
</div>
<div class="paragraph">
<p>&lt;span style=""color: rgb(170, 0, 255);""&gt;eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ&lt;/span&gt;. // Payload</p>
</div>
<div class="paragraph">
<p>&lt;span style=""color: rgb(0, 170, 255);""&gt;-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM&lt;/span&gt; // Signature</p>
</div>
<div class="paragraph">
<p>"
== "&lt;span style=""color: rgb(0, 170, 255);""&gt;JWT &lt;/span&gt;vs. &lt;span style=""color: rgb(217, 0, 0);""&gt;Session + Cookies&lt;/span&gt;"</p>
</div>
<div class="paragraph">
<p>"&lt;span style=""color: rgb(41, 156, 255);""&gt;JWT - ""все свои данные ношу с собой"":&lt;/span&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;span style=""color: rgb(41, 156, 255);""&gt;Stateless (не имеет состяния на сервере, хранит информацию в самом себе)&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(41, 156, 255);""&gt;если в сессии пользователя много информации её придется передавать в каждом запросе&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(41, 156, 255);""&gt;нагрузка на сеть и более долгие запросы&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(41, 156, 255);""&gt;пользователь может посмотреть, что мы храним о нём в нашем токене&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(41, 156, 255);""&gt;в токене менять данные мы не можем, он находиться на компьютере у пользователя, можем только выдать новый, когда срок старого истечёт&lt;/span&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;Session + Cookies - данные храню на сервере: &lt;/span&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;Stateful (информация хранится на сервере)&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;всегда лишь одна пара ключ значение&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;более быстрые запросы&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;пользователь не знает, что мы храним&lt;/span&gt;</p>
</li>
<li>
<p>&lt;span style=""color: rgb(217, 0, 0);""&gt;в сессиях мы можем менять данные пользователя у себя на сервере как захотим</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/span&gt;</p>
</div>
<div class="paragraph">
<p>&lt;span style=""color: rgb(0, 255, 0);""&gt;У механизма Session + Cookies больше преимуществ, поэтому JWT используется только тогда, когда в этом есть реальная необходимость.&lt;/span&gt;&lt;/div&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_spring_security">Что такое Spring Security?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это компонент Spring Framework - является стандратом обеспечения безопасности в Spring приложениях.</p>
</div>
<div class="paragraph">
<p>Помогает реализовать функционал аутентификации и авторизации.</p>
</div>
<div class="paragraph">
<p>Может использоваться как в монолитных так и в микросервисных приложениях.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_аутентификация_и_авторизация">Что такое аутентификация и авторизация?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Аутентификация - это когда мы доказываем серверу что это мы, посредством ввода логина и пароля.</p>
</li>
<li>
<p>Авторизация - после аутентификации, что мы можем делать внутри сервера? Это зависит от нашей роли (пользователь, администратор), одни роли авторизованы на одно, другие на другое.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;img src=""paste-b92cfe472d17f519846e5a9d3bbc2ffbeb2eee98.png""&gt;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_spring_security_встраивается_в_web_приложение">Как Spring Security встраивается в web приложение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>С помощью <strong>фильтров</strong>.</p>
</div>
<div class="paragraph">
<p>*Фильтр *- объект, который перехватывает все входящие HTTP запросы. Если в фильтре будет выясненно, что пользователь не тот, то есть, если пользователь не пройдет проверку (аутентификацию), то фильтр не пропустит его дальше до нашего Spring приложения.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_устроена_аутентификация_в_spring">Как устроена аутентификация в Spring?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Есть интерфейс <strong>AuthenticationProvider</strong> с методом <strong>authenticate()</strong>, который принимает на вход объект класса <strong>Authentication</strong>, и так же возвращает объект этого класса.</p>
</div>
<div class="paragraph">
<p>Аутентификацию методом <strong>authenticate()</strong> можно проводить разными способами, к примеру:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>обращаться к БД, чтобы проверить валидность логиня и пароля пользователя</p>
</li>
<li>
<p>можем обращаться к специальному серверу, который проводит аутентификацию</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Authentication *- хранит в себе *Credentials *(логин и пароль пользователя), когда подается на вход в параметры метода и хранит себе объект *Principal</strong>, в который можно получит что угодно, но чаще всего туда ложится сам пользователь (информация о пользователе).</p>
</div>
<div class="paragraph">
<p>В приложении могут быть несколько <strong>AuthenticationProvider</strong>, каждый со своей реализацией метода <strong>authenticate()</strong>.</p>
</div>
<div class="paragraph">
<p>Особенность объекта *Principal *- это то что после успешной аутентификации пользователя, при каждом следующем запросе, мы будем иметь доступ к его *Authentication *с *Principal *внутри.</p>
</div>
<div class="paragraph">
<p>Как это возможно, ведь HTTP stateless? Объект помещается в сессию пользователя. За то, что при каждом запросе этот объект подгружался из сесси отвечает отдельный *фильтр *из Spring Security.</p>
</div>
<div class="paragraph">
<p>Пока сессия действительна, пользователю не надо проходить аутентификацию при каждом запросе.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_session_и_cookies">Что такое Session и Cookies?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Session - это набор данных о пользователе и его действиях, хранящихся на сервере, которая поддерживает состояние между HTTP-запросами. HTTP по сути является протоколом без состояния (stateless), сеансы используются для придания ему состояния. С помощью Cookies, сервер определяет какой сеанс принадлежит какому пользователю.</p>
</div>
<div class="paragraph">
<p>Cookies - это пара ключ - значение, который посыется бразуером при каждом запросе к какому-то серверу, чаще всего они содержать какую-то персональную информацию, как например ID, через который сервер может определить сессию пользователя.</p>
</div>
<div class="paragraph">
<p>Cookies находится в памяти браузера и ваш браузер заботиться о том, чтобы отправлять их только тем доменам, которые идентифицированы с ними.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_возможны_ли_коллизии_при_шифровании_пароля_через_sha256_или_bcrypt">Возможны ли коллизии при шифровании пароля через SHA256 или BCrypt?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, теоритически это возможно, поскольку мы превращаем одну строку в другю фиксированный длинны, но это вероятность настолько мала, что ей можно пренебречь.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_детерминированный_и_недетерминированный_алгоритм_шифрования_какой_из_них_должен_применятся_в_шифровании_паролей">Что такое детерминированный и недетерминированный алгоритм шифрования? Какой из них должен применятся в шифровании паролей?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Детерминированный алгоритм всегда возвращает одно и тоже значения для какого-то аргумента.</p>
</li>
<li>
<p>Недетерминированный алгоритм возвращает рандомные значения для одной и того же параметра.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Нужно применять детерминированный.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_однодвусторонняя_функция_в_шифровании">Что такое одно/двусторонняя функция в шифровании?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Односторонняя это когда мы не можем из шифра получить зашифрованный текст, а двусторонняя, когда можем.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_микросервисная_архитектура">Что такое микросервисная архитектура?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Микросервисы - Spring Cloud</p>
</div>
<div class="paragraph">
<p>Микросервисная архитектура - это архитектура приложения, которая строится как набор небольших и слабосвязанных компонентов (микросервисов), которые можно разрабатывать, развертывать и поддерживать независимо друг от друга.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_плюсы_и_минусы_микросервисов">Плюсы и минусы микросервисов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Плюсы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>нет привязки к конкретным языкам и технологиям</p>
</li>
<li>
<p>простая интеграция со сторонними решениями и возможность повторного использования</p>
</li>
<li>
<p>практически бесконечная масштабируемость</p>
</li>
<li>
<p>простота обслуживания</p>
</li>
<li>
<p>отказоустойчивость</p>
</li>
<li>
<p>упрощенная симметричная архитектура приложения вместо иерархической с одноранговыми зависимостями между компонентами</p>
</li>
<li>
<p>внесение правок без рисков “обрушить” всю систему</p>
</li>
<li>
<p>возможность производить обновления чаще и быстрее, так как использование микросервисов позволяет обновлять приложение п частям</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Минусы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>миграция монолитной архитектуры в микросервисную может обойтись очень дорого</p>
</li>
<li>
<p>для развертывания микросервисов потребуются опытные специалисты</p>
</li>
<li>
<p>Более сложный DevOps</p>
</li>
<li>
<p>Мониторинг сложнее</p>
</li>
<li>
<p>Retry запросы</p>
</li>
<li>
<p>Распределенные логи и трейсинг запросов</p>
</li>
<li>
<p>Circuit breaking</p>
</li>
<li>
<p>Дубли данных</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_монолитная_архитектура">Что такое монолитная архитектура?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Монолитная архитектура - это архитектура приложения, которая строится как единое целое, где вся логика по обработке запросов помещается внутрь одного процесса. Разумеется, монолиты могут иметь модульную структуру — содержать отдельные классы, функции и т.п. Но связи между этими модулями настолько сильны, что изменение каждого из них неизбежно отражается на работе приложения в целом.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_плюсы_и_минусы_монолитной_архитектуры">Плюсы и минусы монолитной архитектуры?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Плюсы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Упрощенная разработка и развертывание</p>
</li>
<li>
<p>Меньше сквозных проблем</p>
</li>
<li>
<p>Лучшая производительность</p>
</li>
<li>
<p>Не надо отслеживать HTTP запросы</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Минусы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Кодовая база со временем становится громоздкой</p>
</li>
<li>
<p>Сложно внедрять новые технологии</p>
</li>
<li>
<p>Небольшое обновление требует полного повторного развертывания</p>
</li>
<li>
<p>Невозможность масштабирования части приложения</p>
</li>
<li>
<p>Отказ одного модуля чаще всего сказывается на всей работе</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_общаются_между_собой_микросервисы">Как общаются между собой микросервисы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Есть два варианта: синхронное взаимодействие или асинхронное взаимодействие.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Синхронное взаимодействие с помощью HTTP/REST сервисов</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Синхронное взаимодействие микросервисов обычно осуществляется через HTTP и REST-подобные сервисы, которые возвращают XML или JSON — хотя это ни в коем случае не является обязательным (посмотрите, например, на Google Protocol Buffers).</p>
</div>
<div class="paragraph">
<p>Используйте REST-коммуникацию, когда вам нужен немедленный ответ, который мы используем в нашем случае, так как проверка риска обязательна перед открытием счета: нет проверки риска, нет счета.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Асинхронное взаимодействие с помощью обменасообщениями</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Асинхронная микросервисная связь обычно осуществляется посредством обмена сообщениями с помощью реализации JMS и/или с помощью протокола, такого как AMQP. Обычно, на практике не следует недооценивать интеграцию по электронной почте / SMTP.</p>
</div>
<div class="paragraph">
<p>Используйте асинхронное взаимодействие, когда вам не нужен немедленный ответ, скажем, пользователи нажимают кнопку «купить сейчас», и вы хотите сгенерировать счет-фактуру, что, безусловно, не должно происходить в рамках цикла запроса-ответа пользователя на покупку.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_понять_какой_микросервис_упал">Как понять, какой микросервис упал?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Spring sleuth</p>
</li>
<li>
<p>Нужно добавить трассировку по id к запросу (паттернDistributing TracerId)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_load_balancer">Что такое Load Balancer?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Балансировщик нагрузки – перенаправляет запросы на нужный экземпляр приложения (если их запущено несколько).</p>
</div>
<div class="paragraph">
<p>Распределяет траффик между экземплярами микросервисов. Раньше использовалась интеграция с LB Netflix Ribbon Сейчас Spring разработал свою реализацию: Spring Cloud Load Balancer. Рекомендуется использовать ее.</p>
</div>
<div class="paragraph">
<p>В Spring API Gateway уже автоматически встроен LB, который сам принимает решение, куда перенаправить запрос, “видит” какие экземпляры запущены и пр.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_api_gateway">Что такое API Gateway?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Является шлюзом, который обрабатывает входящие запросы и “перекидывает” их на нужный мс (с логированием, кешированием, безопасностью и пр.)</p>
</div>
<div class="paragraph">
<p>В технологиях Spring это направление называется Spring Cloud Gateway микросервисов.</p>
</div>
<div class="paragraph">
<p>AG – это маршрутизатор запросов (он сам не содержит микросервисы, а только перенаправляет запросы)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_rest_принципы_rest">Что такое REST? Принципы REST?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>REST - означает Representational State Transfer (Передача состояния представления)</p>
</div>
<div class="paragraph">
<p>REST API — REST - это набор правил (архитектурный стиль) о том, какпрограммисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать. И использует HTTP-запросы для получения, извлечения, размещения и удаления данных. Его также называют RESTful.</p>
</div>
<div class="paragraph">
<p><strong>ПРИНЦИПЫ REST API</strong></p>
</div>
<div class="paragraph">
<p>Принципы REST API определены в диссертации его создателя Роя Филдинга. Основные из них:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>единый интерфейс</p>
</li>
<li>
<p>разграничение клиента и сервера</p>
</li>
<li>
<p>нет сохранения состояния</p>
</li>
<li>
<p>кэширование всегда разрешено</p>
</li>
<li>
<p>многоуровневая система</p>
</li>
<li>
<p>код предоставляется по запросу.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&lt;/div&gt;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Единый интерфейс</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ресурсы должны быть однозначно идентифицированы посредством одного URL-адреса и только с помощью базовых методов сетевого протокола (DELETE, PUT, GET, HTTP).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Клиент-сервер</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Должно быть четкое разграничение между клиентом и сервером:</p>
</div>
<div class="paragraph">
<p>пользовательский интерфейс и вопросы сбора запросов — на стороне клиента.</p>
</div>
<div class="paragraph">
<p>доступ к данным, управление рабочей нагрузкой и безопасность — на сторонесервера.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Сохранение состояния</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все клиент-серверные операции должны быть без сохранения состояния. Любое необходимое управление состоянием должно осуществляться наклиенте, а не на сервере.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Кэширование</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Все ресурсы должны разрешать кэширование, если явно не указано, что оно невозможно.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Многоуровневая система</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>REST API допускает архитектуру, которая состоит из нескольких уровней серверов.
* Запрос кодаВ большинстве случаев сервер отправляет обратно статические представленияресурсов в формате XML или JSON. Однако при необходимости серверы могутотправлять исполняемый код непосредственно клиенту.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-09-15 05:01:04 UTC
</div>
</div>
</body>
</html>