<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Servlets, JSP, JSTL</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article">
<div id="header">
<h1>Servlets, JSP, JSTL</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_что_такое_сервлет">Что такое <em>«сервлет»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Сервлет</strong> является интерфейсом, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ. Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов.</p>
</div>
<div class="paragraph">
<p>Большинство необходимых для создания сервлетов классов и интерфейсов содержатся в пакетах <code>javax.servlet</code> и <code>javax.servlet.http</code>.</p>
</div>
<div class="paragraph">
<p>Основные методы сервлета:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public void init(ServletConfig config) throws ServletException</code> запускается сразу после загрузки сервлета в память;</p>
</li>
<li>
<p><code>public ServletConfig getServletConfig()</code> возвращает ссылку на объект, который предоставляет доступ к информации о конфигурации сервлета;</p>
</li>
<li>
<p><code>public String getServletInfo()</code> возвращает строку, содержащую информацию о сервлете, например: автор и версия сервлета;</p>
</li>
<li>
<p><code>public void service(ServletRequest request, ServletResponse response) throws ServletException, java.io.IOException</code> вызывается для обработки каждого запроса;</p>
</li>
<li>
<p><code>public void destroy()</code> выполняется перед выгрузкой сервлета из памяти.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Текущая спецификация - Servlet 3.1 описана в JSR-340 и принята в 2013 году.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_заключаются_преимущества_технологии_сервлетов_над_cgi_common_gateway_interface">В чем заключаются преимущества технологии сервлетов над CGI (Common Gateway Interface)?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Сервлеты предоставляют лучшую производительность обработки запросов и более эффективное использование памяти за счет использования преимущество многопоточности (на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).</p>
</li>
<li>
<p>Сервлеты, как платформа и система являются независимыми. Таким образом веб-приложение, написанное с использованием сервлетов может быть запущена в любом контейнере сервлетов, реализующим этот стандарт и в любой операционной системе.</p>
</li>
<li>
<p>Использование сервлетов повышает надежность программы, т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), безопасности и сборщике мусора.</p>
</li>
<li>
<p>Сервлеты относительно легки в изучении и поддержке, таким образом разработчику необходимо заботиться только о бизнес-логике приложения, а не внутренней реализации веб-технологий.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какова_структура_веб_проекта">Какова структура веб-проекта?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>src/main/java</code> Исходники приложения/библиотеки</p>
</div>
<div class="paragraph">
<p><code>src/main/resources</code> Ресурсные файлы приложения/библиотеки</p>
</div>
<div class="paragraph">
<p><code>src/main/filters</code> Файлы сервлетных фильтров</p>
</div>
<div class="paragraph">
<p><code>src/main/webapp</code> Исходники веб-приложения</p>
</div>
<div class="paragraph">
<p><code>src/test/java</code> Исходники тестов</p>
</div>
<div class="paragraph">
<p><code>src/test/resources</code> Ресурсные файлы тестов</p>
</div>
<div class="paragraph">
<p><code>src/test/filters</code> Тесты сервлетных фильтров</p>
</div>
<div class="paragraph">
<p><code>src/it</code> Интеграционные тесты</p>
</div>
<div class="paragraph">
<p><code>src/assembly</code> Описание сборки</p>
</div>
<div class="paragraph">
<p><code>src/site</code> Сайт</p>
</div>
<div class="paragraph">
<p><code>LICENSE.txt</code> Лицензия проекта</p>
</div>
<div class="paragraph">
<p><code>NOTICE.txt</code> Замечания и определения библиотек зависимостей.</p>
</div>
<div class="paragraph">
<p><code>README.txt</code> Описание проекта</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_контейнер_сервлетов">Что такое <em>«контейнер сервлетов»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Контейнер сервлетов</strong>&#8201;&#8212;&#8201;программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, или интегрироваться в Java EE сервер приложений.</p>
</div>
<div class="paragraph">
<p>Контейнер сервлетов обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.</p>
</div>
<div class="paragraph">
<p>Наиболее известные реализации контейнеров сервлетов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Apache Tomcat</p>
</li>
<li>
<p>Jetty</p>
</li>
<li>
<p>JBoss</p>
</li>
<li>
<p>WildFly</p>
</li>
<li>
<p>GlassFish</p>
</li>
<li>
<p>IBM WebSphere</p>
</li>
<li>
<p>Oracle Weblogic</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужны_сервера_приложений_если_есть_контейнеры_сервлетов">Зачем нужны сервера приложений, если есть контейнеры сервлетов?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Пулы соединений с БД</strong></p>
<div class="ulist">
<ul>
<li>
<p>Возможность периодического тестирования доступности СУБД и обновления соединения в случае восстановления после сбоев</p>
</li>
<li>
<p>Замена прав доступа при подключении</p>
</li>
<li>
<p>Балансировка нагрузки между несколькими СУБД, определение доступность или недоступность того или иного узла</p>
</li>
<li>
<p>Защита пула соединений от некорректного кода в приложении, которое по недосмотру не возвращает соединения, просто отбирая его после какого-то таймаута.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>JMS</strong></p>
<div class="ulist">
<ul>
<li>
<p>Доступность сервера очередей сообщений "из-коробки".</p>
</li>
<li>
<p>Возможность кластеризации очередей, т.е. доступность построения распределенных очередей, расположенных сразу на нескольких серверах, что существенно увеличивает масштабируемость и доступность приложения</p>
</li>
<li>
<p>Возможность миграции очередей - в случае падения одного из серверов, его очереди автоматически перемещаются на другой, сохраняя необработанные сообщения.</p>
</li>
<li>
<p>В некоторых серверах приложений поддерживается <em>Unit-of-Order</em> - гарантированный порядок обработки сообщений, удовлетворяющих некоторым критериям.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>JTA</strong> Встроенная поддержка распределенных транзакций для обеспечения согласованности данных в разные СУБД или очереди.</p>
</li>
<li>
<p><strong>Безопасность</strong></p>
<div class="ulist">
<ul>
<li>
<p>Наличие множества провайдеров безопасности и аутентификации:</p>
<div class="ulist">
<ul>
<li>
<p>во встроенном или внешнем <em>LDAP-сервере</em></p>
</li>
<li>
<p>в базе данных</p>
</li>
<li>
<p>в различных <em>Internet-directory</em> (специализированных приложениях для управления правами доступа)</p>
</li>
</ul>
</div>
</li>
<li>
<p>Доступность <em>Single-Sign-On</em> (возможности разделения пользовательской сессии между приложениями) посредством <em>Security Assertion Markup Language (SAML) 1/2</em> или <em>Simple and Protected Negotiate (SPNEGO)</em> и <em>Kerberos</em>: один из серверов выступает в роли базы для хранения пользователей, все другие сервера при аутентификации пользователя обращаются к этой базе.</p>
</li>
<li>
<p>Возможность авторизации посредством протокола <em>eXtensible Access Control Markup Language (XACML)</em>, позволяющего описывать довольно сложные политики (например, приложение доступно пользователю только в рабочее время).</p>
</li>
<li>
<p>Кластеризация всего вышеперечисленного</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Масштабируемость и высокая доступность</strong> Для контейнера сервлетов обычно так же возможно настроить кластеризацию, но она будет довольно примитивной, так как в случае его использования имеются следующие ограничения:</p>
<div class="ulist">
<ul>
<li>
<p>Сложность передачи пользовательской сессии из одного <em>центра обработки данных (ЦоД)</em> в другой через Интернет</p>
</li>
<li>
<p>Отсутствие возможности эффективно настроить репликации сессий на большом (состоящем из 40-50 экземпляров серверов) кластере</p>
</li>
<li>
<p>Невозможность обеспечения миграции экземпляров приложения на другой сервер</p>
</li>
<li>
<p>Недоступность механизмов автоматического мониторинга и реакции на ошибки</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Управляемость</strong></p>
<div class="ulist">
<ul>
<li>
<p>Присутствие единого центра управления, т.н. <em>AdminServer</em> и аналога <em>NodeManager</em>&#8217;а, обеспечивающего</p>
<div class="ulist">
<ul>
<li>
<p>Возможность одновременного запуска нескольких экземпляров сервера</p>
</li>
<li>
<p>Просмотр состояния запущенных экземпляров сервера, обработчиков той или иной очереди, на том или ином сервере, количества соединений с той или иной БД</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Административный канал и развертывание в промышленном режиме</strong> Некоторые сервера приложений позволяют включить так называемый "административный канал" - отдельный порт, запросы по которому имеют приоритет.</p>
<div class="ulist">
<ul>
<li>
<p>Просмотр состояния (выполняющихся транзакций, потоков, очередей) в случае недоступности ("зависания") сервера</p>
</li>
<li>
<p>Обновление приложений "на-лету", без простоя:</p>
<div class="ulist">
<ul>
<li>
<p>добавление на сервер новой версии приложения в "закрытом" режиме, пока пользователи продолжают работать со предыдущей</p>
</li>
<li>
<p>тестирование корректности развертывания новой версии</p>
</li>
<li>
<p>"скрытый" перевод на использование новой версии всех пользователей</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_контейнер_сервлетов_управляет_жизненным_циклом_сервлета_когда_и_какие_методы_вызываются">Как контейнер сервлетов управляет жизненным циклом сервлета, когда и какие методы вызываются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Загрузка класса сервлета&#8201;&#8212;&#8201;когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в память и вызов его конструктора без параметров.</p>
</li>
<li>
<p>Инициализация класса сервлета&#8201;&#8212;&#8201;после того как класс загружен контейнер инициализирует объект <code>ServletConfig</code> для этого сервлета и внедряет его через <code>init()</code> метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.</p>
</li>
<li>
<p>Обработка запросов&#8201;&#8212;&#8201;после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет контейнер порождает новый поток и вызывает метод <code>service()</code> путем передачи ссылки на объекты ответа и запроса.</p>
</li>
<li>
<p>Удаление - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов уничтожает классы сервлетов путем вызова <code>destroy()</code> метода.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения (в отличии от объектов классов, которые уничтожаются сборщиком мусора после того, как они уже не используются) и весь жизненный цикл сервлета можно описать как последовательность вызова методов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>public void init(ServletConfig config)</code>&#8201;&#8212;&#8201;используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета.</p>
</li>
<li>
<p><code>public void service(ServletRequest request, ServletResponse response)</code>&#8201;&#8212;&#8201;вызывается для каждого запроса. Метод не может быть вызван раньше выполнения <code>init()</code> метода.</p>
</li>
<li>
<p><code>public void destroy()</code>&#8201;&#8212;&#8201;вызывается для уничтожения сервлета (один раз за время жизни сервлета).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_дескриптор_развертывания">Что такое <em>«дескриптор развертывания»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Дескриптор развертывания&#8201;&#8212;&#8201;это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. В спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.</p>
</div>
<div class="paragraph">
<p>Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развертывания используется язык XML.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&gt;

    &lt;display-name&gt;Display name.&lt;/display-name&gt;
    &lt;description&gt;Description text.&lt;/description&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;xyz.company.ExampleServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;configuration&lt;/param-name&gt;
            &lt;param-value&gt;default&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/example&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;ExampleJSP&lt;/servlet-name&gt;
        &lt;jsp-file&gt;/sample/Example.jsp&lt;/jsp-file&gt;
    &lt;/servlet&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;myParam&lt;/param-name&gt;
        &lt;param-value&gt;the value&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для веб-приложений дескриптор развертывания должен называться <code>web.xml</code> и находиться в директории <code>WEB-INF</code>, в корне веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации. Также есть и другие типы дескрипторов, такие, как файл дескриптора развертывания <code>sun-web.xml</code>, содержащий специфичные для <em>Sun GlassFish Enterprise Server</em> данные для развертывания именно для этого сервера приложений или файл <code>application.xml</code> в директории <code>META-INF</code> для приложений <em>J2EE</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_действия_необходимо_проделать_при_создании_сервлетов">Какие действия необходимо проделать при создании сервлетов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Чтобы создать сервлет <code>ExampleServlet</code>, необходимо описать его в дескрипторе развёртывания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/example&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;xyz.company.ExampleServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;config&lt;/param-name&gt;
        &lt;param-value&gt;default&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем создать класс <code>xyz.company.ExampleServlet</code> путём наследования от <code>HttpServlet</code> и реализовать логику его работы в методе <code>service()</code> или методах <code>doGet()</code>/<code>doPost()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_каком_случае_требуется_переопределять_метод_service">В каком случае требуется переопределять метод <code>service()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>service()</code> переопределяется, когда необходимо, чтобы сервлет обрабатывал все запросы (и <code>GET</code>, и <code>POST</code>) в одном методе.</p>
</div>
<div class="paragraph">
<p>Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода <code>service()</code>, который в зависимости от поступившего запроса вызывает или метод <code>doGet()</code> или метод <code>doPost()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_есть_ли_смысл_определять_для_сервлета_конструктор_каким_образом_лучше_инициализировать_данные">Есть ли смысл определять для сервлета конструктор? Каким образом лучше инициализировать данные?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Большого смысла определять для сервлета конструктор нет, т.к. инициализировать данные лучше не в конструкторе, а переопределив метод <code>init()</code>, в котором имеется возможность доступа к параметрам инициализации сервлета через использование объекта <code>ServletConfig</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_необходимо_переопределить_только_init_метод_без_аргументов">Почему необходимо переопределить только <code>init()</code> метод без аргументов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>init()</code> переопределяется, если необходимо инициализировать какие-то данные до того как сервлет начнет обрабатывать запросы.</p>
</div>
<div class="paragraph">
<p>При переопределении метода <code>init(ServletConfig config)</code>, первым должен быть вызван метод <code>super(config)</code>, который обеспечит вызов метода <code>init(ServletConfig config)</code> суперкласса. <code>GenericServlet</code> предоставляет другой метод <code>init()</code> без параметров, который будет вызываться в конце метода <code>init(ServletConfig config)</code>.</p>
</div>
<div class="paragraph">
<p>Необходимо использовать переопределенный метод <code>init()</code> без параметров для инициализации данных во избежание каких-либо проблем, например ошибку, когда вызов <code>super()</code> не указан в переопределенном <code>init(ServletConfig config)</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_наиболее_распространенные_задачи_выполняются_в_контейнере_сервлетов">Какие наиболее распространенные задачи выполняются в контейнере сервлетов?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Поддержка обмена данными. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, а также разбирать запрос и генерировать ответ. Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.</p>
</li>
<li>
<p>Управление жизненным циклом сервлетов и ресурсов. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.</p>
</li>
<li>
<p>Поддержка многопоточности. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.</p>
</li>
<li>
<p>Поддержка JSP. JSP классы не похожи на стандартные классы джавы, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.</p>
</li>
<li>
<p>Различные задачи. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_сервлетных_фильтрах">Что вы знаете о <em>сервлетных фильтрах</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Сервлетный фильтр</strong> - это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.</p>
</div>
<div class="paragraph">
<p>Сервлетные фильтры могут:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;</p>
</li>
<li>
<p>определить содержание запроса прежде, чем сервлет будет инициирован;</p>
</li>
<li>
<p>модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;</p>
</li>
<li>
<p>модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;</p>
</li>
<li>
<p>перехватывать инициацию сервлета после обращения к сервлету.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Сервлетный фильтр может быть конфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. Основой для формирования фильтров служит интерфейс <code>javax.servlet.Filter</code>, который реализует три метода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void init(FilterConfig config) throws ServletException</code>;</p>
</li>
<li>
<p><code>void destroy()</code>;</p>
</li>
<li>
<p><code>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException</code>;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Метод <code>init()</code> вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. Метод <code>doFilter()</code> выполняет непосредственно работу фильтра. Таким образом, сервер вызывает <code>init()</code> один раз, чтобы запустить фильтр в работу, а затем вызывает <code>doFilter()</code> столько раз, сколько запросов будет сделано непосредственно к данному фильтру. После того, как фильтр заканчивает свою работу, вызывается метод <code>destroy()</code>.</p>
</div>
<div class="paragraph">
<p>Интерфейс <code>FilterConfig</code> содержит метод для получения имени фильтра, его параметров инициации и контекста активного в данный момент сервлета. С помощью своего метода <code>doFilter()</code> каждый фильтр получает текущий запрос <code>request</code> и ответ <code>response</code>, а также <code>FilterChain</code>, содержащий список фильтров, предназначенных для обработки. В <code>doFilter()</code> фильтр может делать с запросом и ответом всё, что ему захочется - собирать данные или упаковывать объекты для придания им нового поведения. Затем фильтр вызывает <code>chain.doFilter()</code>, чтобы передать управление следующему фильтру. После возвращения этого вызова фильтр может по окончании работы своего метода <code>doFilter()</code> выполнить дополнительную работу над полученным ответом. К примеру, сохранить регистрационную информацию об этом ответе.</p>
</div>
<div class="paragraph">
<p>После того, как класс-фильтр откомпилирован, его необходимо установить в контейнер и <em>«приписать» (map)</em> к одному или нескольким сервлетам. Объявление и подключение фильтра отмечается в дескрипторе развёртывания <code>web.xml</code> внутри элементов <code>&lt;filter&gt;</code> и <code>&lt;filter-mapping&gt;</code>. Для подключение фильтра к сервлету необходимо использовать вложенные элементы <code>&lt;filter-name&gt;</code> и <code>&lt;servlet-name&gt;</code>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Объявление класс-фильтра <code>FilterConnect</code> с именем <code>FilterName</code>:</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">  &lt;filter&gt;
        &lt;filter-name&gt;FilterName&lt;/filter-name&gt;
        &lt;filter-class&gt;FilterConnect&lt;/filter-class&gt;
        &lt;init-param&gt;
                &lt;!--- фильтр имеет параметр инициализации `active`, которому присваивается значение `true`. --&gt;
                &lt;param-name&gt;active&lt;/param-name&gt;
                &lt;param-value&gt;true&lt;/param-true&gt;
        &lt;/init-param&gt;
  &lt;/filter&gt;</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Подключение фильтра <code>FilterName</code> к сервлету <code>ServletName</code>:</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">  &lt;filter-mapping&gt;
        &lt;filter-name&gt;FilterName&lt;/filter-name&gt;
        &lt;servlet-name&gt;ServletName&lt;/servlet-name&gt;
  &lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для связи фильтра со страницами HTML или группой сервлетов необходимо использовать тег <code>&lt;url-pattern&gt;</code>:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Подключение фильтра <code>FilterName</code> ко всем вызовам .html страниц</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">  &lt;filter-mapping&gt;
          &lt;filter-name&gt;FilterName&lt;/filter-name&gt;
          &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Порядок, в котором контейнер строит цепочку фильтров для запроса определяется следующими правилами:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>цепочка, определяемая <code>&lt;url-pattern&gt;</code>, выстраивается в том порядке, в котором встречаются соответствующие описания фильтров в <code>web.xml</code>;</p>
</li>
<li>
<p>последовательность сервлетов, определенных с помощью <code>&lt;servlet-name&gt;</code>, также выполняется в той последовательности, в какой эти элементы встречаются в дескрипторе развёртывания <code>web.xml</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_в_сервлетах_используются_различные_listener">Зачем в сервлетах используются различные <em>listener</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Listener (слушатель)</strong> работает как триггер, выполняя определённые действия при наступлении какого-либо события в жизненном цикле сервлета.</p>
</div>
<div class="paragraph">
<p>Слушатели, разделённые по области видимости (scope):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Request</em>:</p>
<div class="ulist">
<ul>
<li>
<p><code>ServletRequestListener</code> используется для того, чтобы поймать момент создания и уничтожения запроса;</p>
</li>
<li>
<p><code>ServletRequestAttributeListener</code> используется для прослушивания событий, происходящих с атрибутами запроса.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Context</em>:</p>
<div class="ulist">
<ul>
<li>
<p><code>ServletContextListener</code> позволяет поймать момент, когда контекст инициализируется либо уничтожается;</p>
</li>
<li>
<p><code>ServletContextAttributeListener</code> используется для прослушивании событий, происходящих с атрибутами в контексте.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Session</em>:</p>
<div class="ulist">
<ul>
<li>
<p><code>HttpSessionListener</code> позволяет поймать момент создания и уничтожения сессии;</p>
</li>
<li>
<p><code>HttpSessionAttributeListener</code> используется при прослушивании событий происходящих с атрибутами в сессии;</p>
</li>
<li>
<p><code>HttpSessionActivationListener</code> используется в случае, если происходит миграция сессии между различными JVM в распределённых приложениях;</p>
</li>
<li>
<p><code>HttpSessionBindingListener</code> так же используется для прослушивания событий, происходящих с атрибутами в сессии. Разница между <code>HttpSessionAttributeListener</code> и <code>HttpSessionBindingListener</code> слушателями: первый декларируется в <code>web.xml</code>; экземпляр класса создается контейнером автоматически в единственном числе и применяется ко всем сессиям; второй: экземпляр класса должен быть создан и закреплён за определённой сессией «вручную», количество экземпляров также регулируется самостоятельно.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Подключение слушателей:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;
    ...
    &lt;listener&gt;
        &lt;listener-class&gt;xyz.company.ExampleListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HttpSessionBindingListener</code> подключается в качестве атрибута непосредственно в сессию, т.е., чтобы его подключить необходимо:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создать экземпляр класса, реализующего этот интерфейс;</p>
</li>
<li>
<p>положить созданный экземпляр в сессию при помощи <code>setAttribute(String, Object)</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_когда_стоит_использовать_фильтры_сервлетов_а_когда_слушателей">Когда стоит использовать фильтры сервлетов, а когда слушателей?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные (например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), в случае, когда необходимо реагировать на события - лучше применять слушателей.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_реализовать_запуск_сервлета_одновременно_с_запуском_приложения">Как реализовать запуск сервлета одновременно с запуском приложения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Контейнер сервлетов обычно загружает сервлет по первому запросу клиента.</p>
</div>
<div class="paragraph">
<p>Если необходимо загрузить сервлет прямо на старте приложения (например если загрузка сервлета происходит длительное время) следует использовать элемент <code>&lt;load-on-startup&gt;</code> в дескрипторе или аннотацию <code>@loadOnStartup</code> в коде сервлета, что будет указывать на необходимость загрузки сервлета при запуске.</p>
</div>
<div class="paragraph">
<p>Если целочисленное значение этого параметра отрицательно, то сервлет будет загружен при запросе клиента. В противном случае - загрузится на старте приложения, при этом, чем число меньше, тем раньше в очереди на загрузку он окажется.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;xyz.company.ExampleServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_обработать_в_приложении_исключения_выброшенные_другим_сервлетом">Как обработать в приложении исключения, выброшенные другим сервлетом?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда приложение выбрасывет исключение контейнер сервлетов обрабатывает его и создаёт ответ в формате HTML. Это аналогично тому, что происходит при кодах ошибок вроде 404, 403 и т.д.</p>
</div>
<div class="paragraph">
<p>В дополнении к этому существует возможность написания собственных сервлетов для обработки исключений и ошибок с указанием их в дескрипторе развертывания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/AppExceptionHandler&lt;/location&gt;
&lt;/error-page&gt;

&lt;error-page&gt;
    &lt;exception-type&gt;javax.servlet.ServletException&lt;/exception-type&gt;
    &lt;location&gt;/AppExceptionHandler&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Основная задача таких сервлетов - обработать ошибку/исключение и сформировать понятный ответ пользователю. Например, предоставить ссылку на главную страницу или же описание ошибки.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_представляет_собой_servletconfig">Что представляет собой <code>ServletConfig</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>javax.servlet.ServletConfig</code> используется для передачи сервлету конфигурационной информации. Каждый сервлет имеет свой собственный экземпляр объекта <code>ServletConfig</code>, создаваемый контейнером сервлетов.</p>
</div>
<div class="paragraph">
<p>Для установки параметров конфигурации используются параметры <code>init-param</code> в <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;xyz.company.ExampleServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;exampleParameter&lt;/param-name&gt;
        &lt;param-value&gt;parameterValue&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>или аннотации <code>@WebInitParam</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WebServlet(
    urlPatterns = "/example",
    initParams = {
        @WebInitParam(name = "exampleParameter", value = "parameterValue")
    }
)
public class ExampleServlet extends HttpServlet {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для получения <code>ServletConfig</code> сервлета используется метод <code>getServletConfig()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_представляет_собой_servletcontext">Что представляет собой <code>ServletContext</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Уникальный (в рамках веб-приложения) объект <code>ServletContext</code> реализует интерфейс <code>javax.servlet.ServletContext</code> и предоставляет сервлетам доступ к параметрам этого веб-приложения.  Для предоставления доступа используется элемент <code>&lt;context-param&gt;</code> в <code>web.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;web-app&gt;
    ...
    &lt;context-param&gt;
        &lt;param-name&gt;exampleParameter&lt;/param-name&gt;
        &lt;param-value&gt;parameterValue&lt;/param-value&gt;
    &lt;/context-param&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объект <code>ServletContext</code> можно получить с помощью метода <code>getServletContext()</code> у интерфейса <code>ServletConfig</code>. Контейнеры сервлетов так же могут предоставлять контекстные объекты, уникальные для группы сервлетов. Каждая из групп будет связана со своим набором URL-путей хоста. В спецификации Servlet 3 <code>ServletContext</code> был расширен и теперь предоставляет возможности программного добавления слушателей и фильтров в приложение. Так же у этого интерфейса имеется множество полезных методов таких как 	<code>getServerInfo()</code>, <code>getMimeType()</code>, <code>getResourceAsStream()</code> и т.д.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_отличия_servletcontext_и_servletconfig">В чем отличия <code>ServletContext</code> и <code>ServletConfig</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>ServletConfig</code> уникален для сервлета, а <code>ServletContext</code> - для приложения;</p>
</li>
<li>
<p><code>ServletConfig</code> используется для предоставления параметров инициализации конкретному сервлету, а <code>ServletContext</code> для предоставления параметров инициализации для всех сервлетов приложения;</p>
</li>
<li>
<p>для <code>ServletConfig</code> возможности модифицировать атрибуты отсутствуют, атрибуты в объекте <code>ServletContext</code> можно изменять.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужен_интерфейс_servletresponse">Для чего нужен интерфейс <code>ServletResponse</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>ServletResponse</code> используется для отправки данных клиенту. Все методы данного инструмента служат именно этой цели:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getCharacterEncoding()</code> - возвращает MIME тип кодировки (к примеру - UTF8), в которой будет выдаваться информация;</p>
</li>
<li>
<p><code>void setLocale(Locale locale)</code>/<code>Locale getLocale()</code> - указывают на язык используемый в документе;</p>
</li>
<li>
<p><code>ServletOutputStream getOutputStream()</code>/<code>PrintWriter getWriter()</code> - возвращают потоки вывода данных;</p>
</li>
<li>
<p><code>void setContentLength(int len)</code> - устанавливает значение поля HTTP заголовка <em>Content-Length</em>;</p>
</li>
<li>
<p><code>void setContentType(String type)</code> - устанавливает значение поля HTTP заголовка <em>Content-Type</em>.</p>
</li>
<li>
<p><code>void reset()</code> - позволяет сбросить HTTP заголовок к значениям по-умолчанию, если он ещё не был отправлен</p>
</li>
<li>
<p>и др.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужен_интерфейс_servletrequest">Для чего нужен интерфейс <code>ServletRequest</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>ServletRequest</code> используется для получения параметров соединения, запроса, а также заголовков, входящего потока данных и т.д.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_request_dispatcher">Что такое <code>Request Dispatcher</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>RequestDispatcher</code> используется для передачи запроса другому ресурсу, при этом существует возможность добавления данных, полученных из этого ресурса к собственному ответу сервлета. Так же этот интерфейс используется для внутренней коммуникации между сервлетами в одном контексте.</p>
</div>
<div class="paragraph">
<p>В интерфейсе объявлено два метода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void forward(ServletRequest var1, ServletResponse var2)</code>&#8201;&#8212;&#8201;передает запрос из сервлета к другому ресурсу (сервлету, JSP или HTML файлу) на сервере.</p>
</li>
<li>
<p><code>void include(ServletRequest var1, ServletResponse var2)</code>&#8201;&#8212;&#8201;включает контент ресурса (сервлет, JSP или HTML страница) в ответ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Доступ к интерфейсу можно получить с помощью метода интерфейса <code>ServletContext</code> - <code>RequestDispatcher getRequestDispatcher(String path)</code>, где путь начинающийся с <code>/</code>, интерпретируется относительно текущего корневого пути контекста.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_из_одного_сервлета_вызвать_другой_сервлет">Как из одного сервлета вызвать другой сервлет?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для вызова сервлета из того же приложения необходимо использовать механизм внутренней коммуникации сервлетов (<em>inter-servlet communication mechanisms</em>) через вызовы методов <code>RequestDispatcher</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>forward()</code> - передаёт выполнение запроса в другой сервлет;</p>
</li>
<li>
<p><code>include()</code> - предоставляет возможность включить результат работы другого сервлета в возвращаемый ответ.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если необходимо вызывать сервлет принадлежащий другому приложению, то использовать <code>RequestDispatcher</code> уже не получится, т.к. он определен только для текущего приложения. Для подобных целей необходимо использовать метод <code>ServletResponse</code> - <code>sendRedirect()</code> которому предоставляется полный URL другого сервлета. Для передачи данных между сервлетами можно использовать <code>cookies</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличается_sendredirect_от_forward">Чем отличается <code>sendRedirect()</code> от <code>forward()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong><code>forward()</code></strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Выполняется на стороне сервера;</p>
</li>
<li>
<p>Запрос перенаправляется на другой ресурс в пределах того же сервера;</p>
</li>
<li>
<p>Не зависит от протокола клиентского запроса, так как обеспечивается контейнером сервлетов;</p>
</li>
<li>
<p>Нельзя применять для внедрения сервлета в другой контекст;</p>
</li>
<li>
<p>Клиент не знает о фактически обрабатываемом ресурсе и URL в строке остается прежним;</p>
</li>
<li>
<p>Выполняется быстрее метода <code>sendRedirect()</code>;</p>
</li>
<li>
<p>Определён в интерфейсе <code>RequestDispatcher</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><code>sendRedirect()</code></strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Выполняется на стороне клиента;</p>
</li>
<li>
<p>Клиенту возвращается ответ <code>302 (redirect)</code> и запрос перенаправляется на другой сервер;</p>
</li>
<li>
<p>Может использоваться только с клиентами HTTP;</p>
</li>
<li>
<p>Разрешается применять для внедрения сервлета в другой контекст;</p>
</li>
<li>
<p>URL адрес изменяется на адрес нового ресурса;</p>
</li>
<li>
<p>Медленнее <code>forward()</code> т.к. требует создания нового запроса;</p>
</li>
<li>
<p>Определён в интерфейсе <code>HttpServletResponse</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_используются_атрибуты_сервлетов_и_как_происходит_работа_с_ними">Для чего используются атрибуты сервлетов и как происходит работа с ними?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Атрибуты сервлетов используются для внутренней коммуникации сервлетов.</p>
</div>
<div class="paragraph">
<p>В веб-приложении существует возможность работы с атрибутами используя методы <code>setAttribute()</code>, <code>getAttribute()</code>, <code>removeAttribute()</code>, <code>getAttributeNames()</code>, которые предоставлены интерфейсами <code>ServletRequest</code>, <code>HttpSession</code> и <code>ServletContext</code> (для областей видимости <em>request</em>, <em>session</em>, <em>context</em> соответственно).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_можно_допустить_в_сервлете_deadlock">Каким образом можно допустить в сервлете deadlock?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Можно получить блокировку, например, допустив циклические вызовы метода <code>doPost()</code> в методе <code>doGet()</code> и метода <code>doGet()</code> в методе <code>doPost()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_получить_реальное_расположение_сервлета_на_сервере">Как получить реальное расположение сервлета на сервере?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Реальный путь к расположению сервлета на сервере можно получить из объекта <code>ServletContext</code>:</p>
</div>
<div class="paragraph">
<p><code>getServletContext().getRealPath(request.getServletPath())</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_получить_информацию_о_сервере_из_сервлета">Как получить информацию о сервере из сервлета?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Информацию о сервере можно получить из объекта <code>ServletContext</code>:</p>
</div>
<div class="paragraph">
<p><code>getServletContext().getServerInfo()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_получить_ip_адрес_клиента_на_сервере">Как получить IP адрес клиента на сервере?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>IP адрес клиента можно получить вызвав <code>request.getRemoteAddr()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_классы_обертки_для_сервлетов_вы_знаете">Какие классы-обертки для сервлетов вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Собственные обработчики <code>ServletRequest</code> и <code>ServletResponse</code> можно реализовать, добавив новые или переопределив существующие методы у классов-обёрток <code>ServletRequestWrapper</code> (<code>HttpServletRequestWrapper</code>) и <code>ServletResponseWrapper</code> (<code>HttpServletRequestWrapper</code>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_отличия_genericservlet_и_httpservlet">В чем отличия <code>GenericServlet</code> и <code>HttpServlet</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Абстрактный класс <code>GenericServlet</code>&#8201;&#8212;&#8201;независимая от используемого протокола реализация интерфейса <code>Servlet</code>, а абстрактный класс <code>HttpServlet</code> в свою очередь расширяет <code>GenericServlet</code> для протокола HTTP..</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_httpservlet_класс_объявлен_как_абстрактный">Почему <code>HttpServlet</code> класс объявлен как абстрактный?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс <code>HTTPServlet</code> предоставляет лишь общую реализацию сервлета для HTTP протокола. Реализация ключевых методов <code>doGet()</code> и <code>doPost()</code>, содержащих основную бизнес-логику перекладывается на разработчика и по умолчанию возвращает <code>HTTP 405 Method Not Implemented error</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_основные_методы_присутствуют_в_классе_httpservlet">Какие основные методы присутствуют в классе <code>HttpServlet</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>doGet()</code> - для обработки HTTP запросов <code>GET</code>;</p>
</li>
<li>
<p><code>doPost()</code> - для обработки HTTP запросов <code>POST</code>;</p>
</li>
<li>
<p><code>doPut()</code> - для обработки HTTP запросов <code>PUT</code>;</p>
</li>
<li>
<p><code>doDelete()</code> - для обработки HTTP запросов <code>DELETE</code>;</p>
</li>
<li>
<p><code>doHead()</code> - для обработки HTTP запросов <code>HEAD</code>;</p>
</li>
<li>
<p><code>doOptions()</code> - для обработки HTTP запросов <code>OPTIONS</code>;</p>
</li>
<li>
<p><code>doTrace()</code> - для обработки HTTP запросов <code>TRACE</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_стоит_ли_волноваться_о_многопоточной_безопасности_работая_с_сервлетами">Стоит ли волноваться о многопоточной безопасности работая с сервлетами?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Методы <code>init()</code> и <code>destroy()</code> вызываются один раз за жизненный цикл сервлета&#8201;&#8212;&#8201;поэтому по поводу них беспокоиться не стоит.</p>
</div>
<div class="paragraph">
<p>Методы <code>doGet()</code>, <code>doPost()</code>, <code>service()</code> вызываются на каждый запрос клиента и т.к. сервлеты используют многопоточность, то здесь задумываться о потокобезопасной работе обязательно. При этом правила использования многопоточности остаются теми же: локальные переменные этих методов будут созданы отдельно для каждого потока, а при использовании глобальных разделяемых ресурсов необходимо использовать синхронизацию или другие приёмы многопоточного программирования.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_метод_http_не_является_неизменяемым">Какой метод HTTP не является неизменяемым?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP метод называется неизменяемым, если он на один и тот же запрос всегда возвращает одинаковый результат. HTTP методы <code>GET</code>, <code>PUT</code>, <code>DELETE</code>, <code>HEAD</code> и <code>OPTIONS</code> являются неизменяемыми, поэтому необходимо реализовывать приложение так, чтобы эти методы возвращали одинаковый результат постоянно. К изменяемым методам относится метод <code>POST</code>, который и используется для реализации чего-либо, что изменяется при каждом запросе.</p>
</div>
<div class="paragraph">
<p>К примеру, для доступа к статической HTML странице используется метод <code>GET</code>, т.к. он всегда возвращает одинаковый результат. При необходимости сохранять какую-либо информацию, например в базе данных, нужно использовать <code>POST</code> метод.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_есть_методы_отправки_данных_с_клиента_на_сервер">Какие есть методы отправки данных с клиента на сервер?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>GET</code> - используется для запроса содержимого указанного ресурса, изображения или гипертекстового документа. Вместе с запросом могут передаваться дополнительные параметры как часть URI, значения могут выбираться из полей формы или передаваться непосредственно через URL. При этом запросы кэшируются и имеют ограничения на размер. Этот метод является основным методом взаимодействия браузера клиента и веб-сервера.</p>
</li>
<li>
<p><code>POST</code> - используется для передачи пользовательских данных в содержимом HTTP-запроса на сервер. Пользовательские данные упакованы в тело запроса согласно полю заголовка Content-Type и/или включены в URI запроса. При использовании метода POST под URI подразумевается ресурс, который будет обрабатывать запрос.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_разница_между_методами_get_и_post">В чем разница между методами <code>GET</code> и <code>POST</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>GET</code> передает данные серверу используя URL, тогда как <code>POST</code> передает данные, используя тело HTTP запроса. Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать через <code>GET</code>. <code>POST</code> может отправлять гораздо большие объемы данных. Лимит устанавливается web-server и составляет обычно около 2 Mb.</p>
</li>
<li>
<p>Передача данных методом <code>POST</code> более безопасна, чем методом <code>GET</code>, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя, в отличии от URL, который виден почти всегда. Иногда это преимущество превращается в недостаток - вы не сможете послать данные за кого-то другого.</p>
</li>
<li>
<p><code>GET</code>метод является неизменяемым, тогда как <code>POST</code>&#8201;&#8212;&#8201;изменяемый.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_разница_между_printwriter_и_servletoutputstream">В чем разница между <code>PrintWriter</code> и <code>ServletOutputStream</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>PrintWriter</code>&#8201;&#8212;&#8201;класс для работы с символьным потоком, экземпляр которого можно получить через метод <code>ServletResponse</code> <code>getWriter()</code>;</p>
</div>
<div class="paragraph">
<p><code>ServletOutputStream</code>&#8201;&#8212;&#8201;класс для работы байтовым потоком. Для получения его экземпляра используется метод <code>ServletResponse</code> <code>getOutputStream()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_одновременно_использовать_в_сервлете_printwriter_и_servletoutputstream">Можно ли одновременно использовать в сервлете <code>PrintWriter</code> и <code>ServletOutputStream</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Так сделать не получится, т.к. при попытке одновременного вызова <code>getWriter()</code> и <code>getOutputStream()</code> будет выброшено исключение <code>java.lang.IllegalStateException</code> с сообщением, что уже был вызван другой метод.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_об_интерфейсе_singlethreadmodel">Расскажите об интерфейсе <code>SingleThreadModel</code>.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс <code>SingleThreadModel</code> является маркерным - в нем не объявлен ни один метод, однако, если сервлет реализует этот интерфейс, то метод <code>service()</code> этого сервлета гарантированно не будет одновременно выполняться в двух потоках. Контейнер сервлетов либо синхронизирует обращения к единственному экземпляру, либо обеспечивает поддержку пула экземпляров и перенаправление запроса свободному сервлету.
Другими словами, контейнер гарантирует отсутствие конфликтов при одновременном обращении к переменным или методам экземпляра сервлета. Однако существуют также и другие разделяемые ресурсы, которые даже при использовании этого интерфейса, остаются всё так же доступны обработчикам запросов в других потоках. Т.о. пользы от использования этого интерфейса немного и в спецификации Servlet 2.4 он был объявлен <code>deprecated</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_означает_url_encoding_как_это_осуществить_в_java">Что означает <em>URL encoding</em>? Как это осуществить в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>URL Encoding</strong>&#8201;&#8212;&#8201;процесс преобразования данных в форму CGI (Common Gateway Interface), не содержащую пробелов и нестандартных символов, которые заменяются в процессе кодирования на специальные escape-символы. В Java для кодирования строки используется метод <code>java.net.URLEncoder.encode(String str, String unicode)</code>. Обратная операция декодирования возможна через использование метода <code>java.net.URLDecoder.decode(String str, String unicode)</code>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><code>Hello мир!</code> преобразовывается в <code>Hello%20%D0%BC%D0%B8%D1%80!</code>.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_различные_методы_управления_сессией_в_сервлетах_вы_знаете">Какие различные методы управления сессией в сервлетах вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При посещении клиентом Web-ресурса и выполнении вариантов запросов, контекстная информация о клиенте не хранится. В протоколе HTTP нет возможностей для сохранения и изменения информации о предыдущих посещениях клиента. Сеанс (сессия)&#8201;&#8212;&#8201;соединение между клиентом и сервером, устанавливаемое на определенное время, за которое клиент может отправить на сервер сколько угодно запросов. Сеанс устанавливается непосредственно между клиентом и Web-сервером. Каждый клиент устанавливает с сервером свой собственный сеанс. Сеансы используются для обеспечения хранения данных во время нескольких запросов Web-страницы или на обработку информации, введенной в пользовательскую форму в результате нескольких HTTP-соединений (например, клиент совершает несколько покупок в интернет-магазине; студент отвечает на несколько тестов в системе дистанционного обучения).</p>
</div>
<div class="paragraph">
<p>Существует несколько способов обеспечения уникального идентификатора сессии:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>User Authentication</strong>&#8201;&#8212;&#8201;Предоставление учетных данных самим пользователем в момент аутентификации. Переданная таким образом информация в дальнейшем используется для поддержания сеанса. Это метод не будет работать, если пользователь вошёл в систему одновременно из нескольких мест.</p>
</li>
<li>
<p><strong>HTML Hidden Field</strong>&#8201;&#8212;&#8201;Присвоение уникального значения скрытому полю HTML страницы, в момент когда пользователь начинает сеанс. Этот метод не может быть использован со ссылками, потому что нуждается в подтверждении формы со скрытым полем каждый раз во время формирования запроса. Кроме того, это не безопасно, т.к. существует возможность простой подмены такого идентификатора.</p>
</li>
<li>
<p><strong>URL Rewriting</strong>&#8201;&#8212;&#8201;Добавление идентификатора сеанса как параметра URL. Достаточно утомительная операция, потому что требует постоянного отслеживания этого идентификатора при каждом запросе или ответе.</p>
</li>
<li>
<p><strong>Cookies</strong>&#8201;&#8212;&#8201;Использование небольших фрагментов данных, отправленных web-сервером и хранимых на устройстве пользователя. Данный метод не будет работать, если клиент отключает использование cookies.</p>
</li>
<li>
<p><strong>Session Management API</strong>&#8201;&#8212;&#8201;Использование специального API для отслеживания сеанса, построенный на основе и на методах, описанных выше и который решает частные проблемы перечисленных способов:</p>
<div class="ulist">
<ul>
<li>
<p>Чаще всего недостаточно просто отслеживать сессию, необходимо ещё и сохранять какие-либо дополнительные данные о ней, которые могут потребоваться при обработке последующих запросов. Осуществление такого поведения требует много дополнительных усилий.</p>
</li>
<li>
<p>Все вышеперечисленные методы не являются универсальными: для каждого из них можно подобрать конкретный сценарий, при котором они не будут работать.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_cookies">Что такое <em>cookies</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Сookies («куки»)</strong>&#8201;&#8212;&#8201;небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя. Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>аутентификации пользователя;</p>
</li>
<li>
<p>хранения персональных предпочтений и настроек пользователя;</p>
</li>
<li>
<p>отслеживания состояния сеанса доступа пользователя;</p>
</li>
<li>
<p>ведения разнообразной статистики.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_методы_для_работы_с_cookies_предусмотрены_в_сервлетах">Какие методы для работы с cookies предусмотрены в сервлетах?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Servlet API предоставляет поддержку cookies через класс <code>javax.servlet.http.Cookie</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Для получения массива cookies из запроса необходимо воспользоваться методом <code>HttpServletRequest.getCookies()</code>. Методов для добавления cookies в <code>HttpServletRequest</code> не предусмотрено.</p>
</li>
<li>
<p>Для добавления cookie в ответ используется <code>HttpServletResponse.addCookie(Cookie c)</code>. Метода получения cookies в <code>HttpServletResponse</code> отсутствует.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_url_rewriting">Что такое <em>URL Rewriting</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>URL Rewriting</strong> - специальная перезапись (перекодирование) оригинального URL. Данный механизм может использоваться для управления сессией в сервлетах, когда <em>cookies</em> отключены.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужны_и_чем_отличаются_методы_encodeurl_и_encoderedirecturl">Зачем нужны и чем отличаются методы <code>encodeURL()</code> и <code>encodeRedirectURL()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>HttpServletResponse.encodeURL()</code> предоставляет способ преобразования URL в HTML гиперссылку с преобразованием спецсимволов и пробелов, а так же добавления <em>session id</em> к URL. Такое поведение аналогично <code>java.net.URLEncoder.encode()</code>, но с добавлением дополнительного параметра <code>jsessionid</code> в конец URL.</p>
</div>
<div class="paragraph">
<p>Метод <code>HttpServletResponse.encodeRedirectURL()</code> преобразует URL для последующего использования в методе <code>sendRedirect()</code>.</p>
</div>
<div class="paragraph">
<p>Таким образом для HTML гиперссылок при <em>URL rewriting</em> необходимо использовать <code>encodeURL()</code>, а для URL при перенаправлении - <code>encodeRedirectUrl()</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_сессия">Что такое <em>«сессия»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Сессия</strong>  - это сеанс связи между клиентом и сервером, устанавливаемый на определенное время. Сеанс устанавливается непосредственно между клиентом и веб-сервером в момент получения первого запроса к веб-приложению. Каждый клиент устанавливает с сервером свой собственный сеанс, который сохраняется до окончания работы с приложением.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_уведомить_объект_в_сессии_что_сессия_недействительна_или_закончилась">Как уведомить объект в сессии, что сессия недействительна или закончилась?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Чтобы быть уверенным в том, что объект будет оповещён о прекращении сессии, нужно реализовать интерфейс <code>javax.servlet.http.HttpSessionBindingListener</code>. Два метода этого интерфейса: <code>valueBound()</code> и <code>valueUnbound()</code> используются при добавлении объекта в качестве атрибута к сессии и при уничтожении сессии соответственно.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_существует_эффективный_способ_удостоверится_что_все_сервлеты_доступны_только_для_пользователя_с_верной_сессией">Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с верной сессией?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сервлет фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. Поэтому логично использовать соответствующий фильтр для проверки необходимой информации (например валидности сессии) в запросе.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_мы_можем_обеспечить_transport_layer_security_для_нашего_веб_приложения">Как мы можем обеспечить <em>transport layer security</em> для нашего веб приложения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для обеспечения <em>transport layer security</em> необходимо настроить поддержку SSL сервлет контейнера. Как это сделать зависит от конкретной реализации сервлет-контейнера.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_организовать_подключение_к_базе_данных_обеспечить_журналирование_в_сервлете">Как организовать подключение к базе данных, обеспечить журналирование в сервлете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в <em>servlet context listener</em>, а также установить в качестве атрибута контекста для возможности использования другими сервлетами.</p>
</div>
<div class="paragraph">
<p>Журналирование подключается к сервлету стандартным для логгера способом (например для <em>log4j</em> это может быть property-файл или XML-конфигурация) , а далее эта информация используется при настройке соответствующего <em>context listener</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_основные_особенности_появились_в_спецификации_servlet_3">Какие основные особенности появились в спецификации <em>Servlet 3</em>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Servlet Annotations</strong>. До Servlet 3 вся конфигурация содержалась в <code>web.xml</code>, что приводило к ошибкам и неудобству при работе с большим количестве сервлетов. Примеры аннотаций: <code>@WebServlet</code>, <code>@WebInitParam</code>, <code>@WebFilter</code>, <code>@WebListener</code>.</p>
</li>
<li>
<p><strong>Web Fragments</strong>. Одностраничное веб приложение может содержать множество модулей: все модули прописываются в <code>fragment.xml</code> в папке <code>META-INF\</code>. Это позволяет разделять веб приложение на отдельные модули, собранные как .jar-файлы в отдельной <code>lib\</code> директории.</p>
</li>
<li>
<p><strong>Динамическое добавление веб компонентов</strong>. Появилась возможность программно добавлять фильтры и слушатели, используя <code>ServletContext</code> объект. Для этого применяются методы <code>addServlet()</code>, <code>addFilter()</code>, <code>addListener()</code>. Используя это нововведение стало доступным построение динамической системы, в которой необходимый объект будет создан и вызван только по необходимости.</p>
</li>
<li>
<p><strong>Асинхронное выполнение</strong>. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток без удержания всего сервера занятым.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_способы_аутентификации_доступны_сервлету">Какие способы аутентификации доступны сервлету?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Спецификация сервлетов определяет четыре типа проверки подлинности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HTTP Basic Authentication</strong> - <code>BASIC</code>. При доступе к закрытым ресурсам появится окно, которое попросит ввести данные для аутентификации.</p>
</li>
<li>
<p><strong>Form Based Login</strong> - <code>FORM</code>. Используется собственная html форма:</p>
</li>
<li>
<p><strong>HTTP Digest Authentication</strong> - <code>DIGEST</code>. Цифровая аутентификация с шифрованием.</p>
</li>
<li>
<p><strong>HTTPS Authentication</strong> - <code>CLIENT-CERT</code>. Аутентификация с помощью клиентского сертификата.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;login-config&gt;
    &lt;auth-method&gt;FORM&lt;/auth-method&gt;
    &lt;form-login-config&gt;
        &lt;form-login-page&gt;/login.html&lt;/form-login-page&gt;
        &lt;form-error-page&gt;/error.html&lt;/form-error-page&gt;
    &lt;/form-login-config&gt;
&lt;/login-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_java_server_pages_jsp">Что такое <em>Java Server Pages (JSP)</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JSP (JavaServer Pages)</strong>&#8201;&#8212;&#8201;платформонезависимая переносимая и легко расширяемая технология разработки веб-приложений, позволяющая веб-разработчикам создавать содержимое, которое имеет как статические, так и динамические компоненты. Страница JSP содержит текст двух типов: статические исходные данные, которые могут быть оформлены в одном из текстовых форматов HTML, SVG, WML, или XML, и <em>JSP-элементы</em>, которые конструируют динамическое содержимое. Кроме этого могут использоваться <em>библиотеки JSP-тегов</em>, а также <em>EL (Expression Language)</em>, для внедрения Java-кода в статичное содержимое JSP-страниц.</p>
</div>
<div class="paragraph">
<p>Код JSP-страницы транслируется в Java-код сервлета с помощью компилятора JSP-страниц <em>Jasper</em>, и затем компилируется в байт-код JVM.</p>
</div>
<div class="paragraph">
<p>JSP-страницы загружаются на сервере и управляются Java EE Web Application. Обычно такие страницы упакованы в файловые архивы .war и .ear.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужен_jsp">Зачем нужен JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JSP расширяет технологию сервлетов обеспечивая возможность создания динамических страницы с HTML подобным синтаксисом.</p>
</div>
<div class="paragraph">
<p>Хотя создание представлений поддерживается и в сервлетах, но большая часть любой веб-страницы является статической, поэтому код сервлета в таком случае получается чересчур перегруженным, замусоренным и поэтому при его написании легко допустить ошибку.</p>
</div>
<div class="paragraph">
<p>Еще одним преимуществом JSP является горячее развертывание - возможность заменить одну страницу на другую непосредственно в контейнере без необходимости перекомпилировать весь проект или перезапускать сервер.</p>
</div>
<div class="paragraph">
<p>Однако рекомендуется избегать написания серьёзной бизнес-логики в JSP и использовать страницу только в качестве представления.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_опишите_как_обрабатываются_jsp_страницы_начиная_от_запроса_к_серверу_заканчивая_ответом_пользователю">Опишите, как обрабатываются JSP страницы, начиная от запроса к серверу, заканчивая ответом пользователю.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Когда пользователь переходит по ссылке на страницу <code>page.jsp</code>, он отправляет http-запрос на сервер <code>GET /page.jsp</code>. Затем, на основе этого запроса и текста самой страницы, сервер генерирует java-класс, компилирует его и выполняет полученный сервлет, формирующий ответ пользователю в виде представления этой страницы, который сервер и перенаправляет обратно пользователю.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_об_этапах_фазах_жизненного_цикла_jsp">Расскажите об этапах (фазах) жизненного цикла JSP.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если посмотреть код внутри созданной JSP страницы, то он будет выглядеть как HTML и не будет похож на java класс. Конвертацией JSP страниц в HTML код занимается контейнер, который так же создает и сервлет для использования в веб приложении.</p>
</div>
<div class="paragraph">
<p>Жизненный цикл JSP состоит из нескольких фаз, которыми руководит JSP контейнер:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Translation</strong>&#8201;&#8212;&#8201;проверка и парсинг кода JSP страницы для создания кода сервлета.</p>
</li>
<li>
<p><strong>Compilation</strong>&#8201;&#8212;&#8201;компиляция исходного кода сервлета.</p>
</li>
<li>
<p><strong>Class Loading</strong>&#8201;&#8212;&#8201;загрузка скомпилированного класса в память.</p>
</li>
<li>
<p><strong>Instantiation</strong>&#8201;&#8212;&#8201;внедрение конструктора без параметра загруженного класса для инициализации в памяти.</p>
</li>
<li>
<p><strong>Initialization</strong>&#8201;&#8212;&#8201;вызов <code>init()</code> метода объекта JSP класса и инициализация конфигурации сервлета с первоначальными параметрами, которые указаны в дескрипторе развертывания (<code>web.xml</code>). После этой фазы JSP способен обрабатывать запросы клиентов. Обычно эти фазы происходят после первого запроса клиента (т.е. ленивая загрузка), но можно настроить загрузку и инициализацию JSP на старте приложения по аналогии с сервлетами.</p>
</li>
<li>
<p><strong>Request Processing</strong>&#8201;&#8212;&#8201;длительный жизненный цикл обработки запросов клиента JSP страницей. Обработка является многопоточной и аналогична сервлетам&#8201;&#8212;&#8201;для каждого запроса создается новый поток, объекты <code>ServletRequest</code> и <code>ServletResponse</code>, происходит выполнение сервис методов.</p>
</li>
<li>
<p><strong>Destroy</strong>&#8201;&#8212;&#8201;последняя фаза жизненного цикла JSP, на которой её класс удаляется из памяти. Обычно это происходит при выключении сервера или выгрузке приложения.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_о_методах_жизненного_цикла_jsp">Расскажите о методах жизненного цикла JSP.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Контейнер сервлетов (например, Tomcat, GlassFish) создает из JSP-страницы класс сервлета, наследующего свойства интерфейса <code>javax.servlet.jsp.HttpJspBase</code> и включающего следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jspInit()</code>&#8201;&#8212;&#8201;метод объявлен в JSP странице и реализуется с помощью контейнера. Этот метод вызывается один раз в жизненном цикле JSP для того, чтобы инициализировать конфигурационные параметры указанные в дескрипторе развертывания. Этот метод можно переопределить с помощью определения элемента <em>JSP scripting</em> и указания необходимых параметров для инициализации;</p>
</li>
<li>
<p><code>_jspService()</code>&#8201;&#8212;&#8201;метод переопределяется контейнером автоматически и соответствует непосредственно коду JSP, описанному на странице. Этот метод определен в интерфейсе <code>HttpJspPage</code>, его имя начинается с нижнего подчеркивания и он отличается от других методов жизненного цикла тем, что его невозможно переопределить;</p>
</li>
<li>
<p><code>jspDestroy()</code>&#8201;&#8212;&#8201;метод вызывается контейнером для удаления объекта из памяти (на последней фазе жизненного цикла JSP - Destroy). Метод вызывается только один раз и доступен для переопределения, предоставляя возможность освободить ресурсы, которые были созданы в <code>jspInit()</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_методы_жизненного_цикла_jsp_могут_быть_переопределены">Какие методы жизненного цикла JSP могут быть переопределены?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Возможно переопределить лишь <code>jspInit()</code> и <code>jspDestroy()</code> методы.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_можно_предотвратить_прямой_доступ_к_jsp_странице_из_браузера">Как можно предотвратить прямой доступ к JSP странице из браузера?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Прямой доступ к директории <code>/WEB-INF/</code> из веб-приложения отсутствует. Поэтому JSP-страницы можно расположить внутри этой папки и тем самым запретить доступ к странице из браузера. Однако, по аналогии с описанием сервлетов, будет необходимо настроить дескриптор развертывания:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;Example&lt;/servlet-name&gt;
    &lt;jsp-file&gt;/WEB-INF/example.jsp&lt;/jsp-file&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;exampleParameter&lt;/param-name&gt;
        &lt;param-value&gt;parameterValue&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Example&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/example.jsp&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_разница_между_динамическим_и_статическим_содержимым_jsp">Какая разница между <em>динамическим</em> и <em>статическим</em> содержимым JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Статическое содержимое JSP (HTML, код JavaScript, изображения и т.д.) не изменяется в процессе работы веб приложения.</p>
</div>
<div class="paragraph">
<p>Динамические ресурсы созданы для того, чтобы отображать свое содержимое в зависимости от пользовательских действий. Обычно они представлены в виде выражений EL (Expression Language), библиотек JSP-тегов и пр.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_закомментировать_код_в_jsp">Как закомментировать код в JSP?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>&lt;!—- HTML комментарий; отображается на странице JSP —-&gt;</code> такие комментарии будут видны клиенту при просмотре кода страницы.</p>
</li>
<li>
<p><code>&lt;%—- JSP комментарий; не отображается на странице JSP —-%&gt;</code> такие комментарии описываются в созданном сервлете и не посылаются клиенту. Для любых комментариев по коду или отладочной информации необходимо использовать именно такой тип комментариев.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_основные_типы_тегов_jsp">Какие существуют основные типы тегов JSP?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>Выражение JSP</em>: <code>&lt;%= expression %&gt;</code> - выражение, которое будет обработано с перенаправлением результата на вывод;</p>
</li>
<li>
<p><em>Скриплет JSP</em>: <code>&lt;% code %&gt;</code> - код, добавляемый в метод <code>service()</code>.</p>
</li>
<li>
<p><em>Объявление JSP</em>: <code>&lt;%! code %&gt;</code> - код, добавляемый в тело класса сервлета вне метода <code>service()</code>.</p>
</li>
<li>
<p><em>Директива JSP page</em>: <code>&lt;%@ page att="value" %&gt;</code> - директивы для контейнера сервлетов с информацией о параметрах.</p>
</li>
<li>
<p><em>Директива JSP include</em>: <code>&lt;%@ include file="url" %&gt;</code> - файл в локальной системе, подключаемый при трансляции JSP в сервлет.</p>
</li>
<li>
<p><em>Комментарий JSP</em>: <code>&lt;%-- comment --%&gt;</code> - комментарий; игнорируется при трансляции JSP страницы в сервлет.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_действиях_jsp_action_tag_и_jsp_action_elements">Что вы знаете о действиях JSP (<em>Action tag</em> и <em>JSP Action Elements</em>).</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Action tag</strong> и <strong>JSP Action Elements</strong> предоставляют методы работы с Java Beans, подключения ресурсов, проброса запросов и создания динамических XML элементов. Такие элементы всегда начинаются с записи <code>jsp:</code> и используются непосредственно внутри страницы JSP без необходимости подключения сторонних библиотек или дополнительных настроек.</p>
</div>
<div class="paragraph">
<p>Наиболее часто используемыми JSP Action Elements являются:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jsp:include</code>: <code>&lt;jsp:include page="относительный URL" flush="true"/&gt;</code> - подключить файл при запросе страницы. Если необходимо, чтобы файл подключался в процессе трансляции страницы, то используется директива <code>page</code> совместно с атрибутом <code>include</code>;</p>
</li>
<li>
<p><code>jsp:useBean</code>: <code>&lt;jsp:useBean att=значение*/&gt;</code> или <code>&lt;jsp:useBean att=значение*&gt;...&lt;/jsp:useBean&gt;</code> - найти или создать Java bean;</p>
</li>
<li>
<p><code>jsp:setProperty</code>: <code>&lt;jsp:setProperty att=значение*/&gt;</code> - установить свойства Java bean, или явно, или указанием на соответствующее значение, передаваемое при запросе;</p>
</li>
<li>
<p><code>jsp:forward</code>: <code>&lt;jsp:forward page="относительный URL"/&gt;</code> - передать запрос другой странице;</p>
</li>
<li>
<p><code>jsp:plugin</code>: <code>&lt;jsp:plugin attribute="значение"*&gt;...&lt;/jsp:plugin&gt;</code> - сгенерировать (в зависимости от типа браузера) тэги <code>OBJECT</code> или <code>EMBED</code> для апплета, использующего технологию Java Plugin.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_взаимодействие_jsp_сервлет_jsp">Взаимодействие <em>JSP - сервлет - JSP</em>.</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>«JSP - сервлет - JSP»</em> архитектура построения приложений носит название <em>MVC (Model/View/Controller)</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Model</em> - классы данных и бизнес-логики;</p>
</li>
<li>
<p><em>View</em> - страницы JSP;</p>
</li>
<li>
<p><em>Controller</em> - сервлеты.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_области_видимости_переменных_существуют_в_jsp">Какие области видимости переменных существуют в JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Область видимости объектов определяется тем контекстом, в который помещается данный объект. В зависимости от той или иной области действия так же определяется время существования объекта.</p>
</div>
<div class="paragraph">
<p>В JSP предусмотрены следующие области действия переменных (объектов):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>request</code> область действия запроса - объект будет доступен на текущей JSP странице, странице пересылки (при использовании <code>jsp:forward</code>) или на включаемой странице (при использовании <code>jsp:include</code>);</p>
</li>
<li>
<p><code>session</code> область действия сессии - объект будет помещен в сеанс пользователя, будет доступен на всех JSP страницах и будет существовать пока существует сессия пользователя, или он не будет из нее принудительно удален.</p>
</li>
<li>
<p><code>application</code> область действия приложения - объект будет доступен для всех пользователей на всех JSP страницах и будет существовать на протяжении всей работы приложения или пока не будет удален принудительно и контекста приложения.</p>
</li>
<li>
<p><code>page</code> область действия страницы - объект будет доступен только на той странице, где он определен. На включаемых (<code>jsp:include</code>) и переадресуемых (<code>jsp:forward</code>) страницах данный объект уже не будет доступен.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, чтобы объект был доступен всем JSP страницам, необходимо указать область видимости <code>application</code> или <code>session</code>, в зависимости от того требуется ли доступ к объекту всем пользователям или только текущему.</p>
</div>
<div class="paragraph">
<p>Для указания требуемой области действия при определении объекта на JSP странице используется атрибут scope тега <code>jsp:useBean</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;jsp:useBean id="myBean" class="ru.javacore.MyBean" scope="session"/&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Если не указывать атрибут <code>scope</code>, то по умолчанию задается область видимости страницы <code>page</code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_неявные_внутренние_объекты_и_методы_есть_на_jsp_странице">Какие неявные, внутренние объекты и методы есть на JSP странице?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JSP implicit objects (неявные объекты)</strong> создаются контейнером при конвертации JSP страницы в код сервлета для помощи разработчикам. Эти объекты можно использовать напрямую в скриптлетах для передачи информации в сервис методы, однако мы не можем использовать неявные объекты в JSP Declaration, т.к. такой код пойдет на уровень класса.</p>
</div>
<div class="paragraph">
<p>Существует 9 видов неявных объектов, которые можно использовать прямо на JSP странице. Семь из них объявлены как локальные переменные в начале <code>_jspService()</code> метода, а два оставшихся могут быть использованы как аргументы метода <code>_jspService()</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>out Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;Current Time is&lt;/strong&gt;: &lt;% out.print(new Date()); %&gt;&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>request Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;Request User-Agent&lt;/strong&gt;: &lt;%=request.getHeader("User-Agent") %&gt;&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>response Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;Response&lt;/strong&gt;: &lt;%response.addCookie(new Cookie("Test","Value")); %&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>config Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;User init param value&lt;/strong&gt;: &lt;%=config.getInitParameter("User") %&gt;&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>application Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;User context param value&lt;/strong&gt;: &lt;%=application.getInitParameter("User") %&gt;&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>session Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;User Session ID&lt;/strong&gt;: &lt;%=session.getId() %&gt;&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pageContext Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;% pageContext.setAttribute("Test", "Test Value"); %&gt;
&lt;strong&gt;PageContext attribute&lt;/strong&gt;: {Name="Test",Value="&lt;%=pageContext.getAttribute("Test") %&gt;"}&lt;br&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>page Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;Generated Servlet Name&lt;/strong&gt;: &lt;%=page.getClass().getName() %&gt;</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>exception Object</code> :</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;strong&gt;Exception occured&lt;/strong&gt;: &lt;%=exception %&gt;&lt;br&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_неявные_объекты_не_доступны_в_обычной_jsp_странице">Какие неявные объекты не доступны в обычной JSP странице?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Неявный объект исключений JSP недоступен в обычных JSP страницах и используется на страницах ошибок JSP (<em>errorpage</em>) только для того, чтобы перехватить исключение, выброшенное JSP страницей и далее предоставить какую-либо полезную информацию клиенту.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_pagecontext_и_какие_преимущества_его_использования">Что вы знаете о <code>PageContext</code> и какие преимущества его использования?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Неявный объект JSP - экземпляр класса <code>javax.servlet.jsp.PageContext</code> предоставляет доступ ко всем пространствам имён, ассоциированным с JSP-страницей, а также к различным её атрибутам.
Остальные неявные объекты добавляются к <code>pageContext</code> автоматически.</p>
</div>
<div class="paragraph">
<p>Класс <code>PageContext</code> это абстрактный класс, а его экземпляр можно получить через вызов метода <code>JspFactory.getPageContext()</code>, и освободить через вызов метода <code>JspFactory.releasePageContext()</code>.</p>
</div>
<div class="paragraph">
<p><code>PageContext</code> обладает следующим набором особенностей и возможностей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>единый API для обслуживания пространств имён различных областей видимости;</p>
</li>
<li>
<p>несколько удобных API для доступа к различным <code>public</code>-объектам;</p>
</li>
<li>
<p>механизм получения <code>JspWriter</code> для вывода;</p>
</li>
<li>
<p>механизм обслуживания использования сессии страницей;</p>
</li>
<li>
<p>механизм экспонирования («показа») атрибутов директивы <code>page</code> среде скриптинга;</p>
</li>
<li>
<p>механизмы направления или включения текущего запроса в другие компоненты приложения;</p>
</li>
<li>
<p>механизм обработки процессов исключений на страницах ошибок <em>errorpage</em>;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_сконфигурировать_параметры_инициализации_для_jsp">Как сконфигурировать параметры инициализации для JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Параметры инициализации для JSP задаются в <code>web.xml</code> файле аналогично сервлетам - элементами <code>servlet</code> и <code>servlet-mapping</code>. Единственным отличием будет указание местонахождения JSP страницы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;Example&lt;/servlet-name&gt;
    &lt;jsp-file&gt;/WEB-INF/example.jsp&lt;/jsp-file&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;exampleParameter&lt;/param-name&gt;
        &lt;param-value&gt;parameterValue&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_не_рекомендуется_использовать_скриплеты_скриптовые_элементы_в_jsp">Почему не рекомендуется использовать скриплеты (скриптовые элементы) в JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JSP страницы используются в основном  для целей отображения представления (<em>view</em>), а вся бизнес-логика (<em>controller</em>) и модель (<em>model</em>) должны быть реализованы в сервлетах или классах-моделях. Обязанность JSP страницы - создание HTML ответа из переданных через атрибуты параметров. Большая часть JSP содержит HTML код, а для того, чтобы помочь верстальщикам понять JSP код страницы предоставляется функционал элементов <em>action</em>, <em>JSP EL</em>, <em>JSP Standart Tag Library</em>. Именно их и необходимо использовать вместо скриптлетов для создания моста между (JSP)HTML и (JSP)Java частями.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_определить_класс_внутри_jsp_страницы">Можно ли определить класс внутри JSP страницы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Определить класс внутри JSP страницы можно, но это считается плохой практикой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">&lt;%!
private static class ExampleOne {
  //...
}
%&gt;

&lt;%
private class ExampleTwo {
  //...
}
%&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_языке_выражений_jsp_jsp_expression_languageel">Что вы знаете о Языке выражений JSP (JSP Expression Language&#8201;&#8212;&#8201;EL)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JSP Expression Language (EL)</strong>&#8201;&#8212;&#8201;скриптовый язык выражений, который позволяет получить доступ к Java компонентам (JavaBeans) из JSP. Начиная с JSP 2.0 используется внутри JSP тегов для отделения Java кода от JSP для обеспечения лёгкого доступа к Java компонентам, уменьшая при этом количество кода Java в JSP-страницах, или даже полностью исключая его.</p>
</div>
<div class="paragraph">
<p>Развитие EL происходило с целью сделать его более простым для дизайнеров, которые имеют минимальные познания в языке программирования Java. До появления языка выражений, JSP имел несколько специальных тегов таких как скриптлеты (англ.), выражения и т. п. которые позволяли записывать Java код непосредственно на странице. С использованием языка выражений веб-дизайнер должен знать только то, как организовать вызов соответствующих java-методов.</p>
</div>
<div class="paragraph">
<p>Язык выражений JSP 2.0 включает:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Создание и изменение переменных.</p>
</li>
<li>
<p>Управление потоком выполнения программы: ветвление, выполнение различных типов итераций и т.д.</p>
</li>
<li>
<p>Упрощенное обращение к встроенным JSP-объектам.</p>
</li>
<li>
<p>Возможность создавать собственные функции.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Язык выражений используется внутри конструкции <code>${ ... }</code>. Подобная конструкция может размещаться либо отдельно, либо в правой части выражения установки атрибута тега.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_типы_el_операторов_вы_знаете">Какие типы EL операторов вы знаете?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Операторы в EL поддерживают наиболее часто используемые манипуляции данными.</p>
</div>
<div class="paragraph">
<p>Типы операторов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Стандартные операторы отношения: <code>==</code> (или <code>eq</code>), <code>!=</code> (или <code>neq</code>), <code>&lt;</code> (или <code>lt</code>), <code>&gt;</code> (или <code>gt</code>), <code>&lt;=</code> (или <code>le</code>), <code>&gt;=</code> (или <code>ge</code>).</p>
</li>
<li>
<p>Арифметические операторы: <code>+</code>, <code>–</code>, <code>*</code>, <code>/</code> (или <code>div</code>), <code>%</code> (или <code>mod</code>).</p>
</li>
<li>
<p>Логические операторы: <code>&amp;&amp;</code> (или <code>and</code>), <code>||</code> (или <code>or</code>), <code>!</code> (или <code>not</code>).</p>
</li>
<li>
<p>Оператор <code>empty</code>&#8201;&#8212;&#8201;используется для проверки переменной на <code>null</code>, или «пустое значение», который зависит от типа проверяемого объекта. Например, нулевая длина для строки или нулевой размер для коллекции.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_назовите_неявные_внутренние_объекты_jsp_el_и_их_отличия_от_объектов_jsp">Назовите неявные, внутренние объекты JSP EL и их отличия от объектов JSP.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Язык выражений JSP предоставляет множество неявных объектов, которые можно использовать для получения атрибутов в различных областях видимости (scopes) и для значений параметров. Важно отметить, что они отличаются от неявных объектов JSP и содержат атрибуты в заданной области видимости. Наиболее часто использующийся implicit object в JSP EL и JSP page&#8201;&#8212;&#8201;это объект pageContext. Ниже представлена таблица неявных объектов JSP EL.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_отключить_возможность_использования_el_в_jsp">Как отключить возможность использования EL в JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для игнорирования выполнения языка выражений на странице существует два способа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>использовать директиву <code>&lt;%@ page isELIgnored = «true» %&gt;</code>,</p>
</li>
<li>
<p>настроить <code>web.xml</code> (лучше подходит для отключения EL сразу на нескольких страницах):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jsp-config&gt;
    &lt;jsp-property-group&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
        &lt;el-ignored&gt;true&lt;/el-ignored&gt;
    &lt;/jsp-property-group&gt;
&lt;/jsp-config&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_узнать_тип_http_метода_используя_jsp_el">Как узнать тип HTTP метода используя JSP EL?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>${pageContext.request.method}</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_jstl_jsp_standard_tag_library">Что такое <em>JSTL (JSP Standard tag library)</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JavaServer Pages Standard Tag Library, JSTL, Стандартная библиотека тегов JSP</strong>&#8201;&#8212;&#8201;расширение спецификации JSP (конечный результат <em>JSR 52</em>), добавляющее библиотеку JSP тегов для общих нужд, таких как разбор XML данных, условная обработка, создание циклов и поддержка интернационализации.</p>
</div>
<div class="paragraph">
<p>JSTL является альтернативой такому виду встроенной в JSP логики, как <em>скриплеты</em> (прямые вставки Java кода). Использование стандартизованного множества тегов предпочтительнее, поскольку получаемый код легче поддерживать и проще отделять бизнес-логику от логики отображения.</p>
</div>
<div class="paragraph">
<p>Для использования JSTL тегов необходимо:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>подключить зависимости, например в <code>pom.xml</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;jstl&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>указать пространство имен основных тегов JSTL через указание на JSP странице код:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/sql" prefix="sql" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/xml" prefix="x" %&gt;
&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %&gt;</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_из_каких_групп_тегов_состоит_библиотека_jstl">Из каких групп тегов состоит библиотека <em>JSTL</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Группы тегов JSTL согласно их функциональности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Core Tags</em> предоставляют возможности итерации, обработки исключений, URL, <em>forward</em>, <em>redirect response</em> и т.д.</p>
</li>
<li>
<p><em>Formatting Tags</em> и <em>Localization Tags</em> предоставляют возможности по форматированию чисел, дат и поддержки <em>i18n</em> локализации и <em>resource bundles</em>.</p>
</li>
<li>
<p><em>SQL Tags</em>&#8201;&#8212;&#8201;поддержка работы с базами данных.</p>
</li>
<li>
<p><em>XML Tags</em> используются для работы с XML документами: парсинга, преобразования данных, выполнения выражений <em>XPath</em> и т.д..</p>
</li>
<li>
<p><em>JSTL Functions Tags</em> предоставляет набор функций, которые позволяют выполнять различные операции со строками и т.п. Например, по конкатенации или разбиению строк.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_разница_между_cset_и_jspusebean">Какая разница между <code>&lt;c:set&gt;</code> и <code>&lt;jsp:useBean&gt;</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оба тега создают и помещают экземпляры в заданную область видимости, но <code>&lt;jsp:useBean&gt;</code> только создаёт экземпляр конкретного типа, а <code>&lt;c:set&gt;</code>, создав экземпляр, позволяет дополнительно извлекать значение, например, из параметров запроса, сессии и т. д.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличается_cimport_от_jspinclude_и_директивы_include">Чем отличается <code>&lt;c:import&gt;</code> от <code>&lt;jsp:include&gt;</code> и директивы <code>&lt;%@include %&gt;</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>По сравнению с action-тегом <code>&lt;jsp:include&gt;</code> и директивой <code>&lt;%@include %&gt;</code> тег <code>&lt;c:import&gt;</code> обеспечивает более совершенное включение динамических ресурсов, т.к. получает доступ к источнику, чтение информации из которого происходит непосредственно без буферизации и контент включается в исходную JSP построчно.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_можно_расширить_функциональность_jsp">Как можно расширить функциональность JSP?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_написании_пользовательских_jsp_тегов">Что вы знаете о написании пользовательских JSP тегов?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_приведите_пример_использования_собственных_тегов">Приведите пример использования собственных тегов.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JSP можно расширить с помощью создания собственных тегов с необходимой функциональностью, которые можно добавить в библиотеку тегов на страницу JSP указав необходимое пространство имен.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>/WEB-INF/exampleTag.tld</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;taglib version="2.1" xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_1.xsd"&gt;
    &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;
    &lt;short-name&gt;example&lt;/short-name&gt;
    &lt;uri&gt;/WEB-INF/exampleTag&lt;/uri&gt;
    &lt;tag&gt;
        &lt;name&gt;exampleTag&lt;/name&gt;
        &lt;tag-class&gt;xyz.company.ExampleTag&lt;/tag-class&gt;
        &lt;body-content&gt;empty&lt;/body-content&gt;
        &lt;info&gt;The example tag displays Hello World!&lt;/info&gt;
    &lt;/tag&gt;
&lt;/taglib&gt;</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>xyz.company.ExampleServlet.java</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package xyz.company;

import java.io.IOException;

import javax.servlet.jsp.JspException;
import javax.servlet.jsp.tagext.TagSupport;

public class ExampleTag extends TagSupport{
    private static final long serialVersionUID = 1L;

    @Override
    public int doStartTag() throws JspException {
        try {
            pageContext.getOut().print("Hello World!");
        } catch(IOException ioException) {
            throw new JspException("Error: " + ioException.getMessage());
        }
        return SKIP_BODY;
    }
}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>exampleTag.jsp</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;%@ taglib uri="/WEB-INF/exampleTag.tld" prefix="example"%&gt;
&lt;%@ page session="false" pageEncoding="UTF-8"%&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Example Tag&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Example Tag&lt;/h1&gt;
    &lt;p&gt;&lt;example:exampleTage /&gt;&lt;p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Также в пользовательских тегах существует возможность задать входные параметры. Например, существует необходимость отформатировать каким-либо стилем очень длинное число. Для этого можно использовать собственный тег по типу:</p>
</div>
<div class="paragraph">
<p><code>&lt;mytags:formatNumber number="123456.789" format="<mark>,</mark># #.00"/&gt;</code></p>
</div>
<div class="paragraph">
<p>Используя входные параметры, число должно быть преобразовано на JSP странице в таком виде <code>123,456.79</code> согласно шаблону. Т.к. JSTL не предоставляет такой функциональности, необходимо создать пользовательский тег для получения необходимого результата.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_сделать_перенос_строки_в_html_средствами_jsp">Как сделать перенос строки в HTML средствами JSP?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для переноса строки можно использовать тег <code>c:out</code> и атрибут <code>escapeXml</code>, который отключает обработку HTML элементов. В этом случае браузер получит следующий код в виде строки и обработает элемент <code>&lt;br&gt;</code> как требуется:</p>
</div>
<div class="paragraph">
<p><code>&lt;c:out value="&lt;br&gt; creates a new line in HTML" escapeXml="true"&gt;&lt;/c:out&gt;</code></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_не_нужно_конфигурировать_стандартные_jsp_теги_в_web_xml">Почему не нужно конфигурировать стандартные JSP теги в <code>web.xml</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Стандартные теги JSP не конфигурируются в <code>web.xml</code>, потому что tld файлы уже находятся внутри каталога <code>/META-INF/</code> в jar файлах JSTL.</p>
</div>
<div class="paragraph">
<p>Когда контейнер загружает веб-приложение и находит tld файлы в в jar файле в директории <code>/META-INF/</code>, то он автоматически настраивает их для непосредственного использования на JSP страницах. Остается только задать пространство имен на JSP странице.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_можно_обработать_ошибки_jsp_страниц">Как можно обработать ошибки JSP страниц?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для обработки исключений выброшенных на JSP странице достаточно лишь задать страницу ошибки JSP и при её создании установить значение <em>page directive attribute</em> <code>isErrorPage</code> в значение <code>true</code>. Таким образом будет предоставлен доступ к неявным объектам исключений в JSP и появится возможность передавать собственные, более информативные сообщения об ошибках клиенту. При этом настройка дескриптора развертывания выглядит так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;error-page&gt;
     &lt;error-code&gt;404&lt;/error-code&gt;
     &lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;

&lt;error-page&gt;
     &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
     &lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_происходит_обработка_ошибок_с_помощью_jstl">Как происходит обработка ошибок с помощью JSTL?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для перехвата и обработки исключений в служебных методах класса служат JSTL Core Tags <code>c:catch</code> и <code>c:if</code>.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Тег <code>c:catch</code> перехватывает исключение и обертывает его в переменную <code>exception</code>, доступную для обработки в теге <code>c:if</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>____+++&lt;c:catch var="exception"&gt;+++&lt;% int x = 42/0;%&gt;+++&lt;/c:catch&gt;++++++&lt;c:if test="${exception ne null}"&gt;+++Exception is : $\{exception} +
Exception Message: ${exception.message}+++&lt;/c:if&gt;+++

----

Обратите внимание что используется язык выражений JSP EL в теге `c:if`.

[к оглавлению](#servlets-jsp-jstl)

## Как конфигурируется JSP в дескрипторе развертывания.
Для настройки различных параметров JSP страниц используется элемент `jsp-config`, который отвечает за:

+ управление элементами скриптлетов на странице;
+ управления выполнением в языке выражений;
+ определение шаблона URL для encoding;
+ определение размера буфера, который используется для объектов на странице;
+ обозначение групп ресурсов, соответствующих шаблону URL, которые должны быть обработаны как XML документ.

```xml
&lt;jsp-config&gt;
    &lt;taglib&gt;
        &lt;taglib-uri&gt;http://company.xyz/jsp/tlds/customtags&lt;/taglib-uri&gt;
        &lt;taglib-location&gt;/WEB-INF/exampleTag.tld&lt;/taglib-location&gt;
    &lt;/taglib&gt;
&lt;/jsp-config&gt;
----

== Можно ли использовать Javascript на JSP странице?

Да, это возможно. Несмотря на то, что JSP это серверная технология, на выходе она всё равно создает `HTML` страницу, на которую можно добавлять Javascript и CSS.

== Всегда ли создается объект сессии на JSP странице, можно ли отключить его создание?

Jsp-страница, по умолчанию, всегда создает сессию. Используя директиву `page` с атрибутом `session` можно изменить это поведение:

`&lt;%@ page session ="false" %&gt;`

== Какая разница между `JSPWriter` и сервлетным `PrintWriter`?

`PrintWriter` является объектом отвечающим за запись содержания ответа на запрос. `JspWriter` использует объект `PrintWriter` для буферизации. Когда буфер заполняется или сбрасывается, `JspWriter` использует объект `PrintWriter` для записи содержания в ответ.

== Опишите общие практические принципы работы с JSP.

Хорошей практикой работы с технологией JSP является соблюдение следующих правил:

* Следует избегать использования элементов скриптлетов на странице. Если элементы _action_, _JSTL_, _JSP EL_ не удовлетворяют потребностям, то желательно написать собственный тег.
* Рекомендуется использовать разные виды комментариев: так JSP комментарии необходимы для уровня кода и отладки, т.к. они не будут показаны клиенту.
* Не стоит размещать какой-либо бизнес логики внутри JSP страницы. Страницы должны использоваться только для создания ответов клиенту.
* Для повышения производительности лучше отключать создание сессии на странице, когда это не требуется.
* Директивы `taglib`, `page` в начале JSP страницы улучшают читабельность кода.
* Следует правильно использовать директиву `include` и элемент `jsp:include action`. Первая используется для статических ресурсов, а второй для динамических ресурсов времени выполнения.
* Обработку исключений нужно производить с помощью страниц ошибок. Это помогает избегать запуска специальных служебных методов и может повысить производительность.
* Использующиеся CSS и JavaScript должны быть разнесены в разные файлы и подключаться в начале страницы.
* В большинстве случаев JSTL должно хватать для всех нужд. Если это не так, то в начале следует проанализировать логику своего приложения, и попробовать перенести выполнения кода в сервлет, а далее с помощью установки атрибутов использовать на JSP странице только результат.

== Источники

* http://javastudy.ru/interview/jee-servlet-api-questions/[javastudy.ru]
* http://www.java2ee.ru/servlets/[java2ee.ru]
* http://java-online.ru/jsp-questions.xhtml[Java-online]
* http://www.codenet.ru/webmast/java/jsp.php[Codenet]
* https://articles.javatalks.ru/articles/24[JavaTalks Articles]

xref:README.adoc[Вопросы для собеседования]</code></pre>
</div>
</div>
</blockquote>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-08-21 04:05:09 UTC
</div>
</div>
</body>
</html>