<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<title>Java Core</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="README.html">Вопросы для собеседования</a></p>
</div>
</div>
</div>
<h1 id="_java_core" class="sect0">Java Core</h1>
<div class="openblock partintro">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><a href="#Чем-различаются-jre-jvm-и-jdk">Чем различаются JRE, JVM и JDK?</a></p>
</li>
<li>
<p><a href="#Какие-существуют-модификаторы-доступа">Какие существуют модификаторы доступа?</a></p>
</li>
<li>
<p><a href="#О-чем-говорит-ключевое-слово-final">О чем говорит ключевое слово <code>final</code>?</a></p>
</li>
<li>
<p><a href="#Какими-значениями-инициализируются-переменные-по-умолчанию">Какими значениями инициализируются переменные по умолчанию?</a></p>
</li>
<li>
<p><a href="#Что-вы-знаете-о-функции-main">Что вы знаете о функции <code>main()</code>?</a></p>
</li>
<li>
<p><a href="#Какие-логические-операции-и-операторы-вы-знаете">Какие логические операции и операторы вы знаете?</a></p>
</li>
<li>
<p><a href="#Что-такое-тернарный-оператор-выбора">Что такое тернарный оператор выбора?</a></p>
</li>
<li>
<p><a href="#Какие-побитовые-операции-вы-знаете">Какие побитовые операции вы знаете?</a></p>
</li>
<li>
<p><a href="#Где-и-для-чего-используется-модификатор-abstract">Где и для чего используется модификатор <code>abstract</code>?</a></p>
</li>
<li>
<p><a href="#Дайте-определение-понятию-интерфейс-Какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов">Дайте определение понятию <em>«интерфейс»</em>. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</a></p>
</li>
<li>
<p><a href="#Чем-абстрактный-класс-отличается-от-интерфейса-В-каких-случаях-следует-использовать-абстрактный-класс-а-в-каких-интерфейс">Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?</a></p>
</li>
<li>
<p><a href="#Почему-в-некоторых-интерфейсах-вообще-не-определяют-методов">Почему в некоторых интерфейсах вообще не определяют методов?</a></p>
</li>
<li>
<p><a href="#Почему-нельзя-объявить-метод-интерфейса-с-модификатором-final">Почему нельзя объявить метод интерфейса с модификатором <code>final</code>?</a></p>
</li>
<li>
<p><a href="#Что-имеет-более-высокий-уровень-абстракции---класс-абстрактный-класс-или-интерфейс">Что имеет более высокий уровень абстракции - <em>класс</em>, <em>абстрактный класс</em> или <em>интерфейс</em>?</a></p>
</li>
<li>
<p><a href="#Может-ли-объект-получить-доступ-к-члену-класса-объявленному-как-private-Если-да-то-каким-образом">Может ли объект получить доступ к члену класса, объявленному как <code>private</code>? Если да, то каким образом?</a></p>
</li>
<li>
<p><a href="#Каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов">Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</a></p>
</li>
<li>
<p><a href="#Зачем-нужны-и-какие-бывают-блоки-инициализации">Зачем нужны и какие бывают блоки инициализации?</a></p>
</li>
<li>
<p><a href="#К-каким-конструкциям-java-применим-модификатор-static">К каким конструкциям Java применим модификатор <code>static</code>?</a></p>
</li>
<li>
<p><a href="#Для-чего-в-java-используются-статические-блоки-инициализации">Для чего в Java используются статические блоки инициализации?</a></p>
</li>
<li>
<p><a href="#Что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация">Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?</a></p>
</li>
<li>
<p><a href="#Какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса">Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</a></p>
</li>
<li>
<p><a href="#Может-ли-статический-метод-быть-переопределён-или-перегружен">Может ли статический метод быть переопределён или перегружен?</a></p>
</li>
<li>
<p><a href="#Могут-ли-нестатические-методы-перегрузить-статические">Могут ли нестатические методы перегрузить статические?</a></p>
</li>
<li>
<p><a href="#Можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода">Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</a></p>
</li>
<li>
<p><a href="#Возможно-ли-при-переопределении-метода-изменить-модификатор-доступа-возвращаемый-тип-тип-аргумента-или-их-количество-имена-аргументов-или-их-порядок-убирать-добавлять-изменять-порядок-следования-элементов-секции-throws">Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции <code>throws</code>?</a></p>
</li>
<li>
<p><a href="#Как-получить-доступ-к-переопределенным-методам-родительского-класса">Как получить доступ к переопределенным методам родительского класса?</a></p>
</li>
<li>
<p><a href="#Можно-ли-объявить-метод-абстрактным-и-статическим-одновременно">Можно ли объявить метод абстрактным и статическим одновременно?</a></p>
</li>
<li>
<p><a href="#В-чем-разница-между-членом-экземпляра-класса-и-статическим-членом-класса">В чем разница между членом экземпляра класса и статическим членом класса?</a></p>
</li>
<li>
<p><a href="#Где-разрешена-инициализация-статическихнестатических-полей">Где разрешена инициализация статических/нестатических полей?</a></p>
</li>
<li>
<p><a href="#Какие-типы-классов-бывают-в-java">Какие типы классов бывают в java?</a></p>
</li>
<li>
<p><a href="#Расскажите-про-вложенные-классы-В-каких-случаях-они-применяются">Расскажите про вложенные классы. В каких случаях они применяются?</a></p>
</li>
<li>
<p><a href="#Что-такое-статический-класс">Что такое <em>«статический класс»</em>?</a></p>
</li>
<li>
<p><a href="#Какие-существуют-особенности-использования-вложенных-классов-статических-и-внутренних-В-чем-заключается-разница-между-ними">Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?</a></p>
</li>
<li>
<p><a href="#Что-такое-локальный-класс-Каковы-его-особенности">Что такое <em>«локальный класс»</em>? Каковы его особенности?</a></p>
</li>
<li>
<p><a href="#Что-такое-анонимные-классы-Где-они-применяются">Что такое <em>«анонимные классы»</em>? Где они применяются?</a></p>
</li>
<li>
<p><a href="#Каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса">Каким образом из вложенного класса получить доступ к полю внешнего класса?</a></p>
</li>
<li>
<p><a href="#Для-чего-используется-оператор-assert">Для чего используется оператор <code>assert</code>?</a></p>
</li>
<li>
<p><a href="#Что-такое-heap-и-stack-память-в-java-Какая-разница-между-ними">Что такое <em>Heap</em> и <em>Stack</em> память в Java? Какая разница между ними?</a></p>
</li>
<li>
<p><a href="#Верно-ли-утверждение-что-примитивные-типы-данных-всегда-хранятся-в-стеке-а-экземпляры-ссылочных-типов-данных-в-куче">Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?</a></p>
</li>
<li>
<p><a href="#Каким-образом-передаются-переменные-в-методы-по-значению-или-по-ссылке">Каким образом передаются переменные в методы, по значению или по ссылке?</a></p>
</li>
<li>
<p><a href="#Для-чего-нужен-сборщик-мусора">Для чего нужен сборщик мусора?</a></p>
</li>
<li>
<p><a href="#Как-работает-сборщик-мусора">Как работает сборщик мусора?</a></p>
</li>
<li>
<p><a href="#Какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot">Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?</a></p>
</li>
<li>
<p><a href="#Опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot">Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.</a></p>
</li>
<li>
<p><a href="#Что-такое-пул-строк">Что такое «пул строк»?</a></p>
</li>
<li>
<p><a href="#Что-такое-finalize-Зачем-он-нужен">Что такое <code>finalize()</code>? Зачем он нужен?</a></p>
</li>
<li>
<p><a href="#Что-произойдет-со-сборщиком-мусора-если-выполнение-метода-finalize-требует-ощутимо-много-времени-или-в-процессе-выполнения-будет-выброшено-исключение">Что произойдет со сборщиком мусора, если выполнение метода <code>finalize()</code> требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?</a></p>
</li>
<li>
<p><a href="#Чем-отличаются-final-finally-и-finalize">Чем отличаются <code>final</code>, <code>finally</code> и <code>finalize()</code>?</a></p>
</li>
<li>
<p><a href="#Расскажите-про-приведение-типов-Что-такое-понижение-и-повышение-типа">Расскажите про приведение типов. Что такое понижение и повышение типа?</a></p>
</li>
<li>
<p><a href="#Когда-в-приложении-может-быть-выброшено-исключение-classcastexception">Когда в приложении может быть выброшено исключение <code>ClassCastException</code>?</a></p>
</li>
<li>
<p><a href="#Что-такое-литералы">Что такое литералы?</a></p>
</li>
<li>
<p><a href="#Что-такое-autoboxing-автоупаковка-в-java-и-каковы-правила-упаковки-примитивных-типов-в-классы-обертки">Что такое <em>autoboxing («автоупаковка»)</em> в Java и каковы правила упаковки примитивных типов в классы-обертки?</a></p>
</li>
<li>
<p><a href="#Какие-есть-особенности-класса-string">Какие есть особенности класса <code>String</code>?</a></p>
</li>
<li>
<p><a href="#Почему-string-неизменяемый-и-финализированный-класс">Почему <code>String</code> неизменяемый и финализированный класс?</a></p>
</li>
<li>
<p><a href="#Почему-char-предпочтительнее-string-для-хранения-пароля">Почему <code>char[]</code> предпочтительнее <code>String</code> для хранения пароля?</a></p>
</li>
<li>
<p><a href="#Почему-строка-является-популярным-ключом-в-hashmap-в-java">Почему строка является популярным ключом в <code>HashMap</code> в Java?</a></p>
</li>
<li>
<p><a href="#Что-делает-метод-intern-в-классе-string">Что делает метод <code>intern()</code> в классе <code>String</code>?.</a></p>
</li>
<li>
<p><a href="#Можно-ли-использовать-строки-в-конструкции-switch">Можно ли использовать строки в конструкции <code>switch</code>?</a></p>
</li>
<li>
<p><a href="#Какая-основная-разница-между-string-stringbuffer-stringbuilder">Какая основная разница между <code>String</code>, <code>StringBuffer</code>, <code>StringBuilder</code>?</a></p>
</li>
<li>
<p><a href="#Что-такое-класс-object-Какие-в-нем-есть-методы">Что такое класс <code>Object</code>? Какие в нем есть методы?</a></p>
</li>
<li>
<p><a href="#Дайте-определение-понятию-конструктор">Дайте определение понятию «конструктор».</a></p>
</li>
<li>
<p><a href="#Что-такое-конструктор-по-умолчанию">Что такое <em>«конструктор по умолчанию»</em>?</a></p>
</li>
<li>
<p><a href="#Чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами">Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?</a></p>
</li>
<li>
<p><a href="#Где-и-как-вы-можете-использовать-приватный-конструктор">Где и как вы можете использовать приватный конструктор?</a></p>
</li>
<li>
<p><a href="#Расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов">Расскажите про классы-загрузчики и про динамическую загрузку классов.</a></p>
</li>
<li>
<p><a href="#Что-такое-reflection">Что такое <em>Reflection</em>?</a></p>
</li>
<li>
<p><a href="#Зачем-нужен-equals-Чем-он-отличается-от-операции-">Зачем нужен <code>equals()</code>. Чем он отличается от операции <code>==</code>?</a></p>
</li>
<li>
<p><a href="#Если-вы-хотите-переопределить-equals-какие-условия-должны-выполняться">Если вы хотите переопределить <code>equals()</code>, какие условия должны выполняться?</a></p>
</li>
<li>
<p><a href="#Какими-свойствами-обладает-порождаемое-equals-отношение-эквивалентности">Какими свойствами обладает порождаемое <code>equals()</code> отношение эквивалентности?</a></p>
</li>
<li>
<p><a href="#Правила-переопределения-метода-objectequals">Правила переопределения метода <code>Object.equals()</code>.</a></p>
</li>
<li>
<p><a href="#Какая-связь-между-hashcode-и-equals">Какая связь между <code>hashCode()</code> и <code>equals()</code>?</a></p>
</li>
<li>
<p><a href="#Если-equals-переопределен-есть-ли-какие-либо-другие-методы-которые-следует-переопределить">Если <code>equals()</code> переопределен, есть ли какие-либо другие методы, которые следует переопределить?</a></p>
</li>
<li>
<p><a href="#Что-будет-если-переопределить-equals-не-переопределяя-hashcode-Какие-могут-возникнуть-проблемы">Что будет, если переопределить <code>equals()</code> не переопределяя <code>hashCode()</code>? Какие могут возникнуть проблемы?</a></p>
</li>
<li>
<p><a href="#Каким-образом-реализованы-методы-hashcode-и-equals-в-классе-object">Каким образом реализованы методы <code>hashCode()</code> и <code>equals()</code> в классе <code>Object</code>?</a></p>
</li>
<li>
<p><a href="#Для-чего-нужен-метод-hashcode">Для чего нужен метод <code>hashCode()</code>?</a></p>
</li>
<li>
<p><a href="#Каковы-правила-переопределения-метода-objecthashcode">Каковы правила переопределения метода <code>Object.hashCode()</code>?</a></p>
</li>
<li>
<p><a href="#Есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode">Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете <code>hashCode()</code>?</a></p>
</li>
<li>
<p><a href="#Могут-ли-у-разных-объектов-быть-одинаковые-hashcode">Могут ли у разных объектов быть одинаковые <code>hashCode()</code>?</a></p>
</li>
<li>
<p><a href="Если-у-класса-pointint-x-y-реализовать-метод-equalsobject-that-return-thisx&.html#8212;&#8203;thatx&#8212;&#8203;thisy&#8212;&#8203;thaty-но-сделать-хэш-код-в-виде-int-hashcode-return-x-то-будут-ли-корректно-такие-точки-помещаться-и-извлекаться-из-hashset">Если у класса <code>Point{int x, y;}</code> реализовать метод <code>equals(Object that) {(return this.x == that.x &amp;&amp; this.y == that.y)}</code>, но сделать хэш код в виде <code>int hashCode() {return x;}</code>, то будут ли корректно такие точки помещаться и извлекаться из <code>HashSet</code>?</a></p>
</li>
<li>
<p><a href="Могут-ли-у-разных-объектов-ref0&.html#8212;&#8203;ref1-быть-ref0equalsref1&#8212;&#8203;true">Могут ли у разных объектов <code>(ref0 != ref1)</code> быть <code>ref0.equals(ref1) == true</code>?</a></p>
</li>
<li>
<p><a href="Могут-ли-у-разных-ссылок-на-один-объект-ref0&.html#8212;&#8203;ref1-быть-ref0equalsref1&#8212;&#8203;false">Могут ли у разных ссылок на один объект <code>(ref0 == ref1)</code> быть <code>ref0.equals(ref1) == false</code>?</a></p>
</li>
<li>
<p><a href="Можно-ли-так-реализовать-метод-equalsobject-that-return-thishashcode&.html#8212;&#8203;thathashcode">Можно ли так реализовать метод <code>equals(Object that) {return this.hashCode() == that.hashCode()}</code>?</a></p>
</li>
<li>
<p><a href="В-equals-требуется-проверять-что-аргумент-equalsobject-that-такого-же-типа-что-и-сам-объект-В-чем-разница-между-thisgetclass&.html#8212;&#8203;thatgetclass-и-that-instanceof-myclass">В <code>equals()</code> требуется проверять, что аргумент <code>equals(Object that)</code> такого же типа что и сам объект. В чем разница между <code>this.getClass() == that.getClass()</code> и <code>that instanceof MyClass</code>?</a></p>
</li>
<li>
<p><a href="Можно-ли-реализовать-метод-equals-класса-myclass-вот-так-class-myclass-public-boolean-equalsmyclass-that-return-this&.html#8212;&#8203;that">Можно ли реализовать метод <code>equals()</code> класса <code>MyClass</code> вот так: <code>class MyClass {public boolean equals(MyClass that) {return this == that;}}</code>?</a></p>
</li>
<li>
<p><a href="Есть-класс-pointint-x-y-Почему-хэш-код-в-виде-31&.html#8212;&#8203;x&#8212;&#8203;y-предпочтительнее-чем-x&#8212;&#8203;y">Есть класс <code>Point{int x, y;}</code>. Почему хэш код в виде <code>31 * x + y</code> предпочтительнее чем <code>x + y</code>?</a></p>
</li>
<li>
<p><a href="#Расскажите-про-клонирование-объектов">Расскажите про клонирование объектов.</a></p>
</li>
<li>
<p><a href="#В-чем-отличие-между-поверхностным-и-глубоким-клонированием">В чем отличие между <em>поверхностным</em> и <em>глубоким</em> клонированием?</a></p>
</li>
<li>
<p><a href="#Какой-способ-клонирования-предпочтительней">Какой способ клонирования предпочтительней?</a></p>
</li>
<li>
<p><a href="#Почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable">Почему метод <code>clone()</code> объявлен в классе <code>Object</code>, а не в интерфейсе <code>Cloneable</code>?</a></p>
</li>
<li>
<p><a href="#Опишите-иерархию-исключений">Опишите иерархию исключений.</a></p>
</li>
<li>
<p><a href="#Какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются">Какие виды исключений в Java вы знаете, чем они отличаются?</a></p>
</li>
<li>
<p><a href="#Что-такое-checked-и-unchecked-exception">Что такое <em>checked</em> и <em>unchecked exception</em>?</a></p>
</li>
<li>
<p><a href="#Какой-оператор-позволяет-принудительно-выбросить-исключение">Какой оператор позволяет принудительно выбросить исключение?</a></p>
</li>
<li>
<p><a href="#О-чем-говорит-ключевое-слово-throws">О чем говорит ключевое слово <code>throws</code>?</a></p>
</li>
<li>
<p><a href="#Как-написать-собственное-пользовательское-исключение">Как написать собственное («пользовательское») исключение?</a></p>
</li>
<li>
<p><a href="#Какие-существуют-unchecked-exception">Какие существуют <em>unchecked exception</em>?</a></p>
</li>
<li>
<p><a href="#Что-представляет-из-себя-ошибки-класса-error">Что представляет из себя ошибки класса <code>Error</code>?</a></p>
</li>
<li>
<p><a href="#Что-вы-знаете-о-outofmemoryerror">Что вы знаете о <code>OutOfMemoryError</code>?</a></p>
</li>
<li>
<p><a href="#Опишите-работу-блока-try-catch-finally">Опишите работу блока <em>try-catch-finally</em>.</a></p>
</li>
<li>
<p><a href="#Что-такое-механизм-try-with-resources">Что такое механизм <em>try-with-resources</em>?</a></p>
</li>
<li>
<p><a href="#Возможно-ли-использование-блока-try-finally-без-catch">Возможно ли использование блока <em>try-finally</em> (без <code>catch</code>)?</a></p>
</li>
<li>
<p><a href="#Может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений">Может ли один блок <code>catch</code> отлавливать сразу несколько исключений?</a></p>
</li>
<li>
<p><a href="#Всегда-ли-исполняется-блок-finally">Всегда ли исполняется блок <code>finally</code>?</a></p>
</li>
<li>
<p><a href="#Существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен">Существуют ли ситуации, когда блок <code>finally</code> не будет выполнен?</a></p>
</li>
<li>
<p><a href="#Может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения">Может ли метод <em>main()</em> выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</a></p>
</li>
<li>
<p><a href="#Предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-Сколько-блоков-catch-будет-выполнено">Предположим, есть метод, который может выбросить <code>IOException</code> и <code>FileNotFoundException</code> в какой последовательности должны идти блоки <code>catch</code>? Сколько блоков <code>catch</code> будет выполнено?</a></p>
</li>
<li>
<p><a href="#Что-такое-generics">Что такое <em>generics</em>?</a></p>
</li>
<li>
<p><a href="#Что-такое-интернационализация-локализация">Что такое <em>«интернационализация»</em>, <em>«локализация»</em>?</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_различаются_jre_jvm_и_jdk">Чем различаются JRE, JVM и JDK?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>JVM</strong>, Java Virtual Machine (Виртуальная машина Java)&#8201;&#8212;&#8201;основная часть среды времени исполнения Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.</p>
</div>
<div class="paragraph">
<p><strong>JRE</strong>, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.</p>
</div>
<div class="paragraph">
<p><strong>JDK</strong>, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.</p>
</div>
<div class="paragraph">
<p>Коротко: <strong>JDK</strong> - среда для разработки программ на Java, включающая в себя <strong>JRE</strong> - среду для обеспечения запуска Java программ, которая в свою очередь содержит <strong>JVM</strong> - интерпретатор кода Java программ.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_модификаторы_доступа">Какие существуют модификаторы доступа?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>private</strong> (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово <code>private</code>.</p>
</div>
<div class="paragraph">
<p><strong>default</strong>, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное
обозначение не требуется.</p>
</div>
<div class="paragraph">
<p><strong>protected</strong> (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово <code>protected</code>.</p>
</div>
<div class="paragraph">
<p><strong>public</strong> (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.</p>
</div>
<div class="paragraph">
<p>Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия <em>принципу подстановки Барбары Лисков</em>).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_о_чем_говорит_ключевое_слово_final">О чем говорит ключевое слово <code>final</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Модификатор <code>final</code> может применяться к переменным, параметрам методов, полям и методам класса или самим классам.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Класс не может иметь наследников;</p>
</li>
<li>
<p>Метод не может быть переопределен в классах наследниках;</p>
</li>
<li>
<p>Поле не может изменить свое значение после инициализации;</p>
</li>
<li>
<p>Параметры методов не могут изменять своё значение внутри метода;</p>
</li>
<li>
<p>Локальные переменные не могут быть изменены после присвоения им значения.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какими_значениями_инициализируются_переменные_по_умолчанию">Какими значениями инициализируются переменные по умолчанию?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Числа инициализируются <code>0</code> или <code>0.0</code>;</p>
</li>
<li>
<p><code>char</code>&#8201;&#8212;&#8201;<code>\u0000</code>;</p>
</li>
<li>
<p><code>boolean</code>&#8201;&#8212;&#8201;<code>false</code>;</p>
</li>
<li>
<p>Объекты (в том числе <code>String</code>)&#8201;&#8212;&#8201;<code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_функции_main">Что вы знаете о функции <code>main()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>main()</code>&#8201;&#8212;&#8201;точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка <em>`Error: Main method not found`</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_логические_операции_и_операторы_вы_знаете">Какие логические операции и операторы вы знаете?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>&amp;</code>: Логическое <em>AND</em> (И);</p>
</li>
<li>
<p><code>&amp;&amp;</code>: Сокращённое <em>AND</em>;</p>
</li>
<li>
<p><code>|</code>: Логическое <em>OR</em> (ИЛИ);</p>
</li>
<li>
<p><code>||</code>: Сокращённое <em>OR</em>;</p>
</li>
<li>
<p><code>^</code>: Логическое <em>XOR</em> (исключающее <em>OR</em> (ИЛИ));</p>
</li>
<li>
<p><code>!</code>: Логическое унарное <em>NOT</em> (НЕ);</p>
</li>
<li>
<p><code>&amp;=</code>: <em>AND</em> с присваиванием;</p>
</li>
<li>
<p><code>|=</code>: <em>OR</em> с присваиванием;</p>
</li>
<li>
<p><code>^=</code>: <em>XOR</em> с присваиванием;</p>
</li>
<li>
<p><code>==</code>: Равно;</p>
</li>
<li>
<p><code>!=</code>: Не равно;</p>
</li>
<li>
<p><code>?:</code>: Тернарный (троичный) условный оператор.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_тернарный_оператор_выбора">Что такое тернарный оператор выбора?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Тернарный условный оператор <code>?:</code> - оператор, которым можно заменить некоторые конструкции операторов <code>if-then-else</code>.</p>
</div>
<div class="paragraph">
<p>Выражение записывается в следующей форме:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>условие ? выражение1 : выражение2</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Если <code>условие</code> выполняется, то вычисляется <code>выражение1</code> и его результат становится результатом выполнения всего оператора. Если же <code>условие</code> равно <code>false</code>, то вычисляется <code>выражение2</code> и его значение становится результатом работы оператора. Оба операнда <code>выражение1</code> и <code>выражение2</code> должны возвращать значение одинакового (или совместимого) типа.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_побитовые_операции_вы_знаете">Какие побитовые операции вы знаете?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>~</code>: Побитовый унарный оператор NOT;</p>
</li>
<li>
<p><code>&amp;</code>: Побитовый AND;</p>
</li>
<li>
<p><code>&amp;=</code>: Побитовый AND с присваиванием;</p>
</li>
<li>
<p><code>|</code>: Побитовый OR;</p>
</li>
<li>
<p><code>|=</code>: Побитовый OR с присваиванием;</p>
</li>
<li>
<p><code>^</code>: Побитовый исключающее XOR;</p>
</li>
<li>
<p><code>^=</code>: Побитовый исключающее XOR с присваиванием;</p>
</li>
<li>
<p><code>&gt;&gt;</code>: Сдвиг вправо (деление на 2 в степени сдвига);</p>
</li>
<li>
<p><code>&gt;&gt;=</code>: Сдвиг вправо с присваиванием;</p>
</li>
<li>
<p><code>&gt;&gt;&gt;</code>: Сдвиг вправо без учёта знака;</p>
</li>
<li>
<p><code>&gt;&gt;&gt;=</code>: Сдвиг вправо без учёта знака с присваиванием;</p>
</li>
<li>
<p><code>&lt;&lt;</code>: Сдвиг влево (умножение на 2 в степени сдвига);</p>
</li>
<li>
<p><code>&lt;&lt;=</code>: Сдвиг влево с присваиванием.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_где_и_для_чего_используется_модификатор_abstract">Где и для чего используется модификатор <code>abstract</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс, помеченный модификатором <code>abstract</code>, называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.</p>
</div>
<div class="paragraph">
<p>Метод, помеченный ключевым словом <code>abstract</code> - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.</p>
</div>
<div class="paragraph">
<p>Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_дайте_определение_понятию_интерфейс_какие_модификаторы_по_умолчанию_имеют_поля_и_методы_интерфейсов">Дайте определение понятию <em>«интерфейс»</em>. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ключевое слово <code>interface</code> используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как <code>public</code>.</p>
</div>
<div class="paragraph">
<p>Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию <code>default</code> и статических <code>static</code> методов.</p>
</div>
<div class="paragraph">
<p>Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными <code>public</code>, статическими <code>static</code> и неизменяемыми <code>final</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_абстрактный_класс_отличается_от_интерфейса_в_каких_случаях_следует_использовать_абстрактный_класс_а_в_каких_интерфейс">Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</p>
</li>
<li>
<p>Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</p>
</li>
<li>
<p>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как <code>public abstract</code> или (начиная с Java 8) <code>default</code> - методами с реализацией по-умолчанию, а поля - <code>public static final</code>.</p>
</li>
<li>
<p>Интерфейсы позволяют создавать структуры типов без иерархии.</p>
</li>
<li>
<p>Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса, и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_в_некоторых_интерфейсах_вообще_не_определяют_методов">Почему в некоторых интерфейсах вообще не определяют методов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это так называемые <em>маркерные интерфейсы</em>. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс <code>Clonable</code>, который указывает на то, что класс поддерживает механизм клонирования.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_нельзя_объявить_метод_интерфейса_с_модификатором_final">Почему нельзя объявить метод интерфейса с модификатором <code>final</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В случае интерфейсов указание модификатора <code>final</code> бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор <code>final</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_имеет_более_высокий_уровень_абстракции_класс_абстрактный_класс_или_интерфейс">Что имеет более высокий уровень абстракции - <em>класс</em>, <em>абстрактный класс</em> или <em>интерфейс</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Интерфейс.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_объект_получить_доступ_к_члену_класса_объявленному_как_private_если_да_то_каким_образом">Может ли объект получить доступ к члену класса, объявленному как <code>private</code>? Если да, то каким образом?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Внутри класса доступ к приватной переменной открыт без ограничений;</p>
</li>
<li>
<p>Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;</p>
</li>
<li>
<p>Доступ к приватным переменным извне может быть организован через отличные от приватных методов, которые предоставлены разработчиком класса. Например: <code>getX()</code> и <code>setX()</code>.</p>
</li>
<li>
<p>Через механизм рефлексии (Reflection API):</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Victim {
    private int field = 42;
}
//...
Victim victim = new Victim();
Field field = Victim.class.getDeclaredField("field");
field.setAccessible(true);
int fieldValue = (int) field.get(victim);
//...</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каков_порядок_вызова_конструкторов_и_блоков_инициализации_с_учётом_иерархии_классов">Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.</p>
</div>
<div class="paragraph">
<p>Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Parent static block(s) → Child static block(s) → Grandchild static block(s)</p>
</div>
<div class="paragraph">
<p>→ Parent non-static block(s) → Parent constructor →</p>
</div>
<div class="paragraph">
<p>→ Child non-static block(s) → Child constructor →</p>
</div>
<div class="paragraph">
<p>→ Grandchild non-static block(s) → Grandchild constructor</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Пример 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

    public static void main(String args[]) {
        System.out.println(TestClass.v);
        new TestClass().a();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called</pre>
</div>
</div>
<div class="paragraph">
<p>Пример 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

    public static void main(String args[]) {
        new TestClass().a();
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TestClass {

    public static String v = "Some val";

    {
        System.out.println("!!! Non-static initializer");
    }

    static {
        System.out.println("!!! Static initializer");
    }

    public void a() {
        System.out.println("!!! a() called");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! Static initializer
!!! Non-static initializer
!!! a() called</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужны_и_какие_бывают_блоки_инициализации">Зачем нужны и какие бывают блоки инициализации?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Существуют статические и нестатические блоки инициализации.</p>
</li>
<li>
<p>Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.</p>
</li>
<li>
<p>Несколько блоков инициализации выполняются в порядке следования в коде класса.</p>
</li>
<li>
<p>Блок инициализации способен генерировать исключения, если их объявления перечислены в <code>throws</code> всех конструкторов класса.</p>
</li>
<li>
<p>Блок инициализации возможно создать и в анонимном классе.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_к_каким_конструкциям_java_применим_модификатор_static">К каким конструкциям Java применим модификатор <code>static</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>полям;</p>
</li>
<li>
<p>методам;</p>
</li>
<li>
<p>вложенным классам;</p>
</li>
<li>
<p>блокам инициализации;</p>
</li>
<li>
<p>членам секции <code>import</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_в_java_используются_статические_блоки_инициализации">Для чего в Java используются статические блоки инициализации?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса <code>Class</code>).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_произойдёт_если_в_блоке_инициализации_возникнет_исключительная_ситуация">Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в <code>throws</code> всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.</p>
</div>
<div class="paragraph">
<p>В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какое_исключение_выбрасывается_при_возникновении_ошибки_в_блоке_инициализации_класса">Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если возникшее исключение - наследник <code>RuntimeException</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>для статических блоков инициализации будет выброшено <code>java.lang.ExceptionInInitializerError</code>;</p>
</li>
<li>
<p>для нестатических будет проброшено исключение-источник.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Если возникшее исключение - наследник <code>Error</code>, то в обоих случаях будет выброшено <code>java.lang.Error</code>. Исключение: <code>java.lang.ThreadDeath</code> - смерть потока. В этом случае никакое исключение выброшено не будет.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_статический_метод_быть_переопределён_или_перегружен">Может ли статический метод быть переопределён или перегружен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.</p>
</div>
<div class="paragraph">
<p>Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - это вполне корректная языковая конструкция.</p>
</div>
<div class="paragraph">
<p>В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_нестатические_методы_перегрузить_статические">Могут ли нестатические методы перегрузить статические?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_сузить_уровень_доступатип_возвращаемого_значения_при_переопределении_метода">Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>При переопределении метода нельзя сузить модификатор доступа к методу (например с public в MainClass до private в Class extends MainClass).</p>
</li>
<li>
<p>Изменить тип возвращаемого значения при переопределении метода нельзя, будет ошибка attempting to use incompatible return type.</p>
</li>
<li>
<p>Можно сузить возвращаемое значение, если они совместимы.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Animal {

    public Animal eat() {
        System.out.println("animal eat");
        return null;
    }

    public Long calc() {
        return null;
    }

}
public class Dog extends Animal {

    public Dog eat() {
        return new Dog();
    }
/*attempting to use incompatible return type
    public Integer calc() {
        return null;
    }
*/
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_возможно_ли_при_переопределении_метода_изменить_модификатор_доступа_возвращаемый_тип_тип_аргумента_или_их_количество_имена_аргументов_или_их_порядок_убирать_добавлять_изменять_порядок_следования_элементов_секции_throws">Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции <code>throws</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.</p>
</div>
<div class="paragraph">
<p>Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).</p>
</li>
<li>
<p>При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить <em>overloading</em> (перегрузка) метода.</p>
</li>
<li>
<p>Секцию <code>throws</code> метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения <code>RuntimeException</code>. Порядок следования таких элементов при переопределении значения не имеет.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_получить_доступ_к_переопределенным_методам_родительского_класса">Как получить доступ к переопределенным методам родительского класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>С помощью ключевого слова <code>super</code> мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором <code>private</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">super.method();</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_объявить_метод_абстрактным_и_статическим_одновременно">Можно ли объявить метод абстрактным и статическим одновременно?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Нет. В таком случае компилятор выдаст ошибку: <em>"Illegal combination of modifiers: &#8216;abstract&#8217; and &#8216;static&#8217;"</em>. Модификатор <code>abstract</code> говорит, что метод будет реализован в другом классе, а <code>static</code> наоборот указывает, что этот метод будет доступен по имени класса.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_разница_между_членом_экземпляра_класса_и_статическим_членом_класса">В чем разница между членом экземпляра класса и статическим членом класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Модификатор <code>static</code> говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля, помеченные <code>static</code> инициализируются при инициализации класса. На методы, объявленные как <code>static</code>, накладывается ряд ограничений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Они могут вызывать только другие статические методы.</p>
</li>
<li>
<p>Они должны осуществлять доступ только к статическим переменным.</p>
</li>
<li>
<p>Они не могут ссылаться на члены типа <code>this</code> или <code>super</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

	public static void main(String args[]) {
		System.out.println(TestClass.v);
		new TestClass().a();
		System.out.println(TestClass.v);
	}

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TestClass {

	public static String v = "Initial val";

	{
		System.out.println("!!! Non-static initializer");
		v = "Val from non-static";
	}

	static {
		System.out.println("!!! Static initializer");
		v = "Some val";
	}

	public void a() {
		System.out.println("!!! a() called");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Val from non-static</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_где_разрешена_инициализация_статическихнестатических_полей">Где разрешена инициализация статических/нестатических полей?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.</p>
</li>
<li>
<p>Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_типы_классов_бывают_в_java">Какие типы классов бывают в java?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>Top level class</em> (Обычный класс):</p>
<div class="ulist">
<ul>
<li>
<p><em>Abstract class</em> (Абстрактный класс);</p>
</li>
<li>
<p><em>Final class</em> (Финализированный класс).</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Interfaces</em> (Интерфейс).</p>
</li>
<li>
<p><em>Enum</em> (Перечисление).</p>
</li>
<li>
<p><em>Nested class</em> (Вложенный класс):</p>
<div class="ulist">
<ul>
<li>
<p><em>Static nested class</em> (Статический вложенный класс);</p>
</li>
<li>
<p><em>Member inner class</em> (Простой внутренний класс);</p>
</li>
<li>
<p><em>Local inner class</em> (Локальный класс);</p>
</li>
<li>
<p><em>Anonymous inner class</em> (Анонимный класс).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_вложенные_классы_в_каких_случаях_они_применяются">Расскажите про вложенные классы. В каких случаях они применяются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс называется вложенным (<em>Nested class</em>), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.</p>
</div>
<div class="paragraph">
<p>Существуют четыре категории вложенных классов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Static nested class</em> (Статический вложенный класс);</p>
</li>
<li>
<p><em>Member inner class</em> (Простой внутренний класс);</p>
</li>
<li>
<p><em>Local inner class</em> (Локальный класс);</p>
</li>
<li>
<p><em>Anonymous inner class</em> (Анонимный класс).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Такие категории классов, за исключением первого, также называют внутренними (<em>Inner class</em>). Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>
</div>
<div class="paragraph">
<p>Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, то рекомендуется делать его анонимным классом.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_статический_класс">Что такое <em>«статический класс»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это вложенный класс, объявленный с использованием ключевого слова <code>static</code>. К классам верхнего уровня модификатор <code>static</code> неприменим.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_особенности_использования_вложенных_классов_статических_и_внутренних_в_чем_заключается_разница_между_ними">Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.</p>
</li>
<li>
<p>Для создания объекта статического вложенного класса объект внешнего класса не требуется.</p>
</li>
<li>
<p>Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.</p>
</li>
<li>
<p>Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.</p>
</li>
<li>
<p>В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание <code>.this</code> после его имени. Например: <code>Outer.this</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_локальный_класс_каковы_его_особенности">Что такое <em>«локальный класс»</em>? Каковы его особенности?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Local inner class</strong> (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (<em>Member inner class</em>) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.</p>
</div>
<div class="paragraph">
<p>Локальные классы имеют следующие особенности:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Видны только в пределах блока, в котором объявлены;</p>
</li>
<li>
<p>Не могут быть объявлены как <code>private</code>/<code>public</code>/<code>protected</code> или <code>static</code>;</p>
</li>
<li>
<p>Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;</p>
</li>
<li>
<p>Имеют доступ к полям и методам обрамляющего класса;</p>
</li>
<li>
<p>Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором <code>final</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_анонимные_классы_где_они_применяются">Что такое <em>«анонимные классы»</em>? Где они применяются?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.</p>
</div>
<div class="paragraph">
<p>Анонимные классы имеют несколько ограничений:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Их использование разрешено только в одном месте программы - месте его создания;</p>
</li>
<li>
<p>Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;</p>
</li>
<li>
<p>Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Анонимные классы обычно применяются для:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>создания объекта функции (<em>function object</em>), например, реализация интерфейса <code>Comparator</code>;</p>
</li>
<li>
<p>создания объекта процесса (<em>process object</em>), такого как экземпляры классов <code>Thread</code>, <code>Runnable</code> и подобных;</p>
</li>
<li>
<p>в статическом методе генерации;</p>
</li>
<li>
<p>инициализации открытого статического поля <code>final</code>, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_из_вложенного_класса_получить_доступ_к_полю_внешнего_класса">Каким образом из вложенного класса получить доступ к полю внешнего класса?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.</p>
</div>
<div class="paragraph">
<p>Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр. Например: <code>Outer.this.field</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_используется_оператор_assert">Для чего используется оператор <code>assert</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Assert</strong> (Утверждение)&#8201;&#8212;&#8201;это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Утверждение может автоматически сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.</p>
</div>
<div class="paragraph">
<p>Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов выполнения очевидного кода может оказаться полезной при последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.</p>
</div>
<div class="paragraph">
<p>Обычно утверждения оставляют включенными во время разработки и тестирования программ, но отключают в релиз-версиях программ.</p>
</div>
<div class="paragraph">
<p>Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Если в результате удаления утверждения поведение программы может измениться, то это явный признак неправильного использования <em>assert</em>. Таким образом, внутри <em>assert</em> нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы.</p>
</div>
<div class="paragraph">
<p>В Java проверка утверждений реализована с помощью оператора <code>assert</code>, который имеет форму:</p>
</div>
<div class="paragraph">
<p><code>assert [Выражение типа boolean];</code> или <code>assert [Выражение типа boolean] : [Выражение любого типа, кроме void];</code></p>
</div>
<div class="paragraph">
<p>Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется значение булевского выражения, и если его результат <code>false</code>, то генерируется исключение <code>java.lang.AssertionError</code>. В случае использования второй формы оператора <code>assert</code> выражение после двоеточия задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразовано в строку и передано конструктору <code>AssertionError</code>).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_heap_и_stack_память_в_java_какая_разница_между_ними">Что такое <em>Heap</em> и <em>Stack</em> память в Java? Какая разница между ними?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Heap (куча)</strong> используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.</p>
</div>
<div class="paragraph">
<p><strong>Stack (стек)</strong> это область хранения данных также находящееся в общей оперативной памяти (<em>RAM</em>). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.
Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме <em>LIFO</em> (Последний-зашел-Первый-вышел)</p>
</div>
<div class="paragraph">
<p>Различия между <em>Heap</em> и <em>Stack</em> памятью:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Куча используется всеми частями приложения, в то время как стек используется только одним потоком исполнения программы.</p>
</li>
<li>
<p>Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.</p>
</li>
<li>
<p>Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.</p>
</li>
<li>
<p>Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.</p>
</li>
<li>
<p>Если память стека полностью занята, то Java Runtime бросает исключение <code>java.lang.StackOverflowError</code>. Если заполнена память кучи, то бросается исключение <code>java.lang.OutOfMemoryError: Java Heap Space</code>.</p>
</li>
<li>
<p>Размер памяти стека намного меньше памяти в куче.</p>
</li>
<li>
<p>Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для определения начального и максимального размера памяти в куче используются <code>-Xms</code> и <code>-Xmx</code> опции JVM. Для стека определить размер памяти можно с помощью опции <code>-Xss</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_верно_ли_утверждение_что_примитивные_типы_данных_всегда_хранятся_в_стеке_а_экземпляры_ссылочных_типов_данных_в_куче">Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора <code>new</code>) хранится в куче.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_передаются_переменные_в_методы_по_значению_или_по_ссылке">Каким образом передаются переменные в методы, по значению или по ссылке?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужен_сборщик_мусора">Для чего нужен сборщик мусора?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Сборщик мусора (Garbage Collector) должен делать всего две вещи:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);</p>
</li>
<li>
<p>Освобождать память от мусора.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Существует два подхода к обнаружению мусора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Reference counting</em>;</p>
</li>
<li>
<p><em>Tracing</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Reference counting</strong> (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.</p>
</div>
<div class="paragraph">
<p>Главная идея подхода <strong>Tracing</strong> (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (<em>GC Root</em>) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.</p>
</div>
<div class="paragraph">
<p>Существует 4 типа корневых точки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Локальные переменные и параметры методов;</p>
</li>
<li>
<p>Потоки;</p>
</li>
<li>
<p>Статические переменные;</p>
</li>
<li>
<p>Ссылки из JNI.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Самое простое java приложение будет иметь корневые точки:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Локальные переменные внутри <code>main()</code> метода и параметры <code>main()</code> метода;</p>
</li>
<li>
<p>Поток который выполняет <code>main()</code>;</p>
</li>
<li>
<p>Статические переменные класса, внутри которого находится <code>main()</code> метод.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.</p>
</div>
<hr>
<div class="paragraph">
<p>Для очистки памяти от мусора существуют два основных метода:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Copying collectors</em></p>
</li>
<li>
<p><em>Mark-and-sweep</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При <strong>copying collectors</strong> подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Объекты создаются в «from-space»;</p>
</li>
<li>
<p>Когда «from-space» заполняется, приложение приостанавливается;</p>
</li>
<li>
<p>Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;</p>
</li>
<li>
<p>Когда все объекты скопированы «from-space» полностью очищается;</p>
</li>
<li>
<p>«to-space» и «from-space» меняются местами.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;</p>
</li>
<li>
<p>В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Алгоритм работы <strong>mark-and-sweep</strong> можно описать так:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Объекты создаются в памяти;</p>
</li>
<li>
<p>В момент, когда нужно запустить сборщик мусора приложение приостанавливается;</p>
</li>
<li>
<p>Сборщик проходится по дереву объектов, помечая живые объекты;</p>
</li>
<li>
<p>Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;</p>
</li>
<li>
<p>Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Минусы этого способа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Приложение не работает пока происходит сборка мусора;</p>
</li>
<li>
<p>Время остановки напрямую зависит от размеров памяти и количества объектов;</p>
</li>
<li>
<p>Если не использовать «compacting» память будет использоваться не эффективно.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Сборщики мусора HotSpot VM используют комбинированный подход <strong>Generational Garbage Collection</strong>, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>большинство создаваемых объектов быстро становятся мусором;</p>
</li>
<li>
<p>существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_работает_сборщик_мусора">Как работает сборщик мусора?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.</p>
</div>
<div class="paragraph">
<p>Объекты создаются посредством оператора <code>new</code>, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив переменной ссылку на другой объект или значение <code>null</code>; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, ссылки на которые отсутствуют, принято называть мусором (<em>garbage</em>), который будет удален.</p>
</div>
<div class="paragraph">
<p>Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти&#8201;&#8212;&#8201;все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (<em>GC Root</em>) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.</p>
</div>
<div class="paragraph">
<p>Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.</p>
</div>
<div class="paragraph">
<p>Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и, если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов,&#8201;&#8212;&#8201;это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_разновидности_сборщиков_мусора_реализованы_в_виртуальной_машине_hotspot">Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Serial (последовательный)</strong>&#8201;&#8212;&#8201;самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией <code>-XX:+UseSerialGC</code>.</p>
</li>
<li>
<p><strong>Parallel (параллельный)</strong>&#8201;&#8212;&#8201;наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией <code>-XX:+UseParallelGC</code>.</p>
</li>
<li>
<p><strong>Concurrent Mark Sweep (CMS)</strong>&#8201;&#8212;&#8201;нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией <code>-XX:+UseConcMarkSweepGC</code>.</p>
</li>
<li>
<p><strong>Garbage-First (G1)</strong>&#8201;&#8212;&#8201;создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. <em>G1</em> включается опцией Java <code>-XX:+UseG1GC</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_опишите_алгоритм_работы_какого_нибудь_сборщика_мусора_реализованного_в_виртуальной_машине_hotspot">Опишите алгоритм работы какого-нибудь сборщика мусора, реализованного в виртуальной машине HotSpot.</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Serial Garbage Collector (Последовательный сборщик мусора)</strong> был одним из первых сборщиков мусора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращения сборки мусора.</p>
</div>
<div class="paragraph">
<p>Память приложения делится на три пространства:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Young generation</em>. Объекты создаются именно в этом участке памяти.</p>
</li>
<li>
<p><em>Old generation</em>. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».</p>
</li>
<li>
<p><em>Permanent generation</em>. Тут хранятся метаданные об объектах, <em>Class data sharing (CDS)</em>, <em>пул строк (String pool)</em>. Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только для чтения не чистится сборщиком мусора никогда.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Область памяти Young generation состоит из трёх областей: <em>Eden</em> и двух меньших по размеру <em>Survivor spaces</em> - <em>To space</em> и <em>From space</em>. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (<em>tenuring threshold</em>), чтобы быть перемещенными в Old generation.</p>
</div>
<div class="paragraph">
<p>Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (<em>minor collection</em>), в отличие от процесса сборки, проводимого над всей кучей (<em>full collection</em>). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.</p>
</div>
<div class="paragraph">
<p>Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.</p>
</div>
<div class="paragraph">
<p>Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется <em>copying</em> (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).</p>
</div>
<div class="paragraph">
<p>Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.</p>
</div>
<div class="paragraph">
<p>В Old generation сборка мусора происходит с использованием алгоритма <em>mark-sweep-compact</em>, который состоит из трёх фаз. В фазе <em>Mark</em> (пометка) сборщик мусора помечает все живые объекты, затем, в фазе <em>Sweep</em> (очистка) все не помеченные объекты удаляются, а в фазе <em>Сompact</em> (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.</p>
</div>
<div class="paragraph">
<p>Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм <em>bump-the-pointer</em>: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.</p>
</div>
<div class="paragraph">
<p>Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_пул_строк">Что такое «пул строк»?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Пул строк</strong>&#8201;&#8212;&#8201;это набор строк, хранящийся в <em>Heap</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;</p>
</li>
<li>
<p>Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;</p>
</li>
<li>
<p>Когда для создания строки используются <code>"</code>, то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;</p>
</li>
<li>
<p>При использовании оператора <code>new</code> создаётся новый объект <code>String</code>. Затем при помощи метода <code>intern()</code> эту строку можно поместить в пул или же получить из пула ссылку на другой объект <code>String</code> с таким же значением;</p>
</li>
<li>
<p>Пул строк является примером паттерна <em>«Приспособленец» (Flyweight)</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_finalize_зачем_он_нужен">Что такое <code>finalize()</code>? Зачем он нужен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Через вызов метода <code>finalize()</code> (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С&#43;&#43;, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (<em>garbage collector</em>) и переопределяя <code>finalize()</code> можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.</p>
</div>
<div class="paragraph">
<p>После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода <code>finalize()</code> т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.</p>
</div>
<div class="paragraph">
<p>Объект не обязательно будет доступен для сборки сразу же - метод <code>finalize()</code> может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TestClass {

	public void a() {
		System.out.println("!!! a() called");
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения программы с большой вероятностью будет следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! a() called
!!! a() called
!!! done</pre>
</div>
</div>
<div class="paragraph">
<p>Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		a.a();
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		a.a();
		System.out.println("!!! done");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может разниться от запуска к запуску:
Вариант а:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! a() called
!!! a() called
!!! done
!!! finalize() called</pre>
</div>
</div>
<div class="paragraph">
<p>Вариант б:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! a() called
!!! a() called
!!! finalize() called
!!! done</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_произойдет_со_сборщиком_мусора_если_выполнение_метода_finalize_требует_ощутимо_много_времени_или_в_процессе_выполнения_будет_выброшено_исключение">Что произойдет со сборщиком мусора, если выполнение метода <code>finalize()</code> требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Непосредственно вызов <code>finalize()</code> происходит в отдельном потоке <em>Finalizer</em> (<code>java.lang.ref.Finalizer.FinalizerThread</code>), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса <code>Finalizer</code>). Методы <code>finalize()</code> вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то <code>finalize()</code> зависнет, он подвесит поток <em>Finalizer</em>, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода <code>finalize()</code>, будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток <em>Finalizer</em> не освободится, не завершится приложение или не кончится память.</p>
</div>
<div class="paragraph">
<p>То же самое применимо и выброшенным в процессе <code>finalize()</code> исключениям: метод <code>runFinalizer()</code> у потока <em>Finalizer</em> игнорирует все исключения выброшенные в момент выполнения <code>finalize()</code>. Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_final_finally_и_finalize">Чем отличаются <code>final</code>, <code>finally</code> и <code>finalize()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Модификатор <code>final</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Класс не может иметь наследников;</p>
</li>
<li>
<p>Метод не может быть переопределен в классах наследниках;</p>
</li>
<li>
<p>Поле не может изменить свое значение после инициализации;</p>
</li>
<li>
<p>Локальные переменные не могут быть изменены после присвоения им значения;</p>
</li>
<li>
<p>Параметры методов не могут изменять своё значение внутри метода.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Оператор <code>finally</code> гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке <code>try-catch</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>finalize()</code> вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>
</div>
<div class="paragraph">
<p>Пример:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MainClass {

	public static void main(String args[]) {
		TestClass a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		a = null;
		System.gc(); // Принудительно зовём сборщик мусора
		a = new TestClass();
		System.out.println("result of a.a() is " + a.a());
		System.out.println("!!! done");
	}

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TestClass {

	public int a() {
		try {
			System.out.println("!!! a() called");
			throw new Exception("");
		} catch (Exception e) {
			System.out.println("!!! Exception in a()");
			return 2;
		} finally {
			System.out.println("!!! finally in a() ");
		}
	}

	@Override
	protected void finalize() throws Throwable {
		System.out.println("!!! finalize() called");
		super.finalize();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Результат выполнения:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>!!! a() called
!!! Exception in a()
!!! finally in a()
result of a.a() is 2
!!! a() called
!!! Exception in a()
!!! finally in a()
!!! finalize() called
result of a.a() is 2
!!! done</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_приведение_типов_что_такое_понижение_и_повышение_типа">Расскажите про приведение типов. Что такое понижение и повышение типа?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм <em>приведения типов (casting)</em> - способ преобразования значения переменной одного типа в значение другого типа.</p>
</div>
<div class="paragraph">
<p>В Java существуют несколько разновидностей приведения:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Тождественное (identity)</strong>. Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.</p>
</li>
<li>
<p><strong>Расширение (повышение, upcasting) примитивного типа (widening primitive)</strong>. Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа <code>byte</code> (длина 1 байт) к типу <code>int</code> (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.</p>
</li>
<li>
<p><strong>Сужение (понижение, downcasting) примитивного типа (narrowing primitive)</strong>. Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа <code>int</code> было больше <code>127</code>, то при приведении его к <code>byte</code> значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.</p>
</li>
<li>
<p><strong>Расширение объектного типа (widening reference)</strong>. Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.</p>
</li>
<li>
<p><strong>Сужение объектного типа (narrowing reference)</strong>. Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение <code>ClassCastException</code>. Требует явного указания типа.</p>
</li>
<li>
<p><strong>Преобразование к строке (to String)</strong>. Любой тип может быть приведен к строке, т.е. к экземпляру класса <code>String</code>.</p>
</li>
<li>
<p><strong>Запрещенные преобразования (forbidden)</strong>. Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.</p>
</div>
<div class="paragraph">
<p>Для проверки возможности приведения нужно воспользоваться оператором <code>instanceof</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Parent parent = new Child();
if (parent instanceof Child) {
    Child child = (Child) parent;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_когда_в_приложении_может_быть_выброшено_исключение_classcastexception">Когда в приложении может быть выброшено исключение <code>ClassCastException</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>ClassCastException</code> (потомок <code>RuntimeException</code>) - исключение, которое будет выброшено при ошибке приведения типа.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_литералы">Что такое литералы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Литералы</strong>&#8201;&#8212;&#8201;это явно заданные значения в коде программы&#8201;&#8212;&#8201;константы определенного типа, которые находятся в коде в момент запуска.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Test {
   int a = 0b1101010110;
   public static void main(String[] args) {
       System.out.println("Hello world!");
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этом классе &#8220;Hello world!&#8221;&#8201;&#8212;&#8201;литерал.</p>
</div>
<div class="paragraph">
<p>Переменная <code>a</code> - тоже литерал.</p>
</div>
<div class="paragraph">
<p>Литералы бывают разных типов, которые определяются их назначением и способом написания.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_autoboxing_автоупаковка_в_java_и_каковы_правила_упаковки_примитивных_типов_в_классы_обертки">Что такое <em>autoboxing («автоупаковка»)</em> в Java и каковы правила упаковки примитивных типов в классы-обертки?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Автоупаковка</strong> - это механизм неявной инициализации объектов классов-оберток (<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>) значениями соответствующих им исходных примитивных типов (<code>byte</code>, <code>short</code>, <code>int</code>&#8230;&#8203;), без явного использования конструктора класса.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора <code>=</code>), либо при передаче примитива в параметры метода (типа класса-обертки).</p>
</li>
<li>
<p>Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и <code>final</code>-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.</p>
</li>
<li>
<p>Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа <code>byte</code> в <code>Short</code>, без предварительного явного приведения <code>byte</code> в <code>short</code> вызовет ошибку компиляции.</p>
</li>
<li>
<p>Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:
1) неявное расширение/сужение исходного типа примитива до типа примитива, соответствующего классу-обертке (для преобразования <code>int</code> в <code>Byte</code>, сначала компилятор самостоятельно неявно сужает <code>int</code> к <code>byte</code>)
2) автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют два дополнительных ограничения:
    a) присвоение примитива обертке может производится только оператором <code>=</code> (нельзя передать такой примитив в параметры метода без явного приведения типов)
    b) тип левого операнда не должен быть старше чем <code>Character</code>, тип правого не должен старше, чем <code>int</code>: допустимо расширение/сужение <code>byte</code> в/из <code>short</code>, <code>byte</code> в/из <code>char</code>, <code>short</code> в/из <code>char</code> и только сужение <code>byte</code> из <code>int</code>, <code>short</code> из <code>int</code>, <code>char</code> из <code>int</code>. Все остальные варианты требуют явного приведения типов).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой констант в диапазоне <code>-128 ... +127</code> является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_есть_особенности_класса_string">Какие есть особенности класса <code>String</code>?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Это неизменяемый (immutable) и финализированный тип данных;</p>
</li>
<li>
<p>Все объекты класса <code>String</code> JVM хранит в пуле строк;</p>
</li>
<li>
<p>Объект класса <code>String</code> можно получить, используя двойные кавычки;</p>
</li>
<li>
<p>Можно использовать оператор <code>+</code> для конкатенации строк;</p>
</li>
<li>
<p>Начиная с Java 7 строки можно использовать в конструкции <code>switch</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_string_неизменяемый_и_финализированный_класс">Почему <code>String</code> неизменяемый и финализированный класс?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Есть несколько преимуществ в неизменности строк:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в <em>Heap</em>, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.</p>
</li>
<li>
<p>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.</p>
</li>
<li>
<p>Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.</p>
</li>
<li>
<p>Строки используются <em>classloader</em> и неизменность обеспечивает правильность загрузки класса.</p>
</li>
<li>
<p>Поскольку строка неизменяемая, её <code>hashCode()</code> кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в <code>HashMap</code> т.к. его обработка происходит быстрее.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_char_предпочтительнее_string_для_хранения_пароля">Почему <code>char[]</code> предпочтительнее <code>String</code> для хранения пароля?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста.
В случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_строка_является_популярным_ключом_в_hashmap_в_java">Почему строка является популярным ключом в <code>HashMap</code> в Java?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа <code>HashMap</code> они будут обрабатываться быстрее.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_делает_метод_intern_в_классе_string">Что делает метод <code>intern()</code> в классе <code>String</code>?.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>intern()</code> используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_использовать_строки_в_конструкции_switch">Можно ли использовать строки в конструкции <code>switch</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, начиная с Java 7 в операторе <code>switch</code> можно использовать строки, ранние версии Java не поддерживают этого. При этом:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>участвующие строки чувствительны к регистру;</p>
</li>
<li>
<p>используется метод <code>equals()</code> для сравнения полученного значения со значениями <code>case</code>, поэтому во избежание <code>NullPointerException</code> стоит предусмотреть проверку на <code>null</code>.</p>
</li>
<li>
<p>согласно документации, Java 7 для строк в <code>switch</code>, компилятор Java формирует более эффективный байткод для строк в конструкции <code>switch</code>, чем для сцепленных условий <code>if</code>-<code>else</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_основная_разница_между_string_stringbuffer_stringbuilder">Какая основная разница между <code>String</code>, <code>StringBuffer</code>, <code>StringBuilder</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Класс <code>String</code> является неизменяемым (<em>immutable</em>) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</p>
</div>
<div class="paragraph">
<p>Класс <code>StringBuffer</code> изменяемый - использовать <code>StringBuffer</code> следует тогда, когда необходимо часто модифицировать содержимое.</p>
</div>
<div class="paragraph">
<p>Класс <code>StringBuilder</code> был добавлен в Java 5 и он во всем идентичен классу <code>StringBuffer</code> за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_класс_object_какие_в_нем_есть_методы">Что такое класс <code>Object</code>? Какие в нем есть методы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Object</code> это базовый класс для всех остальных объектов в Java. Любой класс наследуется от <code>Object</code> и, соответственно, наследуют его методы:</p>
</div>
<div class="paragraph">
<p><code>public boolean equals(Object obj)</code>&#8201;&#8212;&#8201;служит для сравнения объектов по значению;</p>
</div>
<div class="paragraph">
<p><code>int hashCode()</code>&#8201;&#8212;&#8201;возвращает hash код для объекта;</p>
</div>
<div class="paragraph">
<p><code>String toString()</code>&#8201;&#8212;&#8201;возвращает строковое представление объекта;</p>
</div>
<div class="paragraph">
<p><code>Class getClass()</code>&#8201;&#8212;&#8201;возвращает класс объекта во время выполнения;</p>
</div>
<div class="paragraph">
<p><code>protected Object clone()</code>&#8201;&#8212;&#8201;создает и возвращает копию объекта;</p>
</div>
<div class="paragraph">
<p><code>void notify()</code>&#8201;&#8212;&#8201;возобновляет поток, ожидающий монитор;</p>
</div>
<div class="paragraph">
<p><code>void notifyAll()</code>&#8201;&#8212;&#8201;возобновляет все потоки, ожидающие монитор;</p>
</div>
<div class="paragraph">
<p><code>void wait()</code>&#8201;&#8212;&#8201;остановка вызвавшего метод потока до момента пока другой поток не вызовет метод <code>notify()</code> или <code>notifyAll()</code> для этого объекта;</p>
</div>
<div class="paragraph">
<p><code>void wait(long timeout)</code>&#8201;&#8212;&#8201;остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод <code>notify()</code> или <code>notifyAll()</code> для этого объекта;</p>
</div>
<div class="paragraph">
<p><code>void wait(long timeout, int nanos)</code>&#8201;&#8212;&#8201;остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод <code>notify()</code> или <code>notifyAll()</code> для этого объекта;</p>
</div>
<div class="paragraph">
<p><code>protected void finalize()</code>&#8201;&#8212;&#8201;может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_дайте_определение_понятию_конструктор">Дайте определение понятию «конструктор».</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Конструктор</strong>&#8201;&#8212;&#8201;это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для его инициализации.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_конструктор_по_умолчанию">Что такое <em>«конструктор по умолчанию»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый <strong>«конструктор по умолчанию»</strong>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ClassName() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_чем_отличаются_конструктор_по_умолчанию_конструктор_копирования_и_конструктор_с_параметрами">Чем отличаются конструктор по-умолчанию, конструктор копирования и конструктор с параметрами?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_где_и_как_вы_можете_использовать_приватный_конструктор">Где и как вы можете использовать приватный конструктор?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Приватный (помеченный ключевым словом <code>private</code>, скрытый) конструктор может использоваться публичным статическим методом генерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_классы_загрузчики_и_про_динамическую_загрузку_классов">Расскажите про классы-загрузчики и про динамическую загрузку классов.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Основа работы с классами в Java&#8201;&#8212;&#8201;классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и создания объекта класса по его имени во время работы приложения.</p>
</div>
<div class="paragraph">
<p>В начале работы программы создается 3 основных загрузчика классов:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>базовый загрузчик (bootstrap/primordial)</strong>. Загружает основные системные и внутренние классы JDK (<em>Core API</em> - пакеты <code>java.*</code> (<code>rt.jar</code> и <code>i18n.jar</code>) . Важно заметить, что базовый загрузчик является <em>«Изначальным»</em> или <em>«Корневым»</em> и частью JVM, вследствие чего его нельзя создать внутри кода программы.</p>
</li>
<li>
<p><strong>загрузчик расширений (extention)</strong>. Загружает различные пакеты расширений, которые располагаются в директории <code>&lt;JAVA_HOME&gt;/lib/ext</code> или другой директории, описанной в системном параметре <code>java.ext.dirs</code>. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом <code>sun.misc.Launcher$ExtClassLoader</code>.</p>
</li>
<li>
<p><strong>системный загрузчик (system/application)</strong>. Загружает классы, пути к которым указаны в переменной окружения <code>CLASSPATH</code> или пути, которые указаны в командной строке запуска JVM после ключей <code>-classpath</code> или <code>-cp</code>. Системный загрузчик реализован классом <code>sun.misc.Launcher$AppClassLoader</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке <em>Core API</em>, потом в папке расширений, потом в локальных файлах <code>CLASSPATH</code>.</p>
</div>
<div class="paragraph">
<p>Процесс загрузки класса состоит из трех частей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Loading</em>&#8201;&#8212;&#8201;на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.</p>
</li>
<li>
<p><em>Linking</em>&#8201;&#8212;&#8201;процесс, который может быть разбит на 3 части:</p>
<div class="ulist">
<ul>
<li>
<p><em>Bytecode verification</em>&#8201;&#8212;&#8201;проверка байт-кода на соответствие требованиям, определенным в спецификации JVM.</p>
</li>
<li>
<p><em>Class preparation</em>&#8201;&#8212;&#8201;создание и инициализация необходимых структур, используемых для представления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.</p>
</li>
<li>
<p><em>Resolving</em>&#8201;&#8212;&#8201;загрузка набора классов, на которые ссылается загружаемый класс.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>Initialization</em>&#8201;&#8212;&#8201;вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Динамическая загрузка классов в Java имеет ряд особенностей:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>отложенная (lazy) загрузка и связывание классов</em>. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.</p>
</li>
<li>
<p><em>проверка корректности загружаемого кода (type safeness)</em>. Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.</p>
</li>
<li>
<p><em>программируемая загрузка</em>. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса&#8201;&#8212;&#8201;самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.</p>
</li>
<li>
<p><em>множественные пространства имен</em>. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Существует несколько способов инициировать загрузку требуемого класса:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>явный: вызов <code>ClassLoader.loadClass()</code> или <code>Class.forName()</code> (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);</p>
</li>
<li>
<p>неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_reflection">Что такое <em>Reflection</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Рефлексия (Reflection)</strong> - это механизм получения данных о программе во время её выполнения (runtime). В Java <em>Reflection</em> осуществляется с помощью <em>Java Reflection API</em>, состоящего из классов пакетов <code>java.lang</code> и <code>java.lang.reflect</code>.</p>
</div>
<div class="paragraph">
<p>Возможности Java Reflection API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Определение класса объекта;</p>
</li>
<li>
<p>Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;</p>
</li>
<li>
<p>Определение интерфейсов, реализуемых классом;</p>
</li>
<li>
<p>Создание экземпляра класса;</p>
</li>
<li>
<p>Получение и установка значений полей объекта;</p>
</li>
<li>
<p>Вызов методов объекта;</p>
</li>
<li>
<p>Создание нового массива.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_зачем_нужен_equals_чем_он_отличается_от_операции">Зачем нужен <code>equals()</code>. Чем он отличается от операции <code>==</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>equals()</code> - определяет отношение эквивалентности объектов.</p>
</div>
<div class="paragraph">
<p>При сравнении объектов с помощью <code>==</code> сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком <code>equals()</code> - по внутреннему состоянию объектов.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_если_вы_хотите_переопределить_equals_какие_условия_должны_выполняться">Если вы хотите переопределить <code>equals()</code>, какие условия должны выполняться?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_какими_свойствами_обладает_порождаемое_equals_отношение_эквивалентности">Какими свойствами обладает порождаемое <code>equals()</code> отношение эквивалентности?</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><em>Рефлексивность</em>: для любой ссылки на значение <code>x</code>, <code>x.equals(x)</code> вернет <code>true</code>;</p>
</li>
<li>
<p><em>Симметричность</em>: для любых ссылок на значения <code>x</code> и <code>y</code>, <code>x.equals(y)</code> должно вернуть <code>true</code>, тогда и только тогда, когда <code>y.equals(x)</code> возвращает <code>true</code>.</p>
</li>
<li>
<p><em>Транзитивность</em>: для любых ссылок на значения <code>x</code>, <code>y</code> и <code>z</code>, если <code>x.equals(y)</code> и <code>y.equals(z)</code> возвращают <code>true</code>, тогда и <code>x.equals(z)</code> вернёт <code>true</code>;</p>
</li>
<li>
<p><em>Непротиворечивость</em>: для любых ссылок на значения <code>х</code> и <code>у</code>, если несколько раз вызвать <code>х.equals(y)</code>, постоянно будет возвращаться значение <code>true</code> либо постоянно будет возвращаться значение <code>false</code> при условии, что никакая информация, используемая при сравнении объектов, не поменялась.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для любой ненулевой ссылки на значение <code>х</code> выражение <code>х.equals(null)</code> должно возвращать <code>false</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_правила_переопределения_метода_object_equals">Правила переопределения метода <code>Object.equals()</code>.</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Использование оператора <code>==</code> для проверки, является ли аргумент ссылкой на указанный объект. Если является, возвращается <code>true</code>. Если сравниваемый объект <code>== null</code>, должно вернуться <code>false</code>.</p>
</li>
<li>
<p>Использование вызова метода <code>getClass()</code> для проверки, имеет ли аргумент правильный тип. Если не имеет, возвращается <code>false</code>.</p>
</li>
<li>
<p>Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой <code>instanceof</code> она гарантированно будет выполнена.</p>
</li>
<li>
<p>Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно, возвращается результат <code>true</code>, в противном случае - <code>false</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>По окончанию переопределения метода <code>equals()</code> следует проверить: является ли порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какая_связь_между_hashcode_и_equals">Какая связь между <code>hashCode()</code> и <code>equals()</code>?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_если_equals_переопределен_есть_ли_какие_либо_другие_методы_которые_следует_переопределить">Если <code>equals()</code> переопределен, есть ли какие-либо другие методы, которые следует переопределить?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Равные объекты должны возвращать одинаковые хэш коды. При переопределении <code>equals()</code> нужно обязательно переопределять и метод <code>hashCode()</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_будет_если_переопределить_equals_не_переопределяя_hashcode_какие_могут_возникнуть_проблемы">Что будет, если переопределить <code>equals()</code> не переопределяя <code>hashCode()</code>? Какие могут возникнуть проблемы?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для <code>HashMap</code> это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каким_образом_реализованы_методы_hashcode_и_equals_в_классе_object">Каким образом реализованы методы <code>hashCode()</code> и <code>equals()</code> в классе <code>Object</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Реализация метода <code>Object.equals()</code> сводится к проверке на равенство двух ссылок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public boolean equals(Object obj) {
  return (this == obj);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Реализация метода <code>Object.hashCode()</code> описана как <code>native</code>, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public native int hashCode();</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_для_чего_нужен_метод_hashcode">Для чего нужен метод <code>hashCode()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>hashCode()</code> необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом <code>int</code>, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>если хэш коды разные, то и объекты гарантированно разные;</p>
</li>
<li>
<p>если хэш коды равны, то объекты не обязательно равны(могут быть разные).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_каковы_правила_переопределения_метода_object_hashcode">Каковы правила переопределения метода <code>Object.hashCode()</code>?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_есть_ли_какие_либо_рекомендации_о_том_какие_поля_следует_использовать_при_подсчете_hashcode">Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете <code>hashCode()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например, такие как <code>id</code>, <code>uuid</code>. При этом нужно следовать правилу, если поля задействованы при вычислении <code>hashCode()</code>, то они должны быть задействованы и при выполнении <code>equals()</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_у_разных_объектов_быть_одинаковые_hashcode">Могут ли у разных объектов быть одинаковые <code>hashCode()</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, могут. Метод <code>hashCode()</code> не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется <em>коллизией</em>. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_если_у_класса_pointint_x_y_реализовать_метод_equalsobject_that_return_this_x_that_x_this_y_that_y_но_сделать_хэш_код_в_виде_int_hashcode_return_x_то_будут_ли_корректно_такие_точки_помещаться_и_извлекаться_из_hashset">Если у класса <code>Point{int x, y;}</code> реализовать метод <code>equals(Object that) {(return this.x == that.x &amp;&amp; this.y == that.y)}</code>, но сделать хэш код в виде <code>int hashCode() {return x;}</code>, то будут ли корректно такие точки помещаться и извлекаться из <code>HashSet</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>HashSet</code> использует <code>HashMap</code> для хранения элементов. При добавлении элемента в <code>HashMap</code> вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса <code>Point</code> хэш код будет одинаковым для всех объектов с одинаковым <code>x</code>, что приведёт к вырождению хэш таблицы в список.</p>
</div>
<div class="paragraph">
<p>При возникновении коллизии в <code>HashMap</code> осуществляется проверка на наличие элемента в списке: <code>e.hash == hash &amp;&amp; k = e.key) == key || key.equals(k</code>. Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод <code>equals()</code> будет возвращать <code>false</code>. Соответственно новый элемент будет успешно добавлен в <code>HashSet</code>. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц использоваться не будут.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_у_разных_объектов_ref0_ref1_быть_ref0_equalsref1_true">Могут ли у разных объектов <code>(ref0 != ref1)</code> быть <code>ref0.equals(ref1) == true</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Да, могут. Для этого в классе этих объектов должен быть переопределен метод <code>equals()</code>.</p>
</div>
<div class="paragraph">
<p>Если используется метод <code>Object.equals()</code>, то для двух ссылок <code>x</code> и <code>y</code> метод вернет <code>true</code> тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. <code>x == y</code> возвращает <code>true</code>).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_могут_ли_у_разных_ссылок_на_один_объект_ref0_ref1_быть_ref0_equalsref1_false">Могут ли у разных ссылок на один объект <code>(ref0 == ref1)</code> быть <code>ref0.equals(ref1) == false</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В общем случае - могут, если метод <code>equals()</code> реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок <code>x</code> метод <code>x.equals(x)</code> должен возвращать <code>true</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_так_реализовать_метод_equalsobject_that_return_this_hashcode_that_hashcode">Можно ли так реализовать метод <code>equals(Object that) {return this.hashCode() == that.hashCode()}</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Строго говоря нельзя, поскольку метод <code>hashCode()</code> не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса <code>Object</code> такой код допустим, т.к. метод <code>hashCode()</code> в классе <code>Object</code> возвращает уникальные значения для разных объектов (его вычисление основано на использовании адреса объекта в памяти).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_equals_требуется_проверять_что_аргумент_equalsobject_that_такого_же_типа_что_и_сам_объект_в_чем_разница_между_this_getclass_that_getclass_и_that_instanceof_myclass">В <code>equals()</code> требуется проверять, что аргумент <code>equals(Object that)</code> такого же типа что и сам объект. В чем разница между <code>this.getClass() == that.getClass()</code> и <code>that instanceof MyClass</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Оператор <code>instanceof</code> сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.</p>
</div>
<div class="paragraph">
<p><code>this.getClass() == that.getClass()</code> проверяет два класса на идентичность, поэтому для корректной реализации контракта метода <code>equals()</code> необходимо использовать точное сравнение с помощью метода <code>getClass()</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_можно_ли_реализовать_метод_equals_класса_myclass_вот_так_class_myclass_public_boolean_equalsmyclass_that_return_this_that">Можно ли реализовать метод <code>equals()</code> класса <code>MyClass</code> вот так: <code>class MyClass {public boolean equals(MyClass that) {return this == that;}}</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Реализовать можно, но данный метод не переопределяет метод <code>equals()</code> класса <code>Object</code>, а перегружает его.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_есть_класс_pointint_x_y_почему_хэш_код_в_виде_31_x_y_предпочтительнее_чем_x_y">Есть класс <code>Point{int x, y;}</code>. Почему хэш код в виде <code>31 * x + y</code> предпочтительнее чем <code>x + y</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш функцию.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_расскажите_про_клонирование_объектов">Расскажите про клонирование объектов.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же состоянием используется клонирование объекта.</p>
</div>
<div class="paragraph">
<p>Класс <code>Object</code> содержит <code>protected</code> метод <code>clone()</code>, осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод <code>clone()</code> как <code>public</code> для обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию метода <code>super.clone()</code>, которая и выполняет собственно клонирование.</p>
</div>
<div class="paragraph">
<p>Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс <code>Cloneable</code>. Интерфейс <code>Cloneable</code> не содержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод <code>clone()</code> класса <code>Object</code> возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение <code>CloneNotSupportedException</code>. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.</p>
</div>
<div class="paragraph">
<p>Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля оригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам объект поля класса.</p>
</div>
<div class="paragraph">
<p>Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс <code>Cloneable</code> и переопределяет метод <code>clone()</code>. Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо наличие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования объявлений <code>final</code> для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.</p>
</div>
<div class="paragraph">
<p>Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Специализированный конструктор копирования</strong> - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.</p>
</li>
<li>
<p><strong>Фабричный метод</strong> - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.</p>
</li>
<li>
<p><strong>Механизм сериализации</strong> - сохранение и последующее восстановление объекта в/из потока байтов.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_в_чем_отличие_между_поверхностным_и_глубоким_клонированием">В чем отличие между <em>поверхностным</em> и <em>глубоким</em> клонированием?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Поверхностное копирование</strong> копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс <code>Object</code> не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.</p>
</li>
<li>
<p>Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Глубокое копирование</strong> дублирует абсолютно всю информацию объекта:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Нет необходимости копировать отдельно примитивные данные;</p>
</li>
<li>
<p>Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода <code>clone()</code> должен вызываться <code>super.clone()</code>;</p>
</li>
<li>
<p>Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_способ_клонирования_предпочтительней">Какой способ клонирования предпочтительней?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Наиболее безопасным и, следовательно, предпочтительным способом клонирования является использование специализированного конструктора копирования:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод <code>clone()</code>);</p>
</li>
<li>
<p>Поля для клонирования указываются явно;</p>
</li>
<li>
<p>Возможность клонировать даже <code>final</code> поля.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_почему_метод_clone_объявлен_в_классе_object_а_не_в_интерфейсе_cloneable">Почему метод <code>clone()</code> объявлен в классе <code>Object</code>, а не в интерфейсе <code>Cloneable</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Метод <code>clone()</code> объявлен в классе <code>Object</code> с указанием модификатора <code>native</code>, чтобы обеспечить доступ к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен и как <code>protected</code>, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Непосредственно интерфейс <code>Cloneable</code> является маркерным (не содержит объявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клонированным. Вызов переопределённого метода <code>clone()</code> у не <code>Cloneable</code> объекта вызовет выбрасывание <code>CloneNotSupportedException</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_опишите_иерархию_исключений">Опишите иерархию исключений.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Исключения делятся на несколько классов, но все они имеют общего предка&#8201;&#8212;&#8201;класс <code>Throwable</code>, потомками которого являются классы <code>Exception</code> и <code>Error</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ошибки (Errors)</strong> представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине.</p>
</div>
<div class="paragraph">
<p><strong>Исключения (Exceptions)</strong> являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_виды_исключений_в_java_вы_знаете_чем_они_отличаются">Какие виды исключений в Java вы знаете, чем они отличаются?</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_что_такое_checked_и_unchecked_exception">Что такое <em>checked</em> и <em>unchecked exception</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Java все исключения делятся на два типа:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>checked (контролируемые/проверяемые исключения)</strong> должны обрабатываться блоком <code>catch</code> или описываться в заголовке метода (например, <code>throws IOException</code>). Наличие такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;</p>
</li>
<li>
<p><strong>unchecked (неконтролируемые/непроверяемые исключения)</strong>, к которым относятся ошибки <code>Error</code> (например, <code>OutOfMemoryError</code>), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом <code>RuntimeException</code> и его наследниками (например, <code>NullPointerException</code>), которые могут не обрабатываться блоком <code>catch</code> и не быть описанными в заголовке метода.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какой_оператор_позволяет_принудительно_выбросить_исключение">Какой оператор позволяет принудительно выбросить исключение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Это оператор <code>throw</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">throw new Exception();</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_о_чем_говорит_ключевое_слово_throws">О чем говорит ключевое слово <code>throws</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Модификатор <code>throws</code> прописывается в заголовке метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_как_написать_собственное_пользовательское_исключение">Как написать собственное («пользовательское») исключение?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Необходимо унаследоваться от базового класса требуемого типа исключений (например, от <code>Exception</code> или <code>RuntimeException</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CustomException extends Exception {
    public CustomException() {
        super();
    }

    public CustomException(final String string) {
        super(string + " is invalid");
    }

    public CustomException(final Throwable cause) {
        super(cause);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_какие_существуют_unchecked_exception">Какие существуют <em>unchecked exception</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Наиболее часто встречающиеся: <code>ArithmeticException</code>, <code>ClassCastException</code>, <code>ConcurrentModificationException</code>, <code>IllegalArgumentException</code>, <code>IllegalStateException</code>, <code>IndexOutOfBoundsException</code>, <code>NoSuchElementException</code>, <code>NullPointerException</code>, <code>UnsupportedOperationException</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_представляет_из_себя_ошибки_класса_error">Что представляет из себя ошибки класса <code>Error</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ошибки класса <code>Error</code> представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_вы_знаете_о_outofmemoryerror">Что вы знаете о <code>OutOfMemoryError</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>OutOfMemoryError</code> выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.</p>
</div>
<div class="paragraph">
<p>Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип <code>OutOfMemoryError</code> зависит от того, в какой из них не хватило места:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.lang.OutOfMemoryError: Java heap space</code>: Не хватает места в куче, а именно, в области памяти в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается параметрами <code>-Xms</code> и <code>-Xmx</code>.</p>
</li>
<li>
<p><code>java.lang.OutOfMemoryError: PermGen space</code>: (до версии Java 8) Данная ошибка возникает при нехватке места в <em>Permanent</em> области, размер которой задается параметрами <code>-XX:PermSize</code> и <code>-XX:MaxPermSize</code>.</p>
</li>
<li>
<p><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>: Данная ошибка может возникнуть как при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно отключить с помощью параметра <code>-XX:-UseGCOverheadLimit</code>.</p>
</li>
<li>
<p><code>java.lang.OutOfMemoryError: unable to create new native thread</code>: Выбрасывается, когда нет возможности создавать новые потоки.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_опишите_работу_блока_try_catch_finally">Опишите работу блока <em>try-catch-finally</em>.</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>try</code>&#8201;&#8212;&#8201;данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.
<code>catch</code>&#8201;&#8212;&#8201;ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае их возникновения.
<code>finally</code>&#8201;&#8212;&#8201;ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после последнего блока <code>catch</code>. Управление передаётся в блок <code>finally</code> в любом случае, было выброшено исключение или нет.</p>
</div>
<div class="paragraph">
<p>Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    //код, который потенциально может привести к исключительной ситуации
}
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки
    //код обработки исключительной ситуации
}
finally {
    //необязательный блок, код которого выполняется в любом случае
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_механизм_try_with_resources">Что такое механизм <em>try-with-resources</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Данная конструкция, которая появилась в Java 7, позволяет использовать блок <em>try-catch</em> не заботясь о закрытии ресурсов, используемых в данном сегменте кода.
Ресурсы объявляются в скобках сразу после <code>try</code>, а компилятор уже сам неявно создаёт секцию <code>finally</code>, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс <code>java.lang.Autocloseable</code>.</p>
</div>
<div class="paragraph">
<p>Общий вид конструкции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Стоит заметить, что блоки <code>catch</code> и явный <code>finally</code> выполняются уже после того, как закрываются ресурсы в неявном <code>finally</code>.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_возможно_ли_использование_блока_try_finally_без_catch">Возможно ли использование блока <em>try-finally</em> (без <code>catch</code>)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок <code>catch</code>, в котором будет обрабатываться необходимое исключение.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_один_блок_catch_отлавливать_сразу_несколько_исключений">Может ли один блок <code>catch</code> отлавливать сразу несколько исключений?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком <code>catch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    //...
} catch(IOException | SQLException ex) {
    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_всегда_ли_исполняется_блок_finally">Всегда ли исполняется блок <code>finally</code>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Код в блоке <code>finally</code> будет выполнен всегда, независимо от того, выброшено исключение или нет.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_существуют_ли_ситуации_когда_блок_finally_не_будет_выполнен">Существуют ли ситуации, когда блок <code>finally</code> не будет выполнен?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Например, когда JVM «умирает» - в такой ситуации <code>finally</code> недостижим и не будет выполнен, так как происходит принудительный системный выход из программы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    System.exit(0);
} catch(Exception e) {
    e.printStackTrace();
} finally { }</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_может_ли_метод_main_выбросить_исключение_во_вне_и_если_да_то_где_будет_происходить_обработка_данного_исключения">Может ли метод <em>main()</em> выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Может и оно будет передано в виртуальную машину Java (JVM).</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_предположим_есть_метод_который_может_выбросить_ioexception_и_filenotfoundexception_в_какой_последовательности_должны_идти_блоки_catch_сколько_блоков_catch_будет_выполнено">Предположим, есть метод, который может выбросить <code>IOException</code> и <code>FileNotFoundException</code> в какой последовательности должны идти блоки <code>catch</code>? Сколько блоков <code>catch</code> будет выполнено?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок <code>catch(Exception ex) {}</code>, иначе все дальнейшие блоки <code>catch()</code> уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику <code>catch(Exception ex)</code>.</p>
</div>
<div class="paragraph">
<p>Таким образом, исходя из факта, что <code>FileNotFoundException extends IOException</code> сначала нужно обработать <code>FileNotFoundException</code>, а затем уже <code>IOException</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_generics">Что такое <em>generics</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Generics</strong> - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.</p>
</div>
<div class="paragraph">
<p>Примером использования обобщенных типов может служить <em>Java Collection Framework</em>. Так, класс <code>LinkedList&lt;E&gt;</code> - типичный обобщенный тип. Он содержит параметр <code>E</code>, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать <code>LinkedList</code>, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа <code>LinkedList&lt;String&gt;</code>, <code>LinkedList&lt;Integer&gt;</code> и т.п.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_что_такое_интернационализация_локализация">Что такое <em>«интернационализация»</em>, <em>«локализация»</em>?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Интернационализация (internationalization)</strong> - способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках.</p>
</div>
<div class="paragraph">
<p><strong>Локализация (localization)</strong> -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.</p>
</div>
<div class="paragraph">
<p><a href="#java-core">к оглавлению</a></p>
</div>
</div>
</div>
<h1 id="_источники" class="sect0">Источники</h1>
<div class="openblock partintro">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><a href="http://www.quizful.net/interview/java/">Quizful</a></p>
</li>
<li>
<p><a href="http://javastudy.ru/interview/java-oop2/">JavaStudy.ru</a></p>
</li>
<li>
<p><a href="https://ggenikus.github.io/blog/2014/05/04/gc/">ggenikus.github.io</a></p>
</li>
<li>
<p><a href="https://blogs.oracle.com/vmrobot/entry/основы_сборки_мусора_в_hotspot">Санкт-Петербургская группа тестирования JVM</a></p>
</li>
<li>
<p><a href="http://oop-java.blogspot.ru/2006/02/blog-post_21.html">Объектно-ориентированное программирование</a></p>
</li>
<li>
<p><a href="http://info.javarush.ru/">JavaRush</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="README.html">Вопросы для собеседования</a></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-08-19 05:24:56 UTC
</div>
</div>
</body>
</html>