= OOP

== Что такое ООП?

*Объектно-ориентированное программирование* (ООП) — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.

== Какие преимущества у ООП?

* Возможность легкой модификации (при грамотном анализе и проектировании)
* Возможность отката при наличии версий
* Более легкая расширяемость
* «Более естественная» декомпозиция программного обеспечения, которая существенно облегчает его разработку
* Сокращение количества межмодульных вызовов и уменьшение объемов информации, передаваемой̆ между модулями
* Увеличивается показатель повторного использования кода

== Какие недостатки у ООП?

* Требуется другая квалификация
* Резко увеличивается время на анализ и проектирование систем
* Увеличение времени выполнения
* Размер кода увеличивается
* Неэффективно с точки зрения памяти (мертвый код - тот, который не используется)
* Сложность распределения работ на начальном этапе
* Себестоимость больше

== Назовите основные принципы ООП

* Абстракция
* Инкапсуляция
* Наследование
* Полиморфизм

== Что такое инкапсуляция? (С примером)

*Инкапсуляция* – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.

*Инкапсуляция* – это механизм «обёртывания» данных или кода, который работает с этими данными в отдельный модуль. Инкапсулированные, таким образом, переменные, отделены от других классов и доступ к ним возможен только с помощью методов класса, который содержит эти переменные.

Пример: нажимая на педаль газа, мы не знаем и не понимаем что происходит под капотом, класс Автомобиль скрыл от нас реализацию и дал нам инструменты (методы) для работы с этой реализацией.

== Что такое наследование? (С примером)

*Наследование* – это свойство системы, позволяющее описать новый класс на основе уже существующего, частично или полностью заимствуя функциональность родителя. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.

Пример: есть человек родитель, его потомок наследует от него его характеристики, добавляя что-то свое.

== Что такое полиморфизм? (С примером)

*Полиморфизм* – это свойство системы использовать объекты с общим интерфейсом или классом родителем, без информации о типе и внутренней структуре объекта.

Пример: человек может есть еду в общем, будь-то ягоды, овощи или мясо.

== Что такое ассоциация, агрегация и композиция?

Реализуют has-a (имеет) отношения.

has-a отношения основаны на использовании.

Выделяют три варианта отношения has-a: *ассоциация*, *агрегация* и *композиция*.

*Ассоциация* - это когда объекты двух классов могут ссылаться друг на друга. Например, класс `Horse` has-a `Halter` если код в классе `Horse` содержит ссылку на экземпляр класса `Halter`.

*Агрегация* и *композиция* являются частными случаями ассоциации.

*Агрегация* - отношение, когда один объект является частью другого.

*Композиция* - еще более тесная связь, когда объект не только является частью другого объекта, но и вообще не может принадлежать другому объекту.

*Агрегация*: объект класса `Halter` создается извне `Horse` и передается в конструктор для установления связи, если объект класса `Horse` будет удален, объект класса `Halter` может и дальше использоваться, если, конечно, на него останется ссылка.

*Композиция*: объект класса `Halter` создается в конструкторе, что означает более тесную связь между объектами, объект класса `Halter` не может существовать без создавшего его объекта `Horse`.

== Что значит "is a" (является), имеет - "has a" (содержит)?

«является» подразумевает наследование.

«содержит» подразумевает ассоциацию (агрегацию или композицию).

== Расскажите про раннее (статическое) и позднее (динамическое) связывание

Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).

В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не статический и не был объявлен как final (приватные методы являются final по умолчанию).

== Расскажите про SOLID

*Принцип единственной ответственности* - класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.

*Принцип открытости-закрытости*- программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

*Принцип подстановки Барбары Лисков* - необходимо, чтобы подклассы могли служить заменой для своих суперклассов.

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

*Принцип разделения интерфейса* - создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют. Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.

*Принцип инверсии зависимостей*- объектом зависимости должна быть абстракция, а не что-то конкретное. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. В процессе разработки программного обеспечения существует момент, когда функционал приложения перестает помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.